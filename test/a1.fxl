#!bin/fexl

use "test/common.fxl" \\

\test_built_in_pattern=
(
\result==test_pattern
show result
)

\test_forms=
(
say "== test_forms"
show (\x\y x)            # C
show (\x\y\z x z; y z)   # S
show (\x x)              # I
show (\"x" "x")          # I
show (\x "x")            # (C "x")
show (\x\y\z x; y z)     # R
show (\x\y\z x z y)      # L
show (\x\y y x)          # (L I)
show (\x\y\z ((x z) (y z)) ((x z) (y z)))  # ((S ((R S) ((R (R S)) S))) S)
show ()           # I
show (()(()))     # I
show ((())()"x")  # (I "x")

show! (I; C {x} I)
show! {string_len "abcd"}

show!
	(
	\x={x}
	\y={y}
	\z={z}
	S x y z
	)
)

\test_putchar=
(
say "== test_putchar"
putchar 97
putchar 98
putchar 99
putchar 10
)

\test_fputc=
(
say "== test_fputc"
\putchar=(fputc stdout)
putchar 97
putchar 98
putchar 99
putchar 100
putchar 10
)

\test_readlink=
(
say "== test_readlink"
\bin_path==(readlink "/proc/self/exe")
say bin_path
say base_path
)

\test_inf=
	(
	\inf=(@ I) # infinite loop
	inf
	)

\test_getc=
(
say "== test_getc"
\f=
(
putchar 63
\ch==(fgetc stdin)
#\ch==getchar
putchar 33 putchar ch putchar 10
)

f f
)

\test_say=
(
say "== test_say"
say "Hello world."

(
print_to stderr \print\nl\say
say ["This goes to " "stderr."]
)

# Ensure that say eagerly evaluates its arguments.
\x=(long_add 1 4)
say ["x = " (fwrite stdout "!"; x)]

# Ensure that saying a weird form works well, and doesn't hang.
say "x"
say C
say Y
say S
say (S "x")
say ((S "x") (S "y"))
)

\test_ping=
(
say "== test_ping"
\ping=(ping ping)
\ping=(ping ping)
ping
)

\test_long=
(
say "== test_long"
\+ = long_add
\- = long_sub
\* = long_mul
\/ = long_div
\cmp = long_cmp

\try=say

try (+ 0 0)
try (+ 1 2)
try (- 1 2)
try (+ 42 37)
try (* 5 3)
try (* 5 0)
try (/ 29 4)
try (/ 0 0)
try (/ 1 0)
try (\x=(* 7 3) + x x)
nl

try (cmp 0 0)
try (cmp 1 1)
try (cmp -1 -1)

try (cmp 0 1)
try (cmp -1 0)
try (cmp 1 2)

try (cmp 1 0)
try (cmp 0 -1)
try (cmp 2 1)
nl

try 0
try 1
try -1
try 57
try -57

# Test highest and lowest 64-bit signed values.
try 9223372036854775807   #  2^63 - 1
try -9223372036854775808  # -2^63

# Try it with some arithmetic.
try (- 0; + 1 -9223372036854775808)  #   2^63 - 1
try (- -1 9223372036854775807)       #  -2^63

# Test over/underflow.
try 18446744073709551615    #  2^64 - 1
try -18446744073709551616   # -2^64

say "= order"
\try=
	(\x
	\y=(order x "LT" "EQ" "GT")
	say y
	)
try -2
try -1
try 0
try 1
try 2

say "= long_double"
\try=(\x say (long_double x))

try 4
try 0
try -1
try -37
try 126478

say "= long_char"
\try=(\x say (long_char x))

try 97
try 98
try 99
try 100
)

\test_double=
(
say "== test_double"

\+ = double_add
\- = double_sub
\* = double_mul
\/ = double_div
\cmp = double_cmp

\try=say

try
	(
	\x=(+ 13.2 4.5)
	\x=(+ x x)
	\x=(/ x 0.5)
	x
	)

# On some machines this yields -nan, on others it's nan.  I'm avoiding this
# issue.
#try (/ 0.0 0.0)  # -nan
try
	(
	\x = (/ 0.0 0.0)
	\x=(double_string x)
	\x=(string_eq x "-nan" "nan" x)
	x
	)

try (/ 1.0 0.0)  # inf
try (/ -1.0 0.0) # -inf

try
	(
	\pi=3.14159265358979323846
	\tau=(* 2.0 pi)
	tau
	)

try (- 1e5 1.0)
try -907.285
try 42.333
nl

try (cmp 0.0 0.0)
try (cmp 1.0 1.0)
try (cmp -1.0 -1.0)

try (cmp 0.0 1.0)
try (cmp -1.0 0.0)
try (cmp 1.0 2.0)

try (cmp 1.0 0.0)
try (cmp 0.0 -1.0)
try (cmp 2.0 1.0)

# Ensure that double_cmp returns a long value.
\Cmp=(\x\y order (cmp x y) "LT" "EQ" "GT")
try (Cmp -2.0 0.0)
try (Cmp -1.0 0.0)
try (Cmp 1.2 1.3)
try (Cmp 0.0 0.0)
try (Cmp 1.2 1.2)
try (Cmp 1.0 0.0)
try (Cmp 2.0 0.0)
try (Cmp 5.6 5.5)

say "= double_long"
\try=(\x say (double_long x))

try 4.0
try 0.0
try -1.0
try -37.0
try 126478.0
try 4.3
try 0.3
try -1.3
try -37.3
try 126478.3
try 4.9
try 0.9
try -1.9
try -37.9
try 126478.9
try -126478.9
)

\test_string_common=
(
say "== test_string_common"
\x="abcdef"
\y="abcDEF"
\x=(concat x "")
\y=(concat y "")
say (string_common x y)
)

\test_string_len=
(
say "== test_string_len"
\try=(\x say (string_len x))
try ""
try "a"
try ~ "~
try (concat "a" "b")
try (concat "abc" "de")
try ~
hello
~
)

\test_string_cmp=
(
say "== test_string_cmp"
\try=(\x\y say (string_cmp x y))

# -1
try "" "a"
try "a" "b"
try "abc" "abcd"
# 0
try "" ""
try "a" "a"
try "abc" "abc"
# 1
try "a" ""
try "b" "a"
try "abcd" "abc"
)

\test_string_at=
(
say "== test_string_at"
\try=(\str\pos say (string_at str pos))

try "" -1
try "" 0
try "" 1
try "a" -1
try "a" 0
try "a" 1
try "abc" 0
try "abc" 1
try "abc" 2
try (concat "abc" "def") 3
)

\test_string_long=
(
say "== test_string_long"
\try=
	(\x
	say (string_long x "no" \n ["yes " n])
	)

try "0"
try "1"
try "-1"
try "123"
try "-123"
try "x123"
try "1x23"
try ""
try "   456   "
try "456   "
try "1.6"
try "0."
)

\test_string_double=
(
say "== test_string_double"
\try=
	(\x
	say (string_double x "no" \n ["yes " n])
	)

try "0"
try "1"
try "-1"
try "123"
try "-123"
try "x123"
try "1x23"
try ""
try "   456   "
try "   456.78   "
try "456.78"
try "456   "
try "1.6"
try "0."
try "-0"
try "-0.0"
try "-0.0123"
try "3.14159265358979323846"
try "1e0"
try "1.2e5"
try "-2.84e-6"
)

\test_string_slice =
(
say "== test_string_slice"
\try=
	(\str\pos\len
	Say ["try" (qu str) pos len "=" (qu; string_slice str pos len)]
	)

# Normal cases
try "" 0 0
nl
try "a" 0 0
try "a" 0 1
try "a" 1 0
nl
try "abc" 0 0
try "abc" 0 1
try "abc" 0 2
try "abc" 0 3
try "abc" 1 0
try "abc" 1 1
try "abc" 1 2
try "abc" 2 0
try "abc" 2 1

# Negative position
nl
try "" -1 0 # Perl gives warning.
try "" -1 1
try "" -1 2
nl
try "a" -1 0
try "a" -1 1
try "a" -1 2
nl
try "abcd" -1 0
try "abcd" -1 1
try "abcd" -1 2
try "abcd" -1 3
try "abcd" -1 4
try "abcd" -1 5
try "abcd" -1 6
nl
try "abcd" -2 0
try "abcd" -2 1
try "abcd" -2 2
try "abcd" -2 3
try "abcd" -2 4
try "abcd" -2 5
try "abcd" -2 6
try "abcd" -2 7

try "a" -1 0
try "a" -1 1
try "a" -1 2
try "a" -2 1
try "a" -7 6
try "abcdefg" -4 2
try "abcdefg" -6 3
try "abcdefg" -7 3
try "abcdefg" -8 3
try "abcdefg" -8 2
try "abcdefg" -8 1
try "abcdefg" -8 0 # Perl gives warning.

# Negative length
nl
try "abcd" 0 -1
try "abcd" 2 -1
try "abcd" 2 -3

# Various out of bounds
nl
try "" 0 1
try "" 1 2 # test max < 0.  Perl gives warning.
try "a" 0 2
try "a" 1 1
try "abc" 0 4
try "abc" 2 2
try "abcde" 0 700
try "abcde" 0 6

# Run through some possibilities.
nl
try "abc" -1 0
try "abc" -1 1
try "abc" -1 2
try "abc" -1 3
try "abc" -1 4
try "abc" -1 5
nl
try "abc" 0 0
try "abc" 0 1
try "abc" 0 2
try "abc" 0 3
try "abc" 0 4
nl
try "abc" 1 0
try "abc" 1 1
try "abc" 1 2
try "abc" 1 3
nl
try "abc" 2 0
try "abc" 2 1
try "abc" 2 2

nl
try "a" 0 1
try "a" -1 2
try "a" -2 3
try "a" -2 4
try "a" -2 0 # Perl gives warning.

nl
try "abcde" 0 5
try "abcde" -1 5
try "abcde" -2 5
try "abcde" -3 5
try "abcde" -4 5
try "abcde" -5 5
try "abcde" -5 6
try "abcde" -5 7
try "abcde" -5 8
try "abcde" -5 9
try "abcde" -5 10
try "abcde" -5 900
nl
try "" 0 800
try "" -30 800
nl
try "a" 0 9223372036854775807
try "a" 1 9223372036854775807
try "a" -9223372036854775808 9223372036854775807
try "a" -7 6
try "a" 9223372036854775807 -9223372036854775808
	# test max < 0.  Perl gives warning.
)

\test_string_index =
(
say "== test_string_index"
\try=
	(\haystack\needle\offset
	Say ["try" (qu haystack) (qu needle) offset "="
		(string_index haystack needle offset)]
	)

# NOTE: All of these results agree with the results of Perl's built-in "index"
# function, and were confirmed with a Perl script.

try "abcdefg" "de" 0 # 3

try "abcdefg" "de" 2 # 3
try "abcdefg" "de" 3 # 3
try "abcdefg" "de" 4 # -1

try "" "" 0 # 0
try "" "a" 0 # -1
try "" "" -1 # 0

try "abcdefghijklmnop" "" 0 # 0
try "abcdefghijklmnop" "" 7 # 7
try "abcdefghijklmnop" "" 15 # 15

try "abcdefghijklmnop" "ghI" 0 # -1
try "abcdefghijklmnop" "ghi" 0 # 6
try "abcdefghijklmnop" "mnop" 0 # 12
try "abcdefghijklmnop" "mnopq" 0 # -1
try "abcdefghijklmnop" "p" 0 # 15
try "abcdefghijklmnop" "q" 0 # -1
try "abcdefghijklmnop" "abcdefghijklmnop" 0 # 0
try "abcdefghijklmnop" "abcdefghijklmnop" 1 # -1
try "abcdefghijklmnop" "abcdefghijklmnopq" 0 # -1
try "a" "ab" 0 # -1
try "a" "a" 0 # 0
)

\test_argv=
(
say "== test_argv"

\try=(\n say (argv n))

say argc
try -1
try 0
try 1
try 2
)

\test_later=
(
say "== test_later"
# Test peeling off "later" layers with eager evaluation.
\f=(I T)
\f=(later f)
\f=(later f)
show f
\f==f  show f
\f==f  show f
\f==f  show f
)

\test_file=
(
say "== test_file"
\try=
	(\name
	print ["fopen " name " : "]
	\fh==(fopen name "r")
	print (fh "no" \fh "yes") nl
	)
show stdin
show stdout
show stderr
try "test/a1.fxl"
try "test/a1x.fxl"
)

\test_list=
(
say "== test_list"
\try=Say

try []
try ["a"]
try ["a" "b"]

\tail=["c" "d"]
try ["a" "b"; tail]

try ["a" "b"; append tail tail]

\list=["x" "y"]
\list=(append list list)
\list=(append list list)
try list

# Check the built-in pair function.
pair "x" "y" \x\y
say x
say y
)

\test_var=
(
say "== test_var"
\x==var
\show_val=(say ["x contains " x])

print "x is " show! x
set x (long_add 4 3)
print "x is " show! x
show_val
set x (long_mul 6 (get x))
show_val
)

\test_parse=
(
say "== test_parse"
say ["Parsing the tail of " source_name " on line " source_line]
parse source_file "test" source_line \form\line
print "== form      = " show form
\exp==(resolve form yes source_context source_name T)
say "== Now evaluate"
\exp==exp
print "== value     = " show exp
)

\test_lib=
(
say "== test_lib"
\lib==(dlopen "lib/fexl/liblong.so")
\try=
	(\name
	\fn=(dlsym lib name)
	say ["Symbol " name (long_eq fn 0 " does not exist." " exists.")]
	)
try "fexl_long_string"
try "foobar"
try "fexl_order"
try "string_long"
try "op_cmp"
)

\test_all=
(
test_built_in_pattern
test_forms
test_putchar
test_fputc
test_readlink
#test_inf
#test_getc
test_say
test_ping
test_long
test_double
test_string_common
test_string_len
test_string_cmp
test_string_at
test_string_long
test_string_double
test_string_slice
test_string_index
test_argv
test_later
test_file
test_list
test_var
test_lib
test_parse
)

test_all

# For testing purposes the tail program below starting with "\x=3" appears
# immediately after the virtual EOF "\\".  Normally there'd be a newline.
\\\x=3
\talk=(say ["x = " x])
\talk=(talk talk)
talk

\\

# LATER test some syntax errors by forking a process.
# Missing lambda symbol:
#\= \\

# Missing definition:
#\x= \\

# Just an undefined var:
#x
