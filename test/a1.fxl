#

# Missing lambda symbol:
#\= \\
# Missing definition:
#\x= \\

# TODO detect (Q 0) and die instead */

\load_path=
	(\lib_name\type_name
	Q (dlsym (dlopen lib_name) type_name)
	)

\load=(load_path "")

\.==(load "type_string_append")

\load_from=
	(\lib_name\type_name
	\path=(. base_path; . "lib/fexl/" lib_name)
	load_path path type_name
	)

\eval=(\x \x==x x)
\T=(\T\F T)
\F=(\T\F F)

\S==(load "type_S")
\C==(load "type_C")
\I==(load "type_I")
\@==(load "type_Y")

\long_add==(load "type_long_add")
\putchar==(load "type_putchar")
\getchar==(load "type_getchar")
\fputc==(load "type_fputc")
\fgetc==(load "type_fgetc")
\fwrite==(load_from "libqfile2.so" "type_fwrite")

\stdin==(eval (load "type_stdin"))
\stdout==(eval (load "type_stdout"))
\stderr==(eval (load "type_stderr"))

\show==(load_from "libshow.so" "type_show")
\test==(load_from "libtest.so" "type_test_pattern")
\test==test

show test
#show stdin
#show stdout
#show stderr

(
show (\x\y x)            # C
show (\x\y\z x z; y z)   # S
show (\x x)              # I
show (\"x" "x")          # I
show (\x\y\z x; y z)     # R
show (\x\y\z x z y)      # L
show (\x\y y x)          # (L I)
)

(
putchar 97
putchar 98
putchar 99
putchar 10
)

I
(
\putchar=(fputc stdout)
putchar 97
putchar 98
putchar 99
putchar 100
putchar 10
)

I
(
\readlink==(load_from "libqfile2.so" "type_readlink")
\bin_path==(readlink "/proc/self/exe")
show bin_path
)

I
(
\test=(I; C {x} I)
\test==test
show test
)

F
(
\inf=(@ I) inf
)

I
(
\f=={string_len "abcd"}
show f
)

I
(
\x={x}
\y={y}
\z={z}

\f==(S x y z)
show f
)

F
(
\f=
(
putchar 63
\ch==(fgetc stdin)
putchar 33 putchar ch putchar 10
)

f f
)


(
\fprint=(\fh\x fwrite fh x)  # TODO will allow x to be nested list

\NL="
"

\print_to=
	(\out
	\print=(fprint out)
	\nl=(print NL)
	\say=(\x print x nl)
	\: : print nl say
	)

print_to stdout \print\nl\say
say "Hello world."

(
print_to stderr \print\nl\say
say "This goes to stderr."
)

)

\\\\


\string_append==(Q; dlsym (dlopen "") "type_string_append")
\string_common==(Q; dlsym (dlopen "") "type_string_common")
\string_at==(Q; dlsym (dlopen "") "type_string_at")
\string_cmp==(Q; dlsym (dlopen "") "type_string_cmp")
\length==(Q; dlsym (dlopen "") "type_string_len")
\long_add==(Q (dlsym (dlopen "") "type_long_add"))
\long_div==(Q (dlsym (dlopen "") "type_long_div"))
\double_add==(Q (dlsym (dlopen "") "type_double_add"))
\double_div==(Q (dlsym (dlopen "") "type_double_div"))
\+==long_add
\.=string_append

#\x=(string_append "Hello " "world.  ")
#\x=(string_append x x)
#x

#\x="abcdef"
#\y="abcDEF"
#\x=(string_append x "")
#\y=(string_append y "")
#string_common x y

#string_at (. "abc" "def") (+ 1 2)  # 100

#length (. "abc" "de")  # 5

#string_cmp "abc" "abcd"

#\x=(long_div 13 4)
#\x=(long_add x x)
#x

\x=(double_add 13.2 4.5)
\x=(double_add x x)
\x=(double_div x 0.5)
x

#double_div 0.0 0.0  # -nan
#double_div 1.0 0.0  # inf
#double_div -1.0 0.0  # -inf

#long_div 12 0  # 0

\\\\

\later==(Q; dlsym (dlopen "") "type_later")
\I==(Q; dlsym (dlopen "") "type_I")
\C==(Q; dlsym (dlopen "") "type_C")
\?==(Q; dlsym (dlopen "") "type_query")
#later later
#later (I C)
#? (I C) I

#? (later; later (I C)) I


# Test peeling off "later" layers with eager evaluation.
\f=(I C)
\f=(later f)
\f=(later f)
\f==f
\f==f
f


\\\\

# (later C)
\C=(Q; dlsym (dlopen "") "type_C")
C

\\\\

\ping==(Q; dlsym (dlopen "libping.so") "type_ping")
\ping=(ping ping)
\ping=(ping ping)
ping

\\\\

\readlink==(Q (dlsym (dlopen "") "type_readlink"))
readlink "/proc/self/exe"

\\\

#argv 0
#argv 1
#argv 2
#argv -1

#\+==(Q (dlsym (dlopen "") "type_long_add"))
#+ 42 37

\pi=3.14159265358979323846
\*==(Q (dlsym (dlopen "") "type_double_mul"))
* 2.0 pi

#42 3.14159265358979323846
#1e5

\\

\x=dlopen
C
	S "abc" x
	source_file
	source_name
	source_line

#C {x}

#C (string_len "abc") I
#C S I

#~ "~
#x

#:: f = ((C {{string_len :14} {"abc" :17}}) I)
#:: g = {{string_len :14} {"abc" :17}}


\\\
# Good test case for the need to hold things correctly in the abstract routine.
# ((S ((R S) ((R (R S)) S))) S)
(\x\y\z ((x z) (y z)) ((x z) (y z)))

\\\

#\x x # I
#\x y # C y
#\x\y y x  # L I

#(\S=(\x\y\z (x z) (y z)) \x S x)  # S
#(\S=(\x\y\z (x z) (y z)) S) # S

#\x\y\z x z y # L
#\x\y\z x (y z)  # R
#(\x\y\z x; y z)  # R

\\\\

#\x=C x
#\x=() x
#\x=(()()()) x

#\x=(C) x
#\x=C x
#\x=(() () C) x

#\x=(C S) x

#\x="" x
#\x=~ "~ x
#\x=~ ~ x

#\x=
#\x=S
#\x=C x

#\
#=
#\x
#\ =

#\=

#\ = = eq (=)

#\x==(+ 3 4) x

\\\\

#\f=(\x\y\z (x z) (y z)) f

#\f=(\x\y x) f
#\f=(\x x) f
#\f=() f

#\=(\x x)

#\()
#\=()
#\==()
#\f=

#\
#\ \

#\ =

#\ \(\x\y x)

#\x

#\ \=

#\
#\x

#\=3
#\ = = eq
#=


\f=

\\\\\

#\x x
#\"x" "x"
#\"x" x
\x "x"

#"hi"

#~ foo~
~
hello there
bye now
~
