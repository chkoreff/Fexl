#!bin/fexl

# TODO detect (Q 0) and die instead */
\load=(\lib\name Q (dlsym lib name))

\load_bin==(\lib==(dlopen "") load lib)

\string_append==(load_bin "type_string_append")
\.==string_append

\load_from=
	(\name
	\path==(. "lib/fexl/"; . "lib"; . name ".so")
	\path==(. base_path path)
	\lib==(dlopen path)
	load lib
	)

# TODO open these lazily, one time, on demand only.
\load_long==(load_from "long2")
\load_double==(load_from "double2")
\load_str==(load_from "qstr2")
\load_system==(load_from "system")
\load_file==(load_from "qfile2")
\load_test==(load_from "test")
\load_show==(load_from "show")

\eval=(\x \x==x x)
\T=(\T\F T)
\F=(\T\F F)

\S==(load_bin "type_S")
\C==(load_bin "type_C")
\I==(load_bin "type_I")
\L==(load_bin "type_L")
\@==(load_bin "type_Y")

##
\long_add==(load_long "type_long_add")
\long_sub==(load_long "type_long_sub")
\long_mul==(load_long "type_long_mul")
\long_div==(load_long "type_long_div")
\long_cmp==(load_long "type_long_cmp")
\order==(load_long "type_order")
\long_string==(load_long "type_long_string")

##
\double_add==(load_double "type_double_add")
\double_sub==(load_double "type_double_sub")
\double_mul==(load_double "type_double_mul")
\double_div==(load_double "type_double_div")
\double_cmp==(load_double "type_double_cmp")
\double_string==(load_double "type_double_string")

##
\string_len==(load_str "type_string_len")
\string_cmp==(load_str "type_string_cmp")
\string_at==(load_str "type_string_at")
\string_common==(load_str "type_string_common")

##
\argc==(eval; load_system "type_argc")
\argv==(load_system "type_argv")

##
\putchar==(load_file "type_putchar")
\getchar==(load_file "type_getchar")
\fputc==(load_file "type_fputc")
\fgetc==(load_file "type_fgetc")
\fwrite==(load_file "type_fwrite")

\stdin==(eval; load_file "type_stdin")
\stdout==(eval; load_file "type_stdout")
\stderr==(eval; load_file "type_stderr")

\readlink==(load_file "type_readlink")
\fopen==(load_file "type_fopen")

\fprint=(\fh\x fwrite fh x)  # TODO will allow x to be nested list

\NL="
"

\print_to=
	(\out
	\print=(fprint out)
	\nl=(print NL)
	\say=(\x print x nl)
	\: : print nl say
	)

print_to stdout \print\nl\say

\show==(load_show "type_show")

## test functions

\test_built_in_pattern=
(
\test==(load_test "type_test_pattern")
\test==test

show test
#show stdin
#show stdout
#show stderr
)

\test_forms=
(
say "== test_forms"
\show!=
	(\x
	\x==x
	show x
	)

show (\x\y x)            # C
show (\x\y\z x z; y z)   # S
show (\x x)              # I
show (\"x" "x")          # I
show (\x "x")            # (C "x")
show (\x\y\z x; y z)     # R
show (\x\y\z x z y)      # L
show (\x\y y x)          # (L I)
show (\x\y\z ((x z) (y z)) ((x z) (y z)))  # ((S ((R S) ((R (R S)) S))) S)
show ()           # I
show (()(()))     # I
show ((())()"x")  # (I "x")

show! (I; C {x} I)
show! {string_len "abcd"}

show!
	(
	\x={x}
	\y={y}
	\z={z}
	S x y z
	)
)

\test_putchar=
(
say "== test_putchar"
putchar 97
putchar 98
putchar 99
putchar 10
)

\test_fputc=
(
say "== test_fputc"
\putchar=(fputc stdout)
putchar 97
putchar 98
putchar 99
putchar 100
putchar 10
)

\test_readlink=
(
say "== test_readlink"
\bin_path==(readlink "/proc/self/exe")
say bin_path
)

\test_inf=
	(
	\inf=(@ I) # infinite loop
	inf
	)

\test_getc=
(
say "== test_getc"
\f=
(
putchar 63
\ch==(fgetc stdin)
#\ch==getchar
putchar 33 putchar ch putchar 10
)

f f
)

\test_say=
(
say "== test_say"
say "Hello world."

(
print_to stderr \print\nl\say
say "This goes to stderr."
)

)

\test_ping=
(
say "== test_ping"
\ping==(load_test "type_ping")
\ping=(ping ping)
\ping=(ping ping)
ping
)

\test_long=
(
say "== test_long"
\+ = long_add
\- = long_sub
\* = long_mul
\/ = long_div
\cmp = long_cmp

\try=(\x say (long_string x))

try (+ 0 0)
try (+ 1 2)
try (- 1 2)
try (+ 42 37)
try (* 5 3)
try (* 5 0)
try (/ 29 4)
try (/ 0 0)
try (/ 1 0)
try (\x=(* 7 3) + x x)
nl

try (cmp 0 0)
try (cmp 1 1)
try (cmp -1 -1)

try (cmp 0 1)
try (cmp -1 0)
try (cmp 1 2)

try (cmp 1 0)
try (cmp 0 -1)
try (cmp 2 1)
nl

try 0
try 1
try -1
try 57
try -57

# Test highest and lowest 64-bit signed values.
try 9223372036854775807   #  2^63 - 1
try -9223372036854775808  # -2^63

# Try it with some arithmetic.
try (- 0; + 1 -9223372036854775808)  #   2^63 - 1
try (- -1 9223372036854775807)       #  -2^63

# Test over/underflow.
try 18446744073709551615    #  2^64 - 1
try -18446744073709551616   # -2^64

say "= order"
\try=
	(\x
	\y=(order x "LT" "EQ" "GT")
	say y
	)
try -2
try -1
try 0
try 1
try 2
)

\test_double=
(
say "== test_double"

\+ = double_add
\- = double_sub
\* = double_mul
\/ = double_div
\cmp = double_cmp

\try=(\x say (double_string x))

try
	(
	\x=(+ 13.2 4.5)
	\x=(+ x x)
	\x=(/ x 0.5)
	x
	)

try (/ 0.0 0.0)  # -nan
try (/ 1.0 0.0)  # inf
try (/ -1.0 0.0) # -inf

try
	(
	\pi=3.14159265358979323846
	\tau=(* 2.0 pi)
	tau
	)

try (- 1e5 1.0)
try -907.285
try 42.333
nl

try (cmp 0.0 0.0)
try (cmp 1.0 1.0)
try (cmp -1.0 -1.0)

try (cmp 0.0 1.0)
try (cmp -1.0 0.0)
try (cmp 1.0 2.0)

try (cmp 1.0 0.0)
try (cmp 0.0 -1.0)
try (cmp 2.0 1.0)
)

\test_string_common=
(
say "== test_string_common"
\x="abcdef"
\y="abcDEF"
\x=(. x "")
\y=(. y "")
\n==(string_common x y)
say (long_string n)
)

\test_string_len=
(
say "== test_string_len"
\try=(\x say (long_string; string_len x))
try ""
try "a"
try ~ "~
try (. "a" "b")
try (. "abc" "de")
try ~
hello
~
)

\test_string_cmp=
(
say "== test_string_cmp"
\try=(\x\y say (long_string; string_cmp x y))

# -1
try "" "a"
try "a" "b"
try "abc" "abcd"
# 0
try "" ""
try "a" "a"
try "abc" "abc"
# 1
try "a" ""
try "b" "a"
try "abcd" "abc"
)

\test_string_at=
(
say "== test_string_at"
\try=(\str\pos say (long_string; string_at str pos))

try "" -1
try "" 0
try "" 1
try "a" -1
try "a" 0
try "a" 1
try "abc" 0
try "abc" 1
try "abc" 2
try (. "abc" "def") 3
)

\test_argv=
(
say "== test_argv"

\try=(\n say (argv n))

say (long_string argc)
try -1
try 0
try 1
try 2
)

\test_later=
(
say "== test_later"
\later==(load_bin "type_later")

# Test peeling off "later" layers with eager evaluation.
\f=(I C)
\f=(later f)
\f=(later f)
show f
\f==f  show f
\f==f  show f
\f==f  show f
)

\test_file=
(
say "== test_file"
\try=
	(\name
	print "fopen " print name print " : "
	\fh==(fopen name "r")
	print (fh "no" \fh "yes") nl
	)
try "test/a1.fxl"
try "test/a1x.fxl"
)

\test_list=
(
say "== test_list"
\try=
	(\list
	\print_items=
		(
		@\loop\list
		list () \h\t
		print h
		print " "
		loop t
		)
	print_items list nl
	)

\append=(@\append\x\y x y \h\t [h;append t y])

try []
try ["a"]
try ["a" "b"]

\tail=["c" "d"]
try ["a" "b"; tail]

try ["a" "b"; append tail tail]

\list=["x" "y"]
\list=(append list list)
\list=(append list list)
try list
)

\test_parse=
(
say "== test_parse"
\parse==(load_bin "type_parse")
\pop_symbol==(load_bin "type_pop_symbol")
\look_symbol==(load_bin "type_look_symbol")
print "Parsing the tail of " print source_name
print " on line "
print (long_string source_line)
nl
parse source_file "test" source_line \form\line
print "form " show form
#print "line " show line

\resolve=
	(@\resolve
	\form

	pop_symbol form form \sym\form
	look_symbol sym \label\is_name\line

	print "symbol "
	#print "(line " print (long_string line) print ") "
	print (is_name "name" "string") print ": " print label nl
	print "form " show form
	nl
	resolve form
	)

say "== Loop through symbols"
\form==(resolve form)
)

## main
test_built_in_pattern
test_forms
test_putchar
test_fputc
test_readlink
#test_inf
#test_getc
test_say
test_ping
test_long
test_double
test_string_common
test_string_len
test_string_cmp
test_string_at
test_argv
test_later
test_file
test_list
test_parse

# For testing purposes the tail program below starting with "\x=3" appears
# immediately after the virtual EOF "\\".  Normally there'd be a newline.
\\\x=3

\hello=(say "Hello world." say (long_string x))
hello
hello

\\

# LATER test some syntax errors after you do error propagation in parse.c.
# Missing lambda symbol:
#\= \\

# Missing definition:
#\x= \\
