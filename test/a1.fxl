#

# Missing lambda symbol:
#\= \\
# Missing definition:
#\x= \\

# TODO detect (Q 0) and die instead */

\load=(\lib_name\sym_name Q; dlsym (dlopen lib_name) sym_name)
\.==(load "" "type_string_append")
\long_add==(load "" "type_long_add")

# TODO automatically put base_path if name is not null
\library=(\name . base_path; . "lib/fexl/" name)

\show==(load (library "libshow.so") "type_show")

\test==(load (library "libtest.so") "type_test_pattern")
\test==test
\test==(long_add 4 2)

\C==(load "" "type_C")

show test
show "bye"
show C
#\x==(library "X") show x
\x==base_path show x

\\\\

# Don't need to use base_path when opening "" library.
\readlink==(Q (dlsym (dlopen "") "type_readlink"))
\bin_path==(readlink "/proc/self/exe")
bin_path
\\\\

\C==(Q (dlsym (dlopen "") "type_C"))
\I==(Q (dlsym (dlopen "") "type_I"))
(I; C {x} I)
\\

\@==(Q (dlsym (dlopen "") "type_Y"))
\I==(Q (dlsym (dlopen "") "type_I"))
\inf=(@ I)
\\

\C==(Q (dlsym (dlopen "") "type_C"))
\f={string_len "abcd"}
C f C

\\

\C==(Q (dlsym (dlopen "") "type_C"))
\S==(Q (dlsym (dlopen "") "type_S"))
\I==(Q (dlsym (dlopen "") "type_I"))

\x={x}
\y={y}
\z={z}

S x y z

\\\


\string_append==(Q; dlsym (dlopen "") "type_string_append")
\string_common==(Q; dlsym (dlopen "") "type_string_common")
\string_at==(Q; dlsym (dlopen "") "type_string_at")
\string_cmp==(Q; dlsym (dlopen "") "type_string_cmp")
\length==(Q; dlsym (dlopen "") "type_string_len")
\long_add==(Q (dlsym (dlopen "") "type_long_add"))
\long_div==(Q (dlsym (dlopen "") "type_long_div"))
\double_add==(Q (dlsym (dlopen "") "type_double_add"))
\double_div==(Q (dlsym (dlopen "") "type_double_div"))
\+==long_add
\.=string_append

#\x=(string_append "Hello " "world.  ")
#\x=(string_append x x)
#x

#\x="abcdef"
#\y="abcDEF"
#\x=(string_append x "")
#\y=(string_append y "")
#string_common x y

#string_at (. "abc" "def") (+ 1 2)  # 100

#length (. "abc" "de")  # 5

#string_cmp "abc" "abcd"

#\x=(long_div 13 4)
#\x=(long_add x x)
#x

\x=(double_add 13.2 4.5)
\x=(double_add x x)
\x=(double_div x 0.5)
x

#double_div 0.0 0.0  # -nan
#double_div 1.0 0.0  # inf
#double_div -1.0 0.0  # -inf

#long_div 12 0  # 0

\\\\

\later==(Q; dlsym (dlopen "") "type_later")
\I==(Q; dlsym (dlopen "") "type_I")
\C==(Q; dlsym (dlopen "") "type_C")
\?==(Q; dlsym (dlopen "") "type_query")
#later later
#later (I C)
#? (I C) I

#? (later; later (I C)) I


# Test peeling off "later" layers with eager evaluation.
\f=(I C)
\f=(later f)
\f=(later f)
\f==f
\f==f
f


\\\\

# (later C)
\C=(Q; dlsym (dlopen "") "type_C")
C

\\\\

\ping==(Q; dlsym (dlopen "libping.so") "type_ping")
\ping=(ping ping)
\ping=(ping ping)
ping

\\\\

\readlink==(Q (dlsym (dlopen "") "type_readlink"))
readlink "/proc/self/exe"

\\\

#argv 0
#argv 1
#argv 2
#argv -1

#\+==(Q (dlsym (dlopen "") "type_long_add"))
#+ 42 37

\pi=3.14159265358979323846
\*==(Q (dlsym (dlopen "") "type_double_mul"))
* 2.0 pi

#42 3.14159265358979323846
#1e5

\\

\x=dlopen
C
	S "abc" x
	source_file
	source_name
	source_line

#C {x}

#C (string_len "abc") I
#C S I

#~ "~
#x

#:: f = ((C {{string_len :14} {"abc" :17}}) I)
#:: g = {{string_len :14} {"abc" :17}}


#say "Hello world." # TODO

\\\
# Good test case for the need to hold things correctly in the abstract routine.
# ((S ((R S) ((R (R S)) S))) S)
(\x\y\z ((x z) (y z)) ((x z) (y z)))

\\\

#\x x # I
#\x y # C y
#\x\y y x  # L I

#(\S=(\x\y\z (x z) (y z)) \x S x)  # S
#(\S=(\x\y\z (x z) (y z)) S) # S

#\x\y\z x z y # L
#\x\y\z x (y z)  # R
#(\x\y\z x; y z)  # R

\\\\

#\x=C x
#\x=() x
#\x=(()()()) x

#\x=(C) x
#\x=C x
#\x=(() () C) x

#\x=(C S) x

#\x="" x
#\x=~ "~ x
#\x=~ ~ x

#\x=
#\x=S
#\x=C x

#\
#=
#\x
#\ =

#\=

#\ = = eq (=)

#\x==(+ 3 4) x

\\\\

#\f=(\x\y\z (x z) (y z)) f

#\f=(\x\y x) f
#\f=(\x x) f
#\f=() f

#\=(\x x)

#\()
#\=()
#\==()
#\f=

#\
#\ \

#\ =

#\ \(\x\y x)

#\x

#\ \=

#\
#\x

#\=3
#\ = = eq
#=


\f=

\\\\\

#\x x
#\"x" "x"
#\"x" x
\x "x"

#"hi"

#~ foo~
~
hello there
bye now
~
