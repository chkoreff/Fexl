#

# TODO detect (Q 0) and die instead */

\load_path=
	(\lib_name\type_name
	Q (dlsym (dlopen lib_name) type_name)
	)

\load=(load_path "")

\string_append==(load "type_string_append")
\.==string_append

\load_from=
	(\lib_name\type_name
	\lib_name=(. "lib/fexl/"; . "lib"; . lib_name ".so")
	\path=(. base_path lib_name)
	load_path path type_name
	)

\eval=(\x \x==x x)
\T=(\T\F T)
\F=(\T\F F)

\S==(load "type_S")
\C==(load "type_C")
\I==(load "type_I")
\@==(load "type_Y")

\Load=(load_from "qfile2")
\putchar==(Load "type_putchar")
\getchar==(Load "type_getchar")
\fputc==(Load "type_fputc")
\fgetc==(Load "type_fgetc")
\fwrite==(Load "type_fwrite")

\stdin==(eval; Load "type_stdin")
\stdout==(eval; Load "type_stdout")
\stderr==(eval; Load "type_stderr")

\fprint=(\fh\x fwrite fh x)  # TODO will allow x to be nested list

\NL="
"

\print_to=
	(\out
	\print=(fprint out)
	\nl=(print NL)
	\say=(\x print x nl)
	\: : print nl say
	)

print_to stdout \print\nl\say

\show==(load_from "show" "type_show")

## test functions

\test_built_in_pattern=
(
\test==(load_from "test" "type_test_pattern")
\test==test

show test
#show stdin
#show stdout
#show stderr
)

\test_forms=
(
say "== test forms"
\show!=
	(\x
	\x==x
	show x
	)

show (\x\y x)            # C
show (\x\y\z x z; y z)   # S
show (\x x)              # I
show (\"x" "x")          # I
show (\x "x")            # (C "x")
show (\x\y\z x; y z)     # R
show (\x\y\z x z y)      # L
show (\x\y y x)          # (L I)
show (\x\y\z ((x z) (y z)) ((x z) (y z)))  # ((S ((R S) ((R (R S)) S))) S)
show ()           # I
show (()(()))     # I
show ((())()"x")  # (I "x")

show! (I; C {x} I)
show! {string_len "abcd"}

show!
	(
	\x={x}
	\y={y}
	\z={z}
	S x y z
	)
)

\test_putchar=
(
say "== test putchar"
putchar 97
putchar 98
putchar 99
putchar 10
)

\test_fputc=
(
say "== test fputc"
\putchar=(fputc stdout)
putchar 97
putchar 98
putchar 99
putchar 100
putchar 10
)

\test_readlink=
(
say "== test readlink"
\readlink==(load_from "qfile2" "type_readlink")
\bin_path==(readlink "/proc/self/exe")
show bin_path
)

\test_inf=
	(
	\inf=(@ I) # infinite loop
	inf
	)

\test_getc=
(
\f=
(
putchar 63
\ch==(fgetc stdin)
#\ch==getchar
putchar 33 putchar ch putchar 10
)

f f
)

\test_say=
(
say "Hello world."

(
print_to stderr \print\nl\say
say "This goes to stderr."
)

)

\test_ping=
(
\ping==(load_from "test" "type_ping")
\ping=(ping ping)
\ping=(ping ping)
ping
)

\test_long=
(
say "== test long"
\Load=(load_from "long2")
\+==(Load "type_long_add")
\-==(Load "type_long_sub")
\*==(Load "type_long_mul")
\/==(Load "type_long_div")

\try=
	(\x
	\x==x
	show x
	)

try (+ 0 0)
try (+ 1 2)
try (- 1 2)
try (+ 42 37)
try (* 5 3)
try (* 5 0)
try (/ 29 4)
try (/ 0 0)
try (/ 1 0)
try (\x=(* 7 3) + x x)
)

\test_double=
(
say "== test double"
\Load=(load_from "double2")
\+==(Load "type_double_add")
\-==(Load "type_double_sub")
\/==(Load "type_double_div")
\*==(Load "type_double_mul")

\try=
	(\x
	\x==x
	show x
	)

try
	(
	\x=(+ 13.2 4.5)
	\x=(+ x x)
	\x=(/ x 0.5)
	x
	)

try (/ 0.0 0.0)  # -nan
try (/ 1.0 0.0)  # inf
try (/ -1.0 0.0) # -inf

try
	(
	\pi=3.14159265358979323846
	\tau=(* 2.0 pi)
	tau
	)

try (- 1e5 1.0)
)

\test_string_common=
(
say "== test string_common"
\string_common==(load_from "qstr2" "type_string_common")
\x="abcdef"
\y="abcDEF"
\x=(. x "")
\y=(. y "")
\n==(string_common x y)
show n
)

\test_string_len=
(
say "== test string_len"
\string_len==(load_from "qstr2" "type_string_len")
\try=
	(\x
	\len==(string_len x)
	show len
	)
try ""
try "a"
try ~ "~
try (. "a" "b")
try (. "abc" "de")
try ~
hello
~
)

\test_string_cmp=
(
say "== test string_cmp"
\string_cmp==(load_from "qstr2" "type_string_cmp")
\try=
	(\x\y
	\order==(string_cmp x y)
	show order
	)

# -1
try "" "a"
try "a" "b"
try "abc" "abcd"
# 0
try "" ""
try "a" "a"
try "abc" "abc"
# 1
try "a" ""
try "b" "a"
try "abcd" "abc"
)

\test_string_at=
(
say "== test string_at"
\string_at==(load_from "qstr2" "type_string_at")
\try=
	(\str\pos
	\ch==(string_at str pos)
	show ch
	)
try "" -1
try "" 0
try "" 1
try "a" -1
try "a" 0
try "a" 1
try "abc" 0
try "abc" 1
try "abc" 2
try (. "abc" "def") 3
)

\test_argv=
(
say "== test argv"
\argc==(eval; load_from "system" "type_argc")
\argv==(load_from "system" "type_argv")

\try=(\n
	\x==(argv n)
	show x
	)

show argc
try -1
try 0
try 1
try 2
)

\test_later=
(
say ~ == test "later"~
\later==(load "type_later")

# Test peeling off "later" layers with eager evaluation.
\f=(I C)
\f=(later f)
\f=(later f)
show f
\f==f  show f
\f==f  show f
\f==f  show f
)

\test_parse=
(
say "== test parse"
\parse==(load "type_parse")
\pop_symbol==(load "type_pop_symbol")
print "Parsing the tail of " print source_name nl
parse source_file "test" source_line \form\line
print "form " show form
print "line " show line

# TODO Need a way to examine the sym, getting label, is_name, and line.

\resolve=
	(@\resolve
	\form
	pop_symbol form form \sym\form
	print "sym  " show sym
	print "form " show form
	nl
	resolve form
	)

say "== Loop through symbols"
\form==(resolve form)

)

## main
test_built_in_pattern
test_forms
test_putchar
test_fputc
test_readlink
#test_inf
#test_getc
test_say
test_ping
test_long
test_double
test_string_common
test_string_len
test_string_cmp
test_string_at
test_argv
test_later
test_parse

# For testing purposes the tail program below starting with "\x=3" appears
# immediately after the virtual EOF "\\".  Normally there'd be a newline.
\\\x=3

\hello=(say "Hello world." say x)
hello
hello

\\

# LATER test some syntax errors after you do error propagation in parse.c.
# Missing lambda symbol:
#\= \\

# Missing definition:
#\x= \\
