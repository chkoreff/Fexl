#!bin/fexl

\.==string_append
\string_eq=(\x\y order (string_cmp x y) F T F)
\long_eq=(\x\y order (long_cmp x y) F T F)

\fprint==
	(
	examine 0 \type_long\_
	examine 0.0 \type_double\_
	examine "" \type_string\_
	examine var \type_var\_
	@\fprint\fh
	\done=(fwrite fh)
	\loop=(fprint fh)
	\x
	\x==x
	examine x \type\content
	\case=(long_eq type)
	content
		(
		case type_string (done x);
		case type_long (done; long_string x);
		case type_double (done; double_string x);
		case type_var (loop; get x);
		)
	\h\t
	loop h loop t
	)

\append=(@\append\x\y x y \h\t [h;append t y])
\NL="
"

# TODO generic [+ - * / eq lt gt ge ne] functions.

# Context constructors.  A context is a function which maps a name (string) to
# an optional value, either (yes val) if defined or no if not defined.

# ((define key val next) name) is (yes val) if name equals key, or (next name)
# otherwise.
\define = (\key\val\next \sym string_eq sym key (yes val) (next sym))

# (void name) is always no.
\void = (\name no)

# (chain f g) chains two contexts f and g together.
\chain = (\f\g \name f name (g name) yes)

\print_to=
	(\out
	\print=(fprint out)
	\nl=(print NL)
	\say=(\x print x nl)
	\: : print nl say
	)

print_to stdout \print\nl\say

# Enhance the context.
\define_name=
	(
	define "append" append;
	define "define" define;
	define "@" @;
	define "." .;
	define "NL" NL;
	define "fprint" fprint;
	define "say" say;
	define "print" print;
	define "nl" nl;
	define "long_eq" long_eq;
	define "print_to" print_to;
	define "source_file" source_file;
	define "source_name" source_name;
	define_name
	)

parse source_file source_name source_line \form\line

\define_name=
	(
	define "source_line" line;
	define_name
	)

\exp==(resolve form yes define_name source_name T)
\exp==exp

\\
## test functions

\show!=
	(\x
	\x==x
	show x
	)

\test_built_in_pattern=
(
\result==test_pattern
show result
)

\test_forms=
(
say "== test_forms"
show (\x\y x)            # C
show (\x\y\z x z; y z)   # S
show (\x x)              # I
show (\"x" "x")          # I
show (\x "x")            # (C "x")
show (\x\y\z x; y z)     # R
show (\x\y\z x z y)      # L
show (\x\y y x)          # (L I)
show (\x\y\z ((x z) (y z)) ((x z) (y z)))  # ((S ((R S) ((R (R S)) S))) S)
show ()           # I
show (()(()))     # I
show ((())()"x")  # (I "x")

show! (I; C {x} I)
show! {string_len "abcd"}

show!
	(
	\x={x}
	\y={y}
	\z={z}
	S x y z
	)
)

\test_putchar=
(
say "== test_putchar"
putchar 97
putchar 98
putchar 99
putchar 10
)

\test_fputc=
(
say "== test_fputc"
\putchar=(fputc stdout)
putchar 97
putchar 98
putchar 99
putchar 100
putchar 10
)

\test_readlink=
(
say "== test_readlink"
\bin_path==(readlink "/proc/self/exe")
say bin_path
say base_path
)

\test_inf=
	(
	\inf=(@ I) # infinite loop
	inf
	)

\test_getc=
(
say "== test_getc"
\f=
(
putchar 63
\ch==(fgetc stdin)
#\ch==getchar
putchar 33 putchar ch putchar 10
)

f f
)

\test_say=
(
say "== test_say"
say "Hello world."

(
print_to stderr \print\nl\say
say ["This goes to " "stderr."]
)

# Ensure that say eagerly evaluates its arguments.
\x=(long_add 1 4)
say ["x = " (fwrite stdout "!"; x)]

# Ensure that saying a weird form works well, and doesn't hang.
say "x"
say C
say Y
say S
say (S "x")
say ((S "x") (S "y"))
)

\test_ping=
(
say "== test_ping"
\ping=(ping ping)
\ping=(ping ping)
ping
)

\test_long=
(
say "== test_long"
\+ = long_add
\- = long_sub
\* = long_mul
\/ = long_div
\cmp = long_cmp

\try=say

try (+ 0 0)
try (+ 1 2)
try (- 1 2)
try (+ 42 37)
try (* 5 3)
try (* 5 0)
try (/ 29 4)
try (/ 0 0)
try (/ 1 0)
try (\x=(* 7 3) + x x)
nl

try (cmp 0 0)
try (cmp 1 1)
try (cmp -1 -1)

try (cmp 0 1)
try (cmp -1 0)
try (cmp 1 2)

try (cmp 1 0)
try (cmp 0 -1)
try (cmp 2 1)
nl

try 0
try 1
try -1
try 57
try -57

# Test highest and lowest 64-bit signed values.
try 9223372036854775807   #  2^63 - 1
try -9223372036854775808  # -2^63

# Try it with some arithmetic.
try (- 0; + 1 -9223372036854775808)  #   2^63 - 1
try (- -1 9223372036854775807)       #  -2^63

# Test over/underflow.
try 18446744073709551615    #  2^64 - 1
try -18446744073709551616   # -2^64

say "= order"
\try=
	(\x
	\y=(order x "LT" "EQ" "GT")
	say y
	)
try -2
try -1
try 0
try 1
try 2

say "= long_double"
\try=(\x say (long_double x))

try 4
try 0
try -1
try -37
try 126478

say "= long_char"
\try=(\x say (long_char x))

try 97
try 98
try 99
try 100
)

\test_double=
(
say "== test_double"

\+ = double_add
\- = double_sub
\* = double_mul
\/ = double_div
\cmp = double_cmp

\try=say

try
	(
	\x=(+ 13.2 4.5)
	\x=(+ x x)
	\x=(/ x 0.5)
	x
	)

try (/ 0.0 0.0)  # -nan
try (/ 1.0 0.0)  # inf
try (/ -1.0 0.0) # -inf

try
	(
	\pi=3.14159265358979323846
	\tau=(* 2.0 pi)
	tau
	)

try (- 1e5 1.0)
try -907.285
try 42.333
nl

try (cmp 0.0 0.0)
try (cmp 1.0 1.0)
try (cmp -1.0 -1.0)

try (cmp 0.0 1.0)
try (cmp -1.0 0.0)
try (cmp 1.0 2.0)

try (cmp 1.0 0.0)
try (cmp 0.0 -1.0)
try (cmp 2.0 1.0)

say "= double_long"
\try=(\x say (double_long x))

try 4.0
try 0.0
try -1.0
try -37.0
try 126478.0
try 4.3
try 0.3
try -1.3
try -37.3
try 126478.3
try 4.9
try 0.9
try -1.9
try -37.9
try 126478.9
try -126478.9
)

\test_string_common=
(
say "== test_string_common"
\x="abcdef"
\y="abcDEF"
\x=(. x "")
\y=(. y "")
say (string_common x y)
)

\test_string_len=
(
say "== test_string_len"
\try=(\x say (string_len x))
try ""
try "a"
try ~ "~
try (. "a" "b")
try (. "abc" "de")
try ~
hello
~
)

\test_string_cmp=
(
say "== test_string_cmp"
\try=(\x\y say (string_cmp x y))

# -1
try "" "a"
try "a" "b"
try "abc" "abcd"
# 0
try "" ""
try "a" "a"
try "abc" "abc"
# 1
try "a" ""
try "b" "a"
try "abcd" "abc"
)

\test_string_at=
(
say "== test_string_at"
\try=(\str\pos say (string_at str pos))

try "" -1
try "" 0
try "" 1
try "a" -1
try "a" 0
try "a" 1
try "abc" 0
try "abc" 1
try "abc" 2
try (. "abc" "def") 3
)

\test_string_long=
(
say "== test_string_long"
\try=
	(\x
	say (string_long x "no" \n ["yes " n])
	)

try "0"
try "1"
try "-1"
try "123"
try "-123"
try "x123"
try "1x23"
try ""
try "   456   "
try "456   "
try "1.6"
try "0."
)

\test_string_double=
(
say "== test_string_double"
\try=
	(\x
	say (string_double x "no" \n ["yes " n])
	)

try "0"
try "1"
try "-1"
try "123"
try "-123"
try "x123"
try "1x23"
try ""
try "   456   "
try "   456.78   "
try "456.78"
try "456   "
try "1.6"
try "0."
try "-0"
try "-0.0"
try "-0.0123"
try "3.14159265358979323846"
try "1e0"
try "1.2e5"
try "-2.84e-6"
)

\test_string_slice =
(
say "== test_string_slice"
\try=
	(\str\pos\len
	say (string_slice str pos len)
	)

# Normal cases
say "=="
try "" 0 0
say "=="
try "a" 0 0
try "a" 0 1
try "a" 1 0
say "=="
try "abc" 0 0
try "abc" 0 1
try "abc" 0 2
try "abc" 0 3
try "abc" 1 0
try "abc" 1 1
try "abc" 1 2
try "abc" 2 0
try "abc" 2 1

# Negative position (length offset by position and position set to zero)
say "=="
try "" -1 0
try "" -1 1
try "" -1 2
say "=="
try "a" -1 0
try "a" -1 1
try "a" -1 2
say "=="
try "abcd" -1 0
try "abcd" -1 1
try "abcd" -1 2
try "abcd" -1 3
try "abcd" -1 4
try "abcd" -1 5
try "abcd" -1 6
say "=="
try "abcd" -2 0
try "abcd" -2 1
try "abcd" -2 2
try "abcd" -2 3
try "abcd" -2 4
try "abcd" -2 5
try "abcd" -2 6
try "abcd" -2 7

# Negative length (same as length 0)
say "=="
try "abcd" 0 -1
try "abcd" 2 -1
try "abcd" 2 -3

# Various out of bounds
say "=="
try "" 0 1
try "a" 0 2
try "a" 1 1
try "abc" 0 4
try "abc" 2 2
try "abcde" 0 700
try "abcde" 0 6

# Run through some possibilities.
say "=="
try "abc" -1 0
try "abc" -1 1
try "abc" -1 2
try "abc" -1 3
try "abc" -1 4
try "abc" -1 5
say "=="
try "abc" 0 0
try "abc" 0 1
try "abc" 0 2
try "abc" 0 3
try "abc" 0 4
say "=="
try "abc" 1 0
try "abc" 1 1
try "abc" 1 2
try "abc" 1 3
say "=="
try "abc" 2 0
try "abc" 2 1
try "abc" 2 2

say "=="
try "a" 0 1
try "a" -1 2
try "a" -2 3
try "a" -2 4
try "a" -2 0

say "=="
try "abcde" 0 5
try "abcde" -1 5
try "abcde" -2 5
try "abcde" -3 5
try "abcde" -4 5
try "abcde" -5 5
try "abcde" -5 6
try "abcde" -5 7
try "abcde" -5 8
try "abcde" -5 9
try "abcde" -5 10
try "abcde" -5 900
say "=="
try "" 0 800
try "" -30 800
)

\test_argv=
(
say "== test_argv"

\try=(\n say (argv n))

say argc
try -1
try 0
try 1
try 2
)

\test_later=
(
say "== test_later"
# Test peeling off "later" layers with eager evaluation.
\f=(I T)
\f=(later f)
\f=(later f)
show f
\f==f  show f
\f==f  show f
\f==f  show f
)

\test_file=
(
say "== test_file"
\try=
	(\name
	print ["fopen " name " : "]
	\fh==(fopen name "r")
	print (fh "no" \fh "yes") nl
	)
show stdin
show stdout
show stderr
try "test/a1.fxl"
try "test/a1x.fxl"
)

\test_list=
(
say "== test_list"
\try=
	(\list
	\print_items=
		(
		@\loop\list
		list () \h\t
		print [h " "]
		loop t
		)
	print_items list nl
	)

try []
try ["a"]
try ["a" "b"]

\tail=["c" "d"]
try ["a" "b"; tail]

try ["a" "b"; append tail tail]

\list=["x" "y"]
\list=(append list list)
\list=(append list list)
try list

# Check the built-in pair function.
pair "x" "y" \x\y
say x
say y
)

\test_var=
(
say "== test_var"
\x==var
\show_val=(say ["x contains " x])

print "x is " show! x
set x (long_add 4 3)
print "x is " show! x
show_val
set x (long_mul 6 (get x))
show_val
)

\test_parse=
(
say "== test_parse"
say ["Parsing the tail of " source_name " on line " source_line]

parse source_file "test" source_line \form\line

# Now set up a context (environment) for resolving the parsed form.

# Strings always map to themselves.
\define_string=yes
# Define some more names.
\define_name=
	(
	define "say" say;
	define_name
	)

print "== form      = " show form
\exp==(resolve form define_string define_name source_name T)
say "== Now evaluate"
\exp==exp
print "== value     = " show exp
)

## main
test_built_in_pattern
test_forms
test_putchar
test_fputc
test_readlink
#test_inf
#test_getc
test_say
test_ping
test_long
test_double
test_string_common
test_string_len
test_string_cmp
test_string_at
test_string_long
test_string_double
test_string_slice
test_argv
test_later
test_file
test_list
test_var
test_parse

# For testing purposes the tail program below starting with "\x=3" appears
# immediately after the virtual EOF "\\".  Normally there'd be a newline.
\\\x=3
\talk=(say ["x = " x])
\talk=(talk talk)
talk

\\

# LATER test some syntax errors by forking a process.
# Missing lambda symbol:
#\= \\

# Missing definition:
#\x= \\

# Just an undefined var:
#x
