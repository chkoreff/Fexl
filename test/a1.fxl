# Miscellaneous tests

# Convert atom or list to a string.
\to_string ==
	(\x
	is_atom x
		(
		is_type "" x x;
		is_type 0 x (long_string x);
		is_type 0.0 x (double_string x);
		""
		);
	is_list x
		(
		x "" \h\t
		. (to_string h) (to_string t)
		);
	""
	)

\fprint ==
	(\fh\x
	is_atom x (fwrite fh (to_string x));
	is_list x
		(
		x () \h\t
		fprint fh h;
		fprint fh t;
		);
	)

\print = (fprint stdout)
\warn = (fprint stderr)

\NL="
"
\nl = (print NL)

\die =
	(\msg
	warn [msg NL];
	exit 1;
	)

#LATER \+ = ...
\+ = long_add
\* = long_mul

### Define test functions.

\announce = (\x print ["== " x NL])

\test_var_trace =
(
announce "test_var_trace"
var_new 0 \var
\get=(var_get var)
\put=(var_put var)

# Override with a tracing version:
\get =
	(\next
	get \x
	print ["trace x = " x NL];
	next x
	)

get \x
put (+ x 7)
get \x
put (* x 3)
get \x
print ["final x = " x NL]
)

\test_var_counter =
(
announce "test_var_counter"
\counter_new =
	(\next
	var_new 0 \current
	\get=(var_get current)
	\put=(var_put current)
	\count =
		(
		get \x
		\x = (+ x 1)
		print ["count " x NL]
		put x
		)
	next count
	)

counter_new \ping

ping ping ping
ping ping ping
ping ping ping
)

\test_circular_structure =
(
announce "test_circular_structure"
# Create a circular structure and thus introduce a memory leak.
var_new 0 \var
var_put var var
)

\test_var_ops =
(
announce "test_var_ops"

var_new 0 \var
\get=(var_get var)
\put=(var_put var)

# Override with a tracing version:
\get =
	(\next
	get \x
	print ["trace x = " x NL];
	next x
	)

put 14
get \x
put (+ x x)
get \x
put (* x x)
get \x
)

\test_var_repeat =
(
announce "test_var_repeat"
var_new 0 \var

# LATER a "do" function (over a list)
var_get var \x
print ["x = " x NL]
var_put var (+ x 3)

var_get var \x
print ["x = " x NL]
var_put var (+ x 3)

var_get var \x
print ["x = " x NL]
var_put var (+ x 3)
)

\test_print_repeat =
(
announce "test_print_repeat"

\talk=
(
\x=(* 6; + 3 4)
\y = ["Hello " "x = " x NL]
\y = [y y]

\z=["bananas"]
\z=[z z NL]
\z=["apples" "oranges"; z]

print [y (to_string y) z NL]
)

talk talk
)

\test_is_atom =
(
announce "test_is_atom"
\try =
	(\x
	print (is_atom x "yes" "no");nl;
	)

# yes
try "hello"
try (I "hello")
try (C "hello" S)
try (C 4 S)
try (C 4.5 S)
try ""
# no
try C
try (I C)
try ["apple" "banana"]
try []
try (\x\y y x)
)

\test_is_list =
(
announce "test_is_list"
\try =
	(\x
	print (is_list x "yes" "no");nl;
	)

# yes
try C
try (I C)
try []
try (item 3 [])
try [3 4]
# no
try "hello"
try (I "hello")
try (C "hello" S)
try (C 4 S)
try (item 4)
)

\test_is_type =
(
announce "test_is_type"
\try =
	(\x\y
	print (is_type x y "yes" "no");nl
	)

# yes
try C C
try (I S) (I S)
try (I 3) (I 5)
try (I 3.5) (I 4.5)
try [] C
try "" "abc"

# no
try C S
try (I C) (I S)
try (I 3) (I 4.5)
try 0 "abc"
)


\test_big =
(
# Test an exponential tower, showing how eager evaluation helps.
announce "test_big"
\f = (S C C)

\g =
	(\f
	? f \f  # This line cuts time down to ~0.000s from 8.800s.
	\f = (f f)
	\f = (f f)
	\f = (f f)
	\f = (f f)
	\f = (f f)
	f
	)

\f = (g f)
\f = (g f)
\f = (g f)
\f = (g f)
\f = (g f)

f
)

\test_fwrite =
(
announce "test_fwrite"
\f = (fwrite stdout "Hello ")
f f f
f f f
fwrite stdout NL
)

### Call test functions.

test_var_trace
test_var_counter
test_var_ops
test_var_repeat
test_print_repeat
test_is_atom
test_is_list
test_is_type
test_big
test_fwrite

# LATER fork a process to test these.
#test_circular_structure
#Y I
#Y Y
