#!/usr/bin/fexl
# Scratch-pad for developing new Fexl code.

##### Handy
# LATER A lot of these will be built into the standard context.

\and=(\x\y x y F)
\or=(\x\y x T y)
\not=(\x x F T)

# These functions represent a "possible" value, either (yes val) if you have a
# value or no if you don't.
\yes = (\val \yes\no yes val)
\no  = (     \yes\no no)

# (defined x) is true if x is (yes val).
\defined = (\x x (\_ T) F)

# (undefined x) is true if x is no.
\undefined = (\x not (defined x))

# (default v x) =
#    v   if x is no
#    val if x is (yes val)
\default = (\v\x x I v)

# LATER doc

\map == (\f\xs xs end \x\xs item (f x) (map f xs))

\fold == (\f\z\xs xs z \x\xs \z=(f z x) fold f z xs)

\do == (\xs\f\end xs end \x\xs f x; do xs f end)

\list_and = (fold and T)
\list_or = (fold or F)

\all = (\f\xs list_and (map f xs))
\some = (\f\xs list_or (map f xs))

\choose ==
	(\xs\ys
	xs end \x\xs
	ys end \y\ys
	x (item y) I (choose xs ys)
	)


# Halt the current expression by consuming all arguments which follow.
\halt == (\_ halt)

\string_eq=(\x\y string_compare x y F T F)

\long_lt=(\x\y long_compare x y T F F)
\long_eq=(\x\y long_compare x y F T F)
\long_gt=(\x\y long_compare x y F F T)

\double_lt=(\x\y double_compare x y T F F)
\double_eq=(\x\y double_compare x y F T F)
\double_gt=(\x\y double_compare x y F F T)

\ < = long_lt
\ = = long_eq
\ + = long_add
\ - = long_sub

\is_name = (\x type_eq (type_of x) (type_named "name"))

\to_string = (\x
	is_string x x;
	is_long x (long_string x);
	is_double x (double_string x);
	is_name x (name_string x);
	x)

\print = (\data string_put (to_string data))

# Quote a string.
#
# If the string does not contain quotes, then wrap quotes around it.
#
# If the string does contain quotes, then wrap tilde terminators around it,
# including a space after the first one.  In choosing the terminator, the
# function tries the values "~", "~1", "~2" etc. until it finds one that is not
# contained within the string.

# LATER I could rewrite this far more simply by generating the infinite list of
# all possible terminators and choosing the first one that doesn't appear in
# the string.  No need to convolve the production of terminator candidates with
# the testing and application like this.  The procedural style used here just
# muddies the waters.

\quote_string =
	(
	\try_quote_level==
		(\level\str

		# Choose the terminator string for this level.
		\term =
			(
			(= level 0) ~ "~;  # Try quote first.
			(= level 1) "~";   # Try tilde next.
			# Beyond that, try appending tilde to level minus one.
			string_append "~" (long_string (- level 1))
			)

		# See if the terminator appears inside the string.
		\pos=(string_index str term 0)

		< pos 0
			# It does not appear, so enclose string in pair of terminators.
			(
			# Start with the first terminator.
			string_append term;

			(= level 0
				# Using a quote, so don't use a space.
				()
				# Using a tilde, so use a space.
				(string_append " ")
			);

			# Then follow with the string itself and the terminator again.
			string_append str; term
			)

			# It does appear, so try again with the next level.
			(try_quote_level (+ level 1) str)
		)

	try_quote_level 0
	)

# Convert the value to a tree with the given leaf and branch functions.
\value_tree =
	(\value\leaf\branch

	is_apply value branch;

	\if_type=(type_eq (type_of value))

	\if_basic=(\val\type_name
		if_type (type_of val) (leaf type_name))

	\if_data=(\type_name\to_string
		if_type (type_named type_name) (leaf (to_string value)))

	if_data "long" long_string;
	if_data "double" double_string;
	if_data "string" quote_string;
	if_data "name" name_string;
	if_basic C "C";
	if_basic S "S";
	if_basic I "I";
	if_basic Y "Y";
	if_basic L "L";
	if_basic R "R";
	if_basic F "F";
	if_basic query "?";
	if_basic parse "parse";
	if_basic lambda "lam";
	if_basic resolve "resolve";
	if_basic long_add "long_add";
	if_basic double_add "double_add";
	if_basic string_append "string_append";
	if_basic is_long "is_long";
	if_basic long_double "long_double";
	if_basic end "end";
	if_basic item "item";
	if_basic pair "pair";
	if_basic append "append";

	leaf "_" # unknown
	)

# Print a value.
\value_put ==
	(\value\next
	value_tree value (\x string_put x next)
	\L\R
	string_put "(";
	value_put L;
	string_put " ";
	value_put R;
	string_put ")";
	next
	)

# Convert value to a string representation.
\value_string ==
	(\value
	value_tree value I
	\L\R
	string_append "(";
	string_append (value_string L);
	string_append " ";
	string_append (value_string R);
	string_append ")";
	""
	)

# Show a value (shorthand for value_put).
\show = value_put

# Show a value after evaluating it.
\show! = (\x \x=x show x)


##### Test routines

\test_math_1 =
(\next
print ":: test_math_1"; nl;

\basic_math =
(
\op = (\f\g
	\x\y
	is_long x
		(
		is_long y
			(f x y)
			(\x = (long_double x) g x y)
		)
		(
		is_long y
			(\y = (long_double y) g x y)
			(g x y)
		)
	)

\+ = (op long_add double_add)
\- = (op long_sub double_sub)
\* = (op long_mul double_mul)
\/ = (op long_div double_div)

\return return + - * /
)

basic_math \+ \- \* \/

\x=(/ (+ (* 3.1 (+ (- 4 9) (+ 2 1))) 20) 2)   # = 6.9
\x=(+ x 1)    # = 7.9
\x=(- x 2.1)  # = 5.8

# We show 15 digits because that's what Perl does.
print "/    1.0 7.0 = "; print (double_div 1.0 7.0); nl;
# 0.142857142857143
print "/ 1000.0 7.0 = "; print (double_div 1000.0 7.0); nl;
#  142.857142857143

# Test overflow conditions on long values.
(
\ > = long_gt

\test_overflow=
	(\x\y
	\z=(long_add x y)
	\ok=(and (> z x) (> z y))
	print "check "; print x; print " + "; print y; print " = "; print z;
	print " : "; print (ok "OK" "OVERFLOW");
	nl;
	)

test_overflow 9223372036854775806 1;
test_overflow 9223372036854775807 1;
test_overflow 9223372036854775000 807;
test_overflow 9223372036854775000 808;

test_overflow 1 9223372036854775806;
test_overflow 1 9223372036854775807;
test_overflow 807 9223372036854775000;
test_overflow 808 9223372036854775000;
)

show (x "hello world"); nl;
show! (x "hello world"); nl;

show x; nl;
show (+ x 3); nl;
show! (+ x 3); nl;

\C=(\x\y x)
show C; nl;
show (\x\y\z x z; y z); nl;
show (\x x); nl;
show (\x\y\z x; y z); nl;
show (\x\y\z x z y); nl;

next
)

\test_YI =
(\next
print ":: test_YI";nl;
get_max_steps \x show x;nl;
put_max_steps 10000000;
get_max_steps \x show x;nl;
Y I;
next
)

\test_YY =
(\next
print ":: test_YY";nl;
get_max_bytes \x show x;nl;
put_max_bytes 100000000;
get_max_bytes \x show x;nl;
Y Y
next
)

\test_math_2 =
(\next
print ":: test_math_2";nl;
\4.0=5.0
\3.1=10.6

\+=double_add
show (+ 4.0 3.1);nl;
show! (+ 4.0 3.1);nl;
next
)

\test_string_1 =
(\next
print ":: test_string_1";nl;

\"simple string" = "SIMPLE STRING"
\~ a "bc" d~ = ~ A "BC" D~
print "simple string"; nl;
print ~ a "bc" d~; nl;
print ~1 a "bc" d~1; nl;
print ~EOF a "complex" string~EO~EOF; nl;

print ~EOF hello world
more "stuff"
and more.~EOG~EOF; nl;
next
)

\test_string_2 =
(\next
# Verify that the abstraction routine properly distinguishes between a name x
# and a string "x".
print ":: test_string_2";nl;
\f = (\x \"x" x "x";)
f string_put "ABC"; nl;
next
)

\test_form_1 =
(\next
print ":: test_form_1";nl;
show end; nl;
show item; nl;
show append; nl;
next
)

\test_sym_1 =
(\next
print ":: test_sym_1";nl;

# Test some long symbols.
\f =
(
\123456789012345678901234567890
\abcdefghijklmnopqrstuvwxyzABCDEFGHIJ
\1234567890123456789012345678901234567890
\12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890

# len 30
123456789012345678901234567890
# len 36
abcdefghijklmnopqrstuvwxyzABCDEFGHIJ
# len 40
1234567890123456789012345678901234567890
# len 140
12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
)

# As it turns out, f is merely the identify function I.
show f;nl;
next
)

\test_utf =
(\next
print ":: test_utf"; nl;

\f = "hej 
åabcüdef
ghij
üä
1≠0
"

\åabcüdef = "hej åabcüdef"
\ghij = "hej ghij"
\üä = "hej üä"
\1≠0 = "hej 1≠0"

print "f = "; show f; nl;
print "ghij = "; show ghij; nl;
print "üä = "; show üä; nl;
print "1≠0 = "; show 1≠0; nl;
next
)

\test_parse =
(\next
print ":: test_parse"; nl;

\try =
(\text\next
print "parse ";print (quote_string text);nl;
\result = (parse text)

result \ok\result
result \exp\symbols
print "ok = "; show ok; nl;
print "exp = "; show exp; nl;
print "symbols = "; show symbols; nl;
nl;

next
)

try "string_put";

try "\ = =4 "; # ok

try "\x==4";
try "\x=4";

try "\x==4 x";
try "\x=4 x";

# This one looks funny, but it's just a function that takes a single parameter
# named "=", and always yields the number 3.  So it's the same as "\x 3".
try "\ = 3";

try ~
\x=#comment
4~ # works fine

try ~ string_put "hi";nl; \\ this is ignored~
try "\\ this stuff is ignored"
try "4"
try "long_add 4 5"
try ~ \print=string_put \x="hello" print x;nl;~;

try ~ string_put "Hello."; nl;~

# test multiple occurrences of a string
try ~
string_put "hello";
string_put "hello";
nl;
~;

# Demonstrate that NUL is a white space char.
try ~ string_put  "Hello."; nl;~;

# Here we use Ctrl-G (BEL) in a name.  We also use NULs as white space.
try ~ \printit =string_put      \x="hello" printit    x;nl;~;

try ~ \le  \ <= = le~;
try ~ \eq  \ == = eq~;
try ~ \ ==  \ = = ==~;
try ~ \ <= \ == \ =     <= == =~;

try ~ \+  \x=(+ 4 1.2)~;

try ~ \f  \y=(f "abc" "de") y~;

try ~ \x \'x' \y    x 'x' "x" 5 3.6 y~;

try "\x==x";
try "\x==x x";

try "\x\y x";    # C
try "\x\y y x";  # L I
try "\x\y\z x (y z)";  # R
try "\x\y\z x; y z";   # R
try "\x\y\z x z y";  # L

try ~
\a\b\c
\x=4
\x = (a x)
\x= (b x)
\x=(c x)
x
~;

try "";

try ~
\a\b\c\d\e\f
a b (c) (d; e b) (\x (\y f y) x) a
~;

try ~
\a\b (((a)) (((b))))
~;

try "#";

# These show that the null expression is just I (the identity function).
try "()";  # I
try "\x";  # (C I)
try "\ ="; # (C I)

# Comment right up against a name.
try "\abc abc#def";  # I
# Comment with space before it.
try "\abc abc #def"; # I

try "\x\y\a  x y a#b c";  # I

try "\x\y x x y";  # S I I
try "\x\y x y";  # I
try ";"; # I

try "(\x\y\z x (y z)) (\x x)";  # R I = I
try "\x\y x";  # C
try "\x\y  (\x\y x) x y";  # C
try "\x\y\z (x z) (y z)";  # S
try "(\x\y\z (x z) (y z)) (\x\y x) 4";  # S C 4 = I
try "\x\y y x x";
try "x";
try "\x x";

try ~
\num_eq
\x=1\y\ = = num_eq\z=4
= x z
~;

try ~
\num_eq

\ =# comment 
	= num_eq
~;


try ~
\ =====
\x
\ =
\y
\ <=
\zzz
\|
\>
\A\B
\ >=
\+
\a\b\c\d

   I
(===== ((
    (((x =) y) (<= zzz)(| 1 2)) 
	(
	> # comment
	A# # comment
	B # comment
	)
	
	) (>= x y)) (+ 2 2)
	(a b;; c d)
	(a b;; c d;)
	(A)#hey
)
~;

try "\x4 x4";  # I
try "\ <= <=";  # I
try "\<4 <4";  # I

# It can sometimes be tricky to use a function whose name starts with "=".
# You may need to use parentheses to avoid ambiguity.

# This defines the name "=4" as the value 4.  Probably not what you want.
try "\ =4 =4";

try "\ =4 (=4)"; # I

# This is easy.
try "\long_eq   \eq = long_eq
\x\y
eq x y
";

try "
\long_eq
\ = = long_eq
\x\y
(= x y)  # you must enclose in parens
";

try "
\long_eq
\ = = long_eq
\x\y
= x y    # oops, this is interpreted as \x \y=x x y
";


### Test syntax errors
(
try ~ "~;  # Unclosed string
try "~";   # Unclosed string terminator
try "\x\y  x y (#b c)"; # Unclosed parenthesis
try "\= 3 x"; # Missing lambda symbol
try "\="; # Missing lambda symbol
try "\("; # Missing lambda symbol
try "\)"; # Missing lambda symbol
try "\;"; # Missing lambda symbol
try "(";  # Unclosed parentheses
try ")";  # Extraneous input
try "\";  # Missing lambda symbol
try ~ ((~; # Unclosed parentheses

# Extraneous input (extra right parens on the end)
try ~ show 3; nl;
))
~;

try "\ = = ";  # Missing definition
try "\x=#foo4";  # Missing definition
try "\ \";  # Missing lambda symbol
try "\x=";  # Missing definition
try "\()"; # Missing lambda symbol

# Unclosed string terminator
try ~| ~EOM~|;

# Unclosed string
try ~| ~EOM
~|;

# Unclosed parentheses
try "I C (S";

# Unclosed parentheses
try ~
string_put
	(
	(string_append "Hello" " world."
	];
	nl;
~;

#))  # Resync parens so editor isn't confused.

try "I C )"; # Extraneous input
try ~ \"~;   # Unclosed string
try "\=4";   # Missing lambda symbol
try "\x==";  # Missing definition
try "\x=";   # Missing definition

# Missing definition
try ~
\foo=
\print=string_put
print "Hello world";nl;
~;

# Syntax error in definition (formerly had a memory leak).
try ~
\C = (\x\y x)
\C = ( (\x\y x)
~

# Syntax error in definition (formerly had a memory leak).
try ~
\C == (\x\y x)
\C == ( (\x\y x)
~

);

next
)


\test_long_div =
(\next

\try=
	(\x\y\next
	print "long_div ";print x;print " ";print y;
	\z=(long_div x y)
	print " = ";print z;nl;
	next
	)

\string_long = (\x string_long x I 0)

try (string_long "4") 4;
try 4 3;
try 4 2;
try 4 1;
try 4 0;
try 4 (string_long "error");
try (string_long "4x") (string_long "error");
next
)

# Test the built-in pair function.
\test_pair =
(\next
print ":: test_pair";nl;
pair "xxx" "yyy" \x\y
print "left side is ";print x;nl;
print "right side is ";print y;nl;
next
)

# Illustrate meta-parsing with the use of our own resolution function written
# in Fexl, wrapped around the built-in resolution function.
\test_resolve =
(\next
print ":: test_resolve";nl;

print "Try resolving some things that are not names or strings ...";nl;
resolve C I I;
resolve (C C) I I;
print "... we survived that.";nl;nl;

## Now try a full-fledged parse and resolve.

# Run a program text in the normal way, parsing it in the given context and
# reporting any errors, running the program only if there were no errors.
# LATER errors to stderr instead of stdout.
\run_program =
	(\prog\script\result\context\next
	result \syntax_ok\result result \exp\symbols

	\defs = (map (\entry entry \sym\line context sym) symbols)
	\symbols_ok = (all defined defs)
	\ok = (and syntax_ok symbols_ok)
	\undef_symbols = (choose (map undefined defs) symbols)

	# Now we flatten all the yes/no entries into pure values, using a dummy
	# value of 0 for all no entries.  If we have any no entries we won't run
	# the program anyway, so these dummy values are never encountered anyway.
	\defs = (map (default 0) defs)

	# Now we rip through the list of defs and force an evaluation on each one.
	# This isn't strictly necessary on a functional basis, but it's useful when
	# you use reflective features like type_of, for example in a function such
	# as "show".  By forcing evaluation, a symbol like "C" is evaluated all the
	# way to its ultimate value, instead of lazily remaining as an unevaluated
	# function application.

	do defs (\val \val=val)

	# Now create the program, which is the result of applying exp to each of
	# the definitions in turn.
	\program == (ok (fold I exp defs) exp)

	\print_error =
		(\line\next
		print prog;print ":";print script;print ":";print line;print " ";
		next
		)

	# Report any syntax error.
	syntax_ok ()
		(
		exp \error\line
		print_error line; print error;nl;
		);

	# Report any undefined symbols.
	do undef_symbols
		(\sym
		sym \sym\line
		print_error line; print " Undefined symbol ";
			print (is_name sym I quote_string sym);
			nl;
		);

	# Run the program if there were no errors.
	ok program I;
	next
	)

\try =
	(\text\next

	print "::: program:";nl;
	print (quote_string text);nl;
	print "::: result:";nl;

	# Here is a highly restricted context:
	\context =
		(\sym
		string_long sym yes;
		string_double sym yes;
		\if=(\name\def string_eq sym name (yes def))
		if "print" print;
		if "string_eq" string_eq;
		if "long_lt" long_lt;
		if "double_lt" double_lt;
		if "nl" nl;
		if "bye" (\next print "bye";nl; next);
		if "is_apply" is_apply;
		if "C" C;
		#if "this" (\next print "this";nl;next);
		#if "that" (\next print "that";nl;next);
		no
		)

	# Now wrap that in a context which treats strings literally.
	\context =
		(\sym
		is_name sym
			(context (name_string sym))
			(yes sym)
		)

	argv 0 \prog
	\script = ""
	run_program prog script (parse text) context;

	print "::: done";nl;nl;
	next
	)

### A couple of test cases
try ~
print "begin program";nl;
this;
that;
print "end program";nl;
~;

try ~
print "Hello world.";nl;
bye;
~

# Test a simple reflective feature to ensure that we've forced evaluation on
# all the resolved symbols.
try ~
print "verify that C is an atom  : ";
print (is_apply C (\_\_ "NO") "YES");
nl;
~

# LATER test under fork
#try "put_max_steps 10000000; Y I";
#try "put_max_bytes 1000000; Y Y";
#try "Y Y";

### Just for the heck of it let's try resolving a computed name.  I do it in
# such a way that it delays evaluation of the name until the actual resolve
# call, so I can test the sym->T == 0 case in fexl_resolve.

\try_name=
(\name\next

resolve name
	(\def
	print "The name ";print name;print " is "; print "defined as "; show def;
	)
	(
	print "The name ";print name;print " is "; print "undefined";
	)

print "."; nl;
next
)

try_name (string_name (string_append "long_" "add"));
try_name (string_name (string_append "long_" "addx"));
nl;

next
)

\test_type_eq =
(\next
print ":: test_type_eq";nl;

\try=
(\f\g\next
\tf=(type_of f)
\tg=(type_of g)

print "Types of ";show f;
print " and ";show g;
print " are "; print (type_eq tf tg "the same" "different");print ".";nl;
next
)

\try_before_after=
(\f\g\next
print "Before evaluation: "; try f g;
\f=f \g=g
print "After evaluation:  "; try f g;
next
)

try S C;
try S S;
try (S S) S;
try (S S) (C I);
try 4 2;
try 4 2.3;
try "" "a";

try_before_after (string_append "a" "b") "c";

try_before_after ("a" "b") "c";

# After evaluation, the form ("a" "b") is of type string, though it's not an
# atomic string value.  That results from calling "a" as a function, which has
# no meaningful definition, so the entire form becomes type string all the way
# up.  This actually gives you a way to diagnose type errors at run-time if you
# like.

next
)

\test_atomic =
(\next
print ":: test_atomic";nl;

\try=
(\f\next
print "Value ";show f;
print " is "; print (atomic f "" "not ");print "atomic.";nl;
next
)

try S;
try (S S);
try (C I);
try 4;
try 2.4;
try "";
try ("a" "b");
(\f = ("a" "b") try f);
next
)

\test_type_named =
(\next
print ":: test_type_named";nl;

\type_zero = (type_of (C C))

\try=
(\name\next
\type = (type_named name)
print "Type ";print name;print " is ";
print (type_eq type type_zero "not " "");print "defined.";nl;
next
)

try "long";
try "xlong";
try "double";
try "string";
try "name";
try "type";
try "string_append";
next
)

\test_show =
(\next
print ":: test_show";nl;nl;

\try_show=
	(\f\next
	string_put "value_put:    ";value_put f;nl;
	string_put "value_string: ";string_put (value_string f);nl;
	nl;
	next
	)

try_show C;
try_show S;
try_show (C S);
try_show ((S Y) ((C long_add) ((C (I "hi")) I)));
try_show (I 4.2);
try_show (3 4.2);
try_show 0;
try_show "hello";
try_show (I ~ print "hello world"~);
try_show (I ~| This has both " and ~ in it.~|);
(\f=("a" "b") try_show f);
try_show (long_add 1 5);
try_show (Y Y);
next
)

\test_string_index =
(\next
print ":: test_string_index";nl;

\try=
	(\x\y\n\expect \next
	\pos=(string_index x y n)
	\ok = (= pos expect)
	print "[";print (ok "GOOD" "BAD");print "] ";
	print "string_index ";
	print (quote_string x);
	print " ";
	print (quote_string y);
	print " ";
	print n;
	print " = ";print pos;
	(
	ok
		()
		(print "  [expect "; print expect;  print "]")
	);
	nl;
	next
	)

# NOTE:  All of these results agree with the results of Perl's built-in "index"
# function, and were confirmed with a Perl script.

print "Normal searches";nl;
try "abcdefg" "de" 0   3;
try "abcdefg" "de" 2   3;
try "abcdefg" "de" 3   3;
try "abcdefg" "de" 4   -1;

try "" "" 0   0;
try "" "a" 0   -1;
try "" "" -1   0;

try "abcdefghijklmnop" "" 0   0;
try "abcdefghijklmnop" "" 7   7;
try "abcdefghijklmnop" "" 15   15;

try "abcdefghijklmnop" "ghI" 0   -1;
try "abcdefghijklmnop" "ghi" 0   6;
try "abcdefghijklmnop" "mnop" 0   12;
try "abcdefghijklmnop" "mnopq" 0   -1;
try "abcdefghijklmnop" "p" 0   15;
try "abcdefghijklmnop" "q" 0   -1;
try "abcdefghijklmnop" "abcdefghijklmnop" 0   0;
try "abcdefghijklmnop" "abcdefghijklmnop" 1   -1;
try "abcdefghijklmnop" "abcdefghijklmnopq" 0   -1;
try "a" "ab" 0   -1;
try "a" "a" 0   0;

nl;
print "Search with embedded NUL after the 'n'";nl;
try "abcdefghijklmn op" "mn op" 0   12 ;nl;
print "Search with embedded NUL at the front.";nl;
try " op" " op" 0   0 ;nl;

print "Search with UTF-8 chars.";nl;
try "åabcüdef" "åabcüdef" 0   0;
try "åabcüdef" "åabcüdef" 1   -1;
try "åabcüdef" "cüdef" 0   4;
try "åabcüdef" "cüdef" 1   4;
try "åabcüdef" "cüde" 0   4;
try "åabcüdef" "üdef" 0   5;
try "åabcüdef" "ü" 0   5;
try "åabcüdef" "ü" 5   5;
try "åabcüdef" "ü" 6   -1;

#####
nl;
print "Testing some more corner cases.";nl;

try "" "" 0   0;
try "" "" 1   0;
try "" "" 2   0;

nl;

try "a" "" 0   0;
try "a" "" 1   1;
try "a" "" 2   1;

nl;

try "abcdefghijklmnop" "" 16   16;
try "abcdefghijklmnop" "" 17   16;
try "abcdefghijklmnop" "" 100   16;

nl;

try "abcdef" "f" 5  5;
try "abcdef" "f" 6  -1;
try "abcdef" "f" 100  -1;

nl;

try "abcdef" "" 0   0;
try "abcdef" "" -1   0;
try "abcdef" "" -47   0;

nl;

try "abcdef" "bc" -2   1;
try "abcdef" "bc" -1   1;
try "abcdef" "bc" 0   1;
try "abcdef" "bc" 1   1;
try "abcdef" "bc" 2   -1;
try "abcdef" "bc" 3   -1;
try "abcdef" "bc" 99   -1;

nl;

print ":: More cases";nl;

try "abacadaeaf" "ad" 0   4;
try "aaaXaaaX" "aX" 0   2;
try "aaappn" "aappn" 0  1;
try "bbbbbaaaaappnaaa" "aappna" 0  8;

next
)

\test_quote_string =
(\next
print ":: test_quote_string";nl;

\try=
	(\str\next
	print "string_quote [";print str;print "]";nl;
	\qstr = (quote_string str)
	print "result       [";print qstr;print "]";nl;
	nl;
	next
	)

try "";
try "xyz";
try ~ "~;
try "~";
try ~ As Gus Baird says, "Ain't nothin' simple when you're doin' it for real."~;
try ~| This string has both " and ~ characters in it.~|;

\str="hello" try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
\str=(quote_string str) try str;
next
)

\test_append =
(\next
print ":: test_append"; nl;

# Print a list of strings with space separators.
\print_list ==
	(\list\next
	list next
	\head\tail print head; print " "; print_list tail;
	next
	)

print "Empty = "; print_list end; nl;
print "Just x = "; print_list (item "x"; end); nl;
print "Append [] and [] = "; print_list (append end end); nl;
print "Append [1 2] and [3] = ";
print_list (append (item "1"; item "2"; end) (item "3"; end)); nl;

print "Now some longer lists:"; nl;
\list = (item "apples"; item "bananas"; item "oranges"; end)
print_list list nl;
\list = (append list list)
print_list list nl;
\list = (append list list)
print_list list nl;
\list = (append list list)
print_list list nl;
next
)

#### Run all the tests.

test_math_1;
test_math_2;
test_string_1;
test_string_2;
test_form_1;
test_sym_1;
test_utf;
test_parse;
test_long_div;
test_pair;
test_resolve;

test_type_eq;
test_atomic;
test_type_named;
test_show;
test_string_index;
test_quote_string;
test_append;
