#!bin/fexl

\T=(\T\F T)
\@=Y
\.==string_append
\no=C

\string_eq=(\x\y order (string_cmp x y) F T F)

\fprint=(\fh\x fwrite fh x)  # TODO will allow x to be nested list

\NL="
"

# Context constructors.  A context is a function which maps a name (string) to
# an optional value, either (yes val) if defined or no if not defined.

# ((define key val next) name) is (yes val) if name equals key, or (next name)
# otherwise.
\define = (\key\val\next \sym string_eq sym key (yes val) (next sym))

# (void name) is always no.
\void = (\name no)

\print_to=
	(\out
	\print=(fprint out)
	\nl=(print NL)
	\say=(\x print x nl)
	\: : print nl say
	)

print_to stdout \print\nl\say

## test functions

\test_built_in_pattern=
(
\result==test_pattern
show result
)

\test_forms=
(
say "== test_forms"
\show!=
	(\x
	\x==x
	show x
	)

show (\x\y x)            # C
show (\x\y\z x z; y z)   # S
show (\x x)              # I
show (\"x" "x")          # I
show (\x "x")            # (C "x")
show (\x\y\z x; y z)     # R
show (\x\y\z x z y)      # L
show (\x\y y x)          # (L I)
show (\x\y\z ((x z) (y z)) ((x z) (y z)))  # ((S ((R S) ((R (R S)) S))) S)
show ()           # I
show (()(()))     # I
show ((())()"x")  # (I "x")

show! (I; C {x} I)
show! {string_len "abcd"}

show!
	(
	\x={x}
	\y={y}
	\z={z}
	S x y z
	)
)

\test_putchar=
(
say "== test_putchar"
putchar 97
putchar 98
putchar 99
putchar 10
)

\test_fputc=
(
say "== test_fputc"
\putchar=(fputc stdout)
putchar 97
putchar 98
putchar 99
putchar 100
putchar 10
)

\test_readlink=
(
say "== test_readlink"
\bin_path==(readlink "/proc/self/exe")
say bin_path
say base_path
)

\test_inf=
	(
	\inf=(@ I) # infinite loop
	inf
	)

\test_getc=
(
say "== test_getc"
\f=
(
putchar 63
\ch==(fgetc stdin)
#\ch==getchar
putchar 33 putchar ch putchar 10
)

f f
)

\test_say=
(
say "== test_say"
say "Hello world."

(
print_to stderr \print\nl\say
say "This goes to stderr."
)

)

\test_ping=
(
say "== test_ping"
\ping=(ping ping)
\ping=(ping ping)
ping
)

\test_long=
(
say "== test_long"
\+ = long_add
\- = long_sub
\* = long_mul
\/ = long_div
\cmp = long_cmp

\try=(\x say (long_string x))

try (+ 0 0)
try (+ 1 2)
try (- 1 2)
try (+ 42 37)
try (* 5 3)
try (* 5 0)
try (/ 29 4)
try (/ 0 0)
try (/ 1 0)
try (\x=(* 7 3) + x x)
nl

try (cmp 0 0)
try (cmp 1 1)
try (cmp -1 -1)

try (cmp 0 1)
try (cmp -1 0)
try (cmp 1 2)

try (cmp 1 0)
try (cmp 0 -1)
try (cmp 2 1)
nl

try 0
try 1
try -1
try 57
try -57

# Test highest and lowest 64-bit signed values.
try 9223372036854775807   #  2^63 - 1
try -9223372036854775808  # -2^63

# Try it with some arithmetic.
try (- 0; + 1 -9223372036854775808)  #   2^63 - 1
try (- -1 9223372036854775807)       #  -2^63

# Test over/underflow.
try 18446744073709551615    #  2^64 - 1
try -18446744073709551616   # -2^64

say "= order"
\try=
	(\x
	\y=(order x "LT" "EQ" "GT")
	say y
	)
try -2
try -1
try 0
try 1
try 2
)

\test_double=
(
say "== test_double"

\+ = double_add
\- = double_sub
\* = double_mul
\/ = double_div
\cmp = double_cmp

\try=(\x say (double_string x))

try
	(
	\x=(+ 13.2 4.5)
	\x=(+ x x)
	\x=(/ x 0.5)
	x
	)

try (/ 0.0 0.0)  # -nan
try (/ 1.0 0.0)  # inf
try (/ -1.0 0.0) # -inf

try
	(
	\pi=3.14159265358979323846
	\tau=(* 2.0 pi)
	tau
	)

try (- 1e5 1.0)
try -907.285
try 42.333
nl

try (cmp 0.0 0.0)
try (cmp 1.0 1.0)
try (cmp -1.0 -1.0)

try (cmp 0.0 1.0)
try (cmp -1.0 0.0)
try (cmp 1.0 2.0)

try (cmp 1.0 0.0)
try (cmp 0.0 -1.0)
try (cmp 2.0 1.0)
)

\test_string_common=
(
say "== test_string_common"
\x="abcdef"
\y="abcDEF"
\x=(. x "")
\y=(. y "")
\n==(string_common x y)
say (long_string n)
)

\test_string_len=
(
say "== test_string_len"
\try=(\x say (long_string; string_len x))
try ""
try "a"
try ~ "~
try (. "a" "b")
try (. "abc" "de")
try ~
hello
~
)

\test_string_cmp=
(
say "== test_string_cmp"
\try=(\x\y say (long_string; string_cmp x y))

# -1
try "" "a"
try "a" "b"
try "abc" "abcd"
# 0
try "" ""
try "a" "a"
try "abc" "abc"
# 1
try "a" ""
try "b" "a"
try "abcd" "abc"
)

\test_string_at=
(
say "== test_string_at"
\try=(\str\pos say (long_string; string_at str pos))

try "" -1
try "" 0
try "" 1
try "a" -1
try "a" 0
try "a" 1
try "abc" 0
try "abc" 1
try "abc" 2
try (. "abc" "def") 3
)

\test_argv=
(
say "== test_argv"

\try=(\n say (argv n))

say (long_string argc)
try -1
try 0
try 1
try 2
)

\test_later=
(
say "== test_later"
# Test peeling off "later" layers with eager evaluation.
\f=(I C)
\f=(later f)
\f=(later f)
show f
\f==f  show f
\f==f  show f
\f==f  show f
)

\test_file=
(
say "== test_file"
\try=
	(\name
	print "fopen " print name print " : "
	\fh==(fopen name "r")
	print (fh "no" \fh "yes") nl
	)
show stdin
show stdout
show stderr
try "test/a1.fxl"
try "test/a1x.fxl"
)

\test_list=
(
say "== test_list"
\try=
	(\list
	\print_items=
		(
		@\loop\list
		list () \h\t
		print h
		print " "
		loop t
		)
	print_items list nl
	)

\append=(@\append\x\y x y \h\t [h;append t y])

try []
try ["a"]
try ["a" "b"]

\tail=["c" "d"]
try ["a" "b"; tail]

try ["a" "b"; append tail tail]

\list=["x" "y"]
\list=(append list list)
\list=(append list list)
try list
)

\test_parse=
(
say "== test_parse"
print "Parsing the tail of " print source_name
print " on line " print (long_string source_line) nl

parse source_file "test" source_line \form\line

# Now set up a context (environment) for resolving the parsed form.

# Strings always map to themselves.
\define_string=yes
# Define some more names.
\define_name=
	(
	define "say" say;
	define_name
	)
# Make a simple "resolve" function with everything baked in.
\resolve=(resolve define_string define_name)

print "== form      = " show form
\exp==(resolve form)
print "== resolved  = " show exp
say "== Now evaluate"
\exp==exp
print "== value     = " show exp
)

## main
test_built_in_pattern
test_forms
test_putchar
test_fputc
test_readlink
#test_inf
#test_getc
test_say
test_ping
test_long
test_double
test_string_common
test_string_len
test_string_cmp
test_string_at
test_argv
test_later
test_file
test_list
test_parse

# For testing purposes the tail program below starting with "\x=3" appears
# immediately after the virtual EOF "\\".  Normally there'd be a newline.
\\\x=3

\hello=(say "Hello world." say (long_string x))
hello
hello

\\

# LATER test some syntax errors by forking a process.
# Missing lambda symbol:
#\= \\

# Missing definition:
#\x= \\

# Just an undefined var:
#x
