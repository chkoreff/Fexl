#!/bin/sh

usage()
	{
	progname=$0

	cat 1>&2 <<EOM
NAME
       $progname - do a build or install

SYNOPSIS
       $progname [quiet] [clean] [install] [uninstall] [in <dir>]

DESCRIPTION
       $progname build
              Build locally, in the current directory.

       $progname install
              Install in the default system directory "$sysdir".

       $progname install in <dir>
              Install in directory <dir> instead of "$sysdir".

       $progname uninstall
              Uninstall from the default system directory "$sysdir".

       $progname uninstall in <dir>
              Uninstall from directory <dir> instead of "$sysdir".

       $progname clean
              Erase all the local output files before doing anything else.

       $progname quiet build
              Build quietly, without showing the commands that it runs.

You may also combine the options in various ways such as this:

       $progname quiet build
       $progname quiet install
       $progname quiet clean install
       $progname quiet install in ~/myplace

EOM
	exit 2
	}

# Return true if file_1 is newer than file_2.
newer_than()
	{
	local file_1=$1
	local file_2=$2

	local result=0
	if [ -e $file_2 ]; then
		if [ $file_1 -nt $file_2 ]; then result=1; fi
	else
		result=1
	fi
	echo $result
	}

# Remove a directory without displaying an error message if it doesn't exist.
quiet_rmdir()
	{
	if [ -d $1 ]; then
		rmdir --ignore-fail-on-non-empty $1
	fi
	}

# Run a system command.
run()
	{
	local command="$1"
	if [ $quiet -eq 0 ]; then echo "$command"; fi
	$command
	local code=$?
	if [ $code -ne 0 ]; then exit $code; fi
	}

# Make an object file.
#
# I compile with -O3 because that enables -finline-functions.  You can see that
# by running "gcc -c -Q -O3 --help=optimizers".
#
# NOTE: I no longer use the -ansi flag because that makes the fdopen function
# inaccessible in stdio.h for some strange reason.
make_obj()
	{
	local file_o="$1"
	local file_c="$2"
	shift
	for source in $@
	do
		out_of_date=`newer_than $source $file_o`
		if [ $out_of_date -eq 1 ]
		then
			local command="gcc -c -Wall -Werror -O3 $file_c -o $file_o"
			run "$command"
			break;
		fi
	done
	}

# Make an executable program.
# The -s removes all symbol table and relocation information.
make_exe()
	{
	local target="$1"
	shift
	local out_of_date=0
	for file_o in $@
	do
		out_of_date=`newer_than $file_o $target`
		if [ $out_of_date -ne 0 ]; then break; fi
	done

	if [ $out_of_date -ne 0 ]
	then
		local command="gcc -s"
		for file_o in $@
		do
			command="$command $file_o"
		done
		command="$command -o $target"
		run "$command"
	fi
	}

set_system_name()
	{
	local main_c=`grep -l "^int main(" src/*.c | head -1`
	if [ "$main_c" = "" ]; then
		echo "I don't see a main program here."
		exit 2
	fi
	system_name=`basename $main_c .c`
	}

# Build the system.  This runs the obj/build script, creating it if necessary
# by analyzing the source files and header dependencies.
build()
	{
	mkdir -p obj
	mkdir -p bin

	if [ ! -e obj/build ]
	then
		set_system_name

		local objects=""
		for file_c in src/*.c
		do
			base=`basename $file_c .c`
			file_o=obj/$base.o

			objects="$objects$file_o "

			local headers
			headers=`
			grep -e "^#include \".*\"" $file_c |
			sed "s/^#include \"\(.*\)\"/\1/" |
			(
			while read file_h; do
				echo -n "src/$file_h "
			done;
			)`

			echo "make_obj $file_o $file_c $headers" >>obj/build
		done

		echo "make_exe bin/$system_name $objects" >>obj/build
		echo "system_name=$system_name" >>obj/build
		chmod +x obj/build
	fi

	local script
	script=`cat obj/build`
	eval "$script"
	}

# Set up flags based on command line options.
handle_options()
	{
	quiet=0
	clean=0
	build=0
	install=0
	uninstall=0
	valid=1
	sysdir=/usr

	while [ $# -gt 0 ]; do
		local verb="$1"
		shift
		case $verb in
			build) build=1 ;;
			quiet) quiet=1 ;;
			clean) clean=1 ;;
			install) install=1 ;;
			uninstall) uninstall=1 ;;
			in)
				if [ $# -gt 0 ]; then
					sysdir="$1"
					shift
				else
					valid=0
				fi
				;;
			*) valid=0 ;;
		esac
	done
	}

handle_options "$@"
if [ $valid -eq 0 ]; then usage; fi

if [ $uninstall -eq 1 ]; then
	set_system_name
	rm -f $sysdir/bin/$system_name
	rm -rf $sysdir/share/$system_name
	quiet_rmdir $sysdir/bin
	quiet_rmdir $sysdir/share
	quiet_rmdir $sysdir
	exit
fi

valid=0
if [ $clean -eq 1 ]; then
	valid=1
	rm -rf obj
	rm -rf bin
fi

if [ $build -eq 1 -o $install -eq 1 ]; then
	valid=1
	build

	if [ $install -eq 1 ]; then
		mkdir -p $sysdir
		mkdir -p $sysdir/bin
		mkdir -p $sysdir/share

		run "cp -p bin/$system_name $sysdir/bin/"
		run "rm -rf $sysdir/share/$system_name"
		run "cp -pr share/$system_name $sysdir/share/"
		chown -R $USER:$USER $sysdir/bin/$system_name
		chown -R $USER:$USER $sysdir/share/$system_name
	fi

	# Now, in case you're running under sudo, change the permissions on the
	# locally created directories back to the underlying user. Otherwise you'd
	# have files owned by root in your local directory, which is annoying.

	if [ "$SUDO_USER" != "" ]; then
		chown -f -R $SUDO_USER:$SUDO_USER bin
		chown -f -R $SUDO_USER:$SUDO_USER obj
	fi
fi

if [ $valid -eq 0 ]; then usage; fi
