#!/bin/sh

# Build and install the Fexl program as required.  Run "./build help" to see
# the usage options.

usage()
	{
	progname=$0

	cat <<EOM
NAME
       $progname - build the Fexl program

SYNOPSIS
       $progname [quite] [clean] [erase]

DESCRIPTION

       $progname
              Do a local build, only compiling what actually changed.

       $progname clean
              Compile everything from scratch.

       $progname quiet
              Build quietly, without showing the commands that it runs.

       $progname erase
              Erase all the local output files and don't build anything.
EOM
	exit 2
	}

# Return true if file_1 is newer than file_2.
newer_than()
	{
	local file_1="$1"
	local file_2="$2"

	local result=0
	if [ -e $file_2 ]; then
		if [ $file_1 -nt $file_2 ]; then result=1; fi
	else
		result=1
	fi
	echo $result
	}

# Compile a module if it's out of date.
module()
	{
	module=$1

	# Always include the module's own header file if it exists.
	if [ -e src/$module.h ]; then
		set $@ $module
	fi

	shift

	object="obj/$module.o"
	source="src/$module.c"

	objects="$objects $object"

	headers=""
	update=`newer_than $source $object`

	while [ $# -gt 0 ]; do
		name=$1
		shift
		if [ "$name" = "-" ]; then
			# A "-" means the next arg is a system header, e.g. "- stdio".
			name=$1
			shift
			header=$name.h
		else
			# This is a local header.
			header=src/$name.h
			if [ $update -eq 0 ]; then
				update=`newer_than $header $object`
			fi
		fi
		headers="$headers $header"
	done

	if [ $update -eq 1 ]; then
		includes=""
		for header in $headers
		do
			includes="$includes -include $header"
		done

		local command="gcc $cflags $includes $source -o $object"
		if [ $quiet -eq 0 ]; then echo "build module $module"; fi

		$command
		local code=$?
		if [ $code -ne 0 ]; then exit $code; fi

		relink=1
	fi
	}

# Remove a module that we don't use but keep around just in case.
no_module()
	{
	module=$1
	object="obj/$module.o"
	if [ -e $object ]; then
		rm $object
		relink=1
	fi
	}

# Link a program if it's out of date.
program()
	{
	name=$1
	program=bin/$name

	if [ $relink -eq 0 ]; then
		if [ ! -e $program ]; then
			relink=1
		fi
	fi

	if [ $relink -eq 1 ]; then
		if [ $quiet -eq 0 ]; then echo "build program $name"; fi

		local flags=""

		# We use -rdynamic (aka --export-dynamic) so that dynamically loaded
		# libraries will link to the functions defined in the program.
		flags="$flags -rdynamic"

		# The -s removes all symbol table and relocation information.
		flags="$flags -s"

		local libs=""

		# We use -ldl (libdl) so the program can call dlopen and dlsym.
		# LATER jturner says he had to remove -ldl when building on OpenBSD.
		# I suppose I should compare uname with "OpenBSD".
		libs="$libs -ldl"

		local command="gcc $flags $objects $libs -o $program"
		$command
	fi
	}

# Link a library if it's out of date.
library()
	{
	name=$1

	library=lib/fexl/$name.so

	if [ $relink -eq 0 ]; then
		if [ ! -e $library ]; then
			relink=1
		fi
	fi

	if [ $relink -eq 1 ]; then
		if [ $quiet -eq 0 ]; then echo "build library $name"; fi
		gcc -s -shared -o $library $objects
	fi
	}

# Set up flags based on command line options.
handle_options()
	{
	quiet=0
	clean=0
	erase=0
	valid=1

	while [ $# -gt 0 ]; do
		verb=$1
		shift
		case $verb in
			quiet) quiet=1 ;;
			clean) clean=1 ;;
			erase) erase=1 ;;
			*) valid=0 ;;
		esac
	done

	if [ $valid -eq 0 ]; then usage; fi
	}

# Begin a section for building something.
begin_section()
	{
	objects=""
	relink=0
	}

# Begin a section for building a program.
begin_program()
	{
	cflags=$common_cflags
	begin_section
	}

# Begin a section for building a library.
begin_library()
	{
	# Add -fPIC (Position Independent Code) so we can link into shared library.
	cflags="$common_cflags -fPIC"
	begin_section
	}

# Now let's build.

handle_options $@

if [ $clean -eq 1 -o $erase -eq 1 ]; then
	rm -rf obj
	rm -rf bin
	rm -rf lib
	if [ $erase -eq 1 ]; then exit; fi
fi

mkdir -p obj
mkdir -p bin
mkdir -p lib/fexl

# I compile with -O3 because that enables -finline-functions.  You can see that
# by running "gcc -c -Q -O3 --help=optimizers".
#
# NOTE: I no longer use the -ansi flag because that makes the fdopen function
# inaccessible in stdio.h for some strange reason.
common_cflags="-c -Wall -Werror -O3"

## Build the main Fexl program.

begin_program
module basic - string value
module die - stdarg - stdio - stdlib
module double - stdio - stdlib - string value basic string
module fexl value basic parse resolve
module file - stdio - string - unistd memory value basic long string
module lib - dlfcn - stdio die value file string
module long - stdio - stdlib - string value basic string
module memory - stdlib die
module parse - ctype - stdio - string die value basic file long resolve string
module resolve - stdio - string value basic double file long parse string \
	system var
module string - string memory value basic
module system - stdlib - string - sys/resource value basic long
module value memory die
module var - string value basic

program fexl

## Build the dynamic libraries.

#begin_library
#module lib1 ...
#library lib1
