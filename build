#!/bin/sh

# Build and install the Fexl program as required.  Run "./build help" to see
# the usage options.

# LATER http://stackoverflow.com/questions/394230/detect-the-os-from-a-bash-script
# Don't use backticks, use the newer clearer syntax: "unamestr = $(uname)".

usage()
	{
	progname=$0

	local dir=$default_place

	cat <<EOM
NAME
       $progname - build the Fexl program

SYNOPSIS
       $progname [install] [ uninstall] [in <dir>] [erase] [quiet] [clean]

DESCRIPTION

       $progname install
              Build Fexl and install in $dir, or add "in <dir>" to install
              somewhere else.

       $progname uninstall
              Uninstall Fexl from $dir, or add "in <dir>" to uninstall
              somewhere else.

       $progname
              Do a local build, only compiling what actually changed.

       $progname clean
              Compile everything from scratch.

       $progname quiet
              Build quietly, without showing the commands that it runs.

       $progname erase
              Erase all the local output files and don't build anything.

You may also combine the options in various ways such as this:

       $progname quiet clean install
       $progname quiet install in ~/myfexl

EOM
	exit 2
	}

# Remove a directory without displaying an error message if it doesn't exist.
quiet_rmdir()
	{
	if [ -d $1 ]; then
		rmdir --ignore-fail-on-non-empty $1
	fi
	}

handle_options()
	{
	default_place="/usr"
	current_place=$default_place

	# Check the command line.

	valid=1
	quiet=0
	clean=0
	erase=0
	install=0
	uninstall=0

	while [ $# -gt 0 ]; do
		verb=$1
		shift
		case $verb in
			quiet) quiet=1 ;;
			clean) clean=1 ;;
			erase) erase=1 ;;
			install) install=1 ;;
			uninstall) uninstall=1 ;;
			in)
				if [ $# -gt 0 ]; then
					current_place=$1
					shift
				else
					valid=0
				fi
				;;
			*) valid=0 ;;
		esac
	done

	if [ $valid -eq 0 ]; then usage; fi

	if [ $uninstall -eq 1 ]; then
		rm -f $current_place/bin/fexl
		rm -rf $current_place/lib/fexl
		rm -rf $current_place/share/fexl

		# Now safely remove any directories that are empty.
		quiet_rmdir $current_place/bin
		quiet_rmdir $current_place/lib
		quiet_rmdir $current_place/share
		quiet_rmdir $current_place
		exit
	fi

	if [ $clean -eq 1 -o $erase -eq 1 ]; then
		rm -rf bin
		rm -rf lib
		rm -rf obj
		if [ $erase -eq 1 ]; then exit; fi
	fi
	}

# Return true if file_1 is newer than file_2.
newer_than()
	{
	local file_1="$1"
	local file_2="$2"

	local result=0
	if [ -e $file_2 ]; then
		if [ $file_1 -nt $file_2 ]; then result=1; fi
	else
		result=1
	fi
	echo $result
	}

# Run a system command and echo if not quiet.  Halt on any error.
run()
	{
	local command="$1"
	if [ $quiet -eq 0 ]; then echo $command; fi
	$command
	local code=$?
	if [ $code -ne 0 ]; then exit $code; fi
	}

handle_options $@

mkdir -p obj
mkdir -p bin

# Build any object files which are missing or out of date with respect to their
# C source files or any included header files.
#
# I compile with -O3 because that enables -finline-functions.  You can see that
# by running "gcc -c -Q -O3 --help=optimizers".
#
# I compile with -fPIC to generate Position Independent Code for shared
# libraries.
#
# NOTE: I no longer use the -ansi flag because that makes the fdopen function
# inaccessible in stdio.h for some strange reason.

cflags="-c -Wall -Werror -O3 -fPIC"

for file_c in src/*.c
do
	name=`basename $file_c .c`
	file_o=obj/$name.o

	update=`newer_than $file_c $file_o`
	if [ $update -eq 0 ]; then
		grep -e "^#include \".*\"$" $file_c |
		sed "s/^#include \"\(.*\)\"/\1/" |
		(
		while read file; do
			file_h=src/$file
			update=`newer_than $file_h $file_o`
			if [ $update -eq 1 ]; then exit 1; fi
		done
		)
		update=$?
	fi

	if [ $update -eq 1 ]; then
		run "gcc $cflags $file_c -o $file_o"
	fi
done

# Determine the base directory for this build.
pwd=`pwd`

if [ $install -eq 1 ]; then
	base=$current_place
	mkdir -p $base/bin
	mkdir -p $base/share
else
	base=$pwd
fi

# Determine where the library should go.
dir_lib=$base/lib/fexl

# Collect objects that are not main programs.  These go into the library.
objects=
update=0
for file_c in `grep -L "^int main(" src/*.c`
do
	name=`basename $file_c .c`
	file_o=obj/$name.o
	objects="$objects $file_o"
	if [ $update -eq 0 ]; then
		update=`newer_than $file_o $dir_lib/libfexl.so`
	fi
done

# Now create a couple of small C files which specify the base path name both
# for the local and installed versions.  We create the C files in the obj
# directory to avoid modifying the src directory in any way.

# We always create a fresh base_install.c because we don't want to use an old
# one if you're installing in a different place now.

rm -f obj/base_install.c

for version in local install
do
	base_dir=
	if [ "$version" = "install" ]; then
		base_dir=$current_place
	else
		base_dir=$pwd
	fi

	file_c=obj/base_$version.c
	file_o=obj/base_$version.o

	if [ ! -e $file_c ]; then
		echo "char *base = \"$base_dir\";" >$file_c
		run "gcc $cflags $file_c -o $file_o"
	fi
done

# Now we choose the version of base to link into the library depending on
# whether we're doing a final install or just building locally.
if [ $install -eq 1 ]; then
	base_o=obj/base_install.o
else
	base_o=obj/base_local.o
fi

objects="$objects $base_o"
if [ $update -eq 0 ]; then
	update=`newer_than $base_o $dir_lib/libfexl.so`
fi

# Build the shared library.  We use -ldl (libdl) for dlopen and dlsym.
# LATER jturner says he had to remove -ldl when building on OpenBSD.
# I should auto-detect that.
if [ $update -eq 1 ]; then
	mkdir -p $dir_lib
	run "gcc -shared -o $dir_lib/libfexl.so $objects -ldl"
fi

if [ $install -eq 1 ]; then
	# Copy the "share/fexl" directory to "$current_place/share/fexl".
	rm -rf $current_place/share/fexl
	cp -pr share/fexl $current_place/share/fexl
	chown -R $USER:$USER $current_place/share/fexl
fi

# Build the executables for any main programs.
#
# We link with an absolute library path.  That lets you run the executable
# without having to be in the directory where you did the build.  It also does
# not rely on the system search paths in /etc/ld.so.conf, which means the
# program won't break if you change those search paths.  It also allows you to
# install multiple versions of Fexl in different places if you like.

for file_c in `grep -l "^int main(" src/*.c`
do
	name=`basename $file_c .c`
	file_o=obj/$name.o

	dir_bin=bin

	if [ $install -eq 1 ]; then
		if [ "$name" = "fexl" ]; then
			dir_bin=$current_place/bin
		fi
	fi

	file_x=$dir_bin/$name

	update=`newer_than $file_o $file_x`
	if [ $update -eq 0 ]; then
		update=`newer_than $dir_lib/libfexl.so $file_x`
	fi

	if [ $update -eq 1 ]; then
		run "gcc $file_o -o $file_x $dir_lib/libfexl.so"
	fi
done

# Now, in case you're running under sudo, change the permissions on the locally
# created directories back to the underlying user.  Otherwise you'd have files
# owned by root in your local directory, which is annoying.

if [ "$SUDO_USER" != "" ]; then
	chown -R $SUDO_USER:$SUDO_USER bin
	chown -R $SUDO_USER:$SUDO_USER lib
	chown -R $SUDO_USER:$SUDO_USER obj
fi
