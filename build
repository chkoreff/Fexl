#!/bin/sh

# (Patrick Chkoreff)
#
# This script builds or installs the Fexl project.  It checks time stamps and
# builds only what is out of date.  It automatically finds header dependencies,
# which it caches in obj/*.dep files.
#
# The installer honours the standard structure (e.g. the way perl does it):
#
#   /usr/bin/fexl
#   /usr/lib/fexl
#   /usr/share/fexl
#
# Run "./build help" to see the full usage message.

usage()
	{
	local prog=$0

	cat 1>&2 <<EOM
NAME
       $prog - Build or install the $g_project system as required.

SYNOPSIS
       $prog [quiet] [clean] [install] [uninstall] [in <dir>]

DESCRIPTION
       $prog
              Build in the current directory.

       $prog install
       $prog uninstall
              Install or uninstall in the default system directory "$g_sysdir".

       $prog install in <dir>
       $prog uninstall in <dir>
              Install or uninstall in the specified directory <dir>.

       $prog quiet
              Build quietly, without showing the commands that it runs.

       $prog clean
              Build after erasing all local output files.

       $prog erase
              Erase all local output files and do nothing else.

You may also combine options in various ways such as:

       $prog quiet install
       $prog quiet clean install
       $prog quiet install in ~/my$g_project

EOM
	exit 2
	}

# Return true if file_1 is newer than file_2.
newer_than()
	{
	local file_1=$1
	local file_2=$2

	local result=0
	if [ -e $file_2 ]; then
		if [ $file_1 -nt $file_2 ]; then result=1; fi
	else
		result=1
	fi
	echo $result
	}

# Remove a directory without displaying an error message if it doesn't exist.
quiet_rmdir()
	{
	if [ -d $1 ]; then
		rmdir --ignore-fail-on-non-empty $1
	fi
	}

# Run a system command.
run()
	{
	local command="$1"
	if [ $g_quiet -eq 0 ]; then echo "$command"; fi
	$command
	local code=$?
	if [ $code -ne 0 ]; then exit $code; fi
	}

# Get the list of header files that a C source file includes.
get_headers()
	{
	local name=$1
	local file_c=src/$name.c

	grep -e "^#include \".*\"" $file_c |
	sed 's/^#include "\(.*\)".*$/\1/' |
	(
	while read file_h; do
		echo -n "src/$file_h "
	done;
	)
	}

# Make an object file from a C source file.
#
# We compile with -O3 because that enables -finline-functions.  You can see
# that by running "gcc -c -Q -O3 --help=optimizers".
#
# NOTE: We no longer use the -ansi option because that makes the fdopen
# function inaccessible in stdio.h, and makes readlink inaccessible in
# unistd.h.
make_obj()
	{
	local name=$1
	local options="$2"

	local file_c=src/$name.c
	local file_o=obj/$name.o

	# Make sure header cache file obj/$name.dep is up to date.
	if [ -e $file_c ]; then
		local file_dep=obj/$name.dep
		if [ `newer_than $file_c $file_dep` -eq 1 ]; then
			local headers="`get_headers $name`"
			echo $headers >$file_dep
		fi
	fi

	local update=`newer_than $file_c $file_o`
	if [ $update -eq 0 ]; then
		local headers="`cat $file_dep`"

		local file_h
		for file_h in $headers
		do
			update=`newer_than $file_h $file_o`
			if [ $update -eq 1 ]; then
				break
			fi
		done
	fi

	if [ $update -eq 1 ]; then
		run "gcc -c -Wall -Werror -O3$options $file_c -o $file_o"
	fi
	}

# Make a library.  We use -fPIC (Position Independent Code) so the object can
# be linked into a shared library.
make_lib()
	{
	local name=$1

	local file_so=lib/$g_project/lib$name.so
	local update=0
	local list_obj=""

	while [ $# -gt 0 ]; do
		local obj="$1"
		shift
		if [ "$obj" = "-" ]; then break; fi
		make_obj $obj " -fPIC"
		local file_o=obj/$obj.o
		list_obj="$list_obj $file_o"
		if [ $update -eq 0 ]; then
			update=`newer_than $file_o $file_so`
		fi
	done

	while [ $# -gt 0 ]; do
		local lib="$1"
		shift
		list_obj="$list_obj -l$lib"
	done

	if [ $update -eq 1 ]; then
		local options="-L lib/$g_project"
		run "gcc -s -shared $options$list_obj -o $file_so"
	fi
	}

# Make an executable program.
#
# We need the -Wl option so the program can find the local dynamic libraries.
# (Run ldd on bin/$name to see the dynamic linkage.)
#
# We use -s to remove all symbol table and relocation information.
#
# We use -rdynamic (aka --export-dynamic) so that dynamically loaded libraries
# will link to the functions defined in the program.  You must use this option
# for reliable results.
#
# We use $ORIGIN so the program can always find shared libraries relative to
# its own location, regardless of where you install it and from where you run
# it.  You can see the effect with "readelf -d bin/$g_project"
#
# We use --no-as-needed to force linkage with the shared libraries, which makes
# their functions available to the program with dlsym(NULL).

make_bin()
	{
	local name=$1

	local file_e=bin/$name
	local update=0
	local list_obj=""

	while [ $# -gt 0 ]; do
		local obj="$1"
		shift
		if [ "$obj" = "-" ]; then break; fi
		make_obj $obj ""
		local file_o=obj/$obj.o
		list_obj="$list_obj $file_o"
		if [ $update -eq 0 ]; then
			update=`newer_than $file_o $file_e`
		fi
	done

	while [ $# -gt 0 ]; do
		local lib="$1"
		shift
		local file_so=lib/$g_project/lib$lib.so
		list_obj="$list_obj -l$lib"
	done

	if [ $update -eq 1 ]; then
		local options="-L lib/$g_project"
		options="$options -Wl,-z,origin,-rpath,\$ORIGIN/../lib/$g_project,--no-as-needed"
		run "gcc -rdynamic -s $options$list_obj -o $file_e"
	fi
	}

do_erase()
	{
	rm -rf obj
	rm -rf lib
	rm -rf bin
	}

# Guard against disaster.
sanity_check()
	{
	if [ "$g_place" = "" ]; then
		echo 2>&1 "Sorry, this script is broken (it didn't set g_place)."
		exit 1
	fi
	if [ "$g_project" = "" ]; then
		echo 2>&1 "Sorry, this script is broken (it didn't set g_project)."
		exit 1
	fi
	}

# Validate command line options and set global variables accordingly.
validate_options()
	{
	local valid=1

	g_quiet=0
	g_clean=0
	g_erase=0
	g_install=0
	g_uninstall=0
	g_sysdir=/usr
	g_place=$g_sysdir

	while [ $# -gt 0 ]; do
		local verb="$1"
		shift
		case $verb in
			quiet) g_quiet=1 ;;
			clean) g_clean=1 ;;
			erase) g_erase=1 ;;
			install) g_install=1 ;;
			uninstall) g_uninstall=1 ;;
			in)
				if [ $# -gt 0 ]; then
					g_place="$1"
					shift
				else
					valid=0
				fi
				;;
			*) valid=0 ;;
		esac
	done

	if [ $valid -eq 0 ]; then usage; fi

	if [ $g_install -eq 1 -a $g_uninstall -eq 1 ]; then
		echo 2>&1 "That combination of options makes no sense."
		exit 2
	fi

	if [ $g_install -eq 1 -o $g_uninstall -eq 1 ]; then
		if [ $g_place -ef . ]; then
			echo 2>&1 "You can't install or uninstall in the current directory."
			exit 2
		fi
	fi

	sanity_check
	}

do_install()
	{
	sanity_check
	run "mkdir -p $g_place"
	run "mkdir -p $g_place/bin"
	run "mkdir -p $g_place/lib"
	run "mkdir -p $g_place/share"

	local name
	for name in $g_publish_bin
	do
		run "cp -p bin/$name $g_place/bin/"
	done

	run "rm -rf $g_place/lib/$g_project"
	run "cp -pr lib/$g_project $g_place/lib/"

	run "rm -rf $g_place/share/$g_project"
	run "cp -pr share/$g_project $g_place/share/"

	for name in $g_publish_bin
	do
		run "chown $USER:$USER $g_place/bin/$name"
	done

	run "chown -R $USER:$USER $g_place/lib/$g_project"
	run "chown -R $USER:$USER $g_place/share/$g_project"

	# Now, in case you're running under sudo, change the permissions on the
	# locally created directories back to the underlying user. Otherwise you'd
	# have files owned by root in your local directory, which is annoying.

	if [ "$SUDO_USER" != "" ]; then
		run "chown -f -R $SUDO_USER:$SUDO_USER bin"
		run "chown -f -R $SUDO_USER:$SUDO_USER obj"
		run "chown -f -R $SUDO_USER:$SUDO_USER lib"
	fi
	}

do_uninstall()
	{
	sanity_check

	local name
	for name in $g_publish_bin
	do
		run "rm -f $g_place/bin/$name"
	done

	run "rm -rf $g_place/lib/$g_project"
	run "rm -rf $g_place/share/$g_project"
	run "quiet_rmdir $g_place/bin"
	run "quiet_rmdir $g_place/lib"
	run "quiet_rmdir $g_place/share"
	run "quiet_rmdir $g_place"
	}

do_build()
	{
	make_lib double
	make_lib file

	# jturner notes that -ldl is incompatible with OpenBSD, and is not needed.
	local os=`uname`
	if [ "$os" = "Linux" ]; then
		make_lib lib - dl
	else
		make_lib lib
	fi

	make_lib long
	make_lib str
	make_lib qfile
	make_lib qstr
	make_lib system
	make_lib var
	# These are just for testing.
	make_lib test
	make_lib show

	make_bin fexl basic buf die form memory parse resolve value \
		- double file lib long qfile qstr str system var show test
	}

main()
	{
	g_project=fexl
	g_publish_bin="fexl"

	validate_options "$@"

	if [ $g_uninstall -eq 1 ]; then
		do_uninstall
		exit
	fi

	if [ $g_clean -eq 1 -o $g_erase -eq 1 ]; then
		do_erase
        if [ $g_erase -eq 1 ]; then exit; fi
	fi

	mkdir -p bin
	mkdir -p obj
	mkdir -p lib/$g_project

	do_build

	if [ $g_install -eq 1 ]; then
		do_install
	fi
	}

main "$@"
