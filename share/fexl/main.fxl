#

# TODO make sure we have tests for all these

# The "if" function can enhance readability, e.g. instead of this:
#   (= x 0) A B
# you may prefer this:
#   if (= x 0) A B
\if=I

\not = (\x x F T)
\and = (\x\y x y F)
\or  = (\x\y x T y)

# Optional ("maybe") values:  no or (yes x)
\no  = (   \no\yes no)
\yes = (\x \no\yes yes x)

\pair=(\x\y\p p x y)

# Return the length of a list.
\length=(@\length\xs xs 0 \_\xs long_add 1 (length xs))

# (append xs ys) appends the two lists.
\append=(@\append\xs\ys xs ys \x\xs [x;append xs ys])

# (fold fn z xs) is the result of applying function fn to each element of list,
# starting with z.  So for example (+ fold 0) is the function which adds up all
# the elements of a list.
\fold=(@\fold\fn\z\xs xs z \x\xs \z==(fn z x) fold fn z xs)

# (filter f xs) filters the list xs with function f, only returning the entries
# for which (f x) is true.
\filter=(@\filter\f\xs xs end \x\xs f x (item x) I; filter f xs)

# (map f xs) is the list of (f x) values for each x in xs.
\map=(@\map\f\xs xs [] \x\xs [(f x); map f xs])

# Apply function f to each entry in xs, ending with next.  This is useful for
# producing a side-effect for each entry in a list.
\each = (@\each\xs\f xs () \x\xs f x; each xs f)

# (choose xs ys) returns the list of all y in ys where the corresponding x in
# xs is true.  The xs is a list of bits which serves as a "mask".
\choose =
	(@\choose\xs\ys
	xs end \x\xs
	ys end \y\ys
	x (item y) I (choose xs ys)
	)

# (sort keep compare xs) sorts the list xs using the three-way comparison
# function.  It keeps duplicates if the keep flag is true, otherwise it
# discards them and returns only the unique entries.
\sort =
	(@\sort\keep\compare\xs
	xs end \x\xs

	\lo = (filter (\y compare y x T F F) xs)
	\hi = (filter (\y compare y x F keep T) xs)

	append (sort keep compare lo);
	item x;
	sort keep compare hi
	)

# Insert a separator between the elements of a list.
\join=
	(@\join\sep\list
	list [] \h\t
	t [h] \_\_ [h sep; (join sep t)]
	)

# The entry function returns the entry at a given position in a list, starting
# with 0.  If the position is beyond the end of the list, it returns [].
\entry=
	(
	@\entry\n\xs
	xs [] \x\xs
	long_compare n 0 [] x;
	entry (long_sub n 1) xs
	)

# Generate ordering functions.
\ordering=
	(\compare
	\lt=(\x\y compare x y T F F)
	\le=(\x\y compare x y T T F)
	\eq=(\x\y compare x y F T F)
	\ne=(\x\y compare x y T F T)
	\gt=(\x\y compare x y F F T)
	\ge=(\x\y compare x y F T T)
	\: : lt le eq ne gt ge
	)

ordering string_compare
\string_lt\string_le
\string_eq\string_ne
\string_gt\string_ge

ordering long_compare
\long_lt\long_le
\long_eq\long_ne
\long_gt\long_ge

ordering double_compare
\double_lt\double_le
\double_eq\double_ne
\double_gt\double_ge

# TODO make these the generic versions
\lt = long_lt
\le = long_le
\eq = long_eq
\ne = long_ne
\gt = long_gt
\ge = long_ge

\ <   = lt
\ <=  = le
\ =   = eq
\ !=  = ne
\ >   = gt
\ >=  = ge

# TODO full math operators
\add = long_add
\sub = long_sub
\mul = long_mul
\div = long_div

\ +  = add
\ -  = sub
\ *  = mul
\ /  = mul

# Return the list of long values in the range lo through hi.
\range=
	(
	@\range\lo\hi
	long_gt lo hi [];
	[lo; range (long_add lo 1) hi]
	)

# TODO with generic <= this would work with longs and doubles, but what if the
# list has strings too?  I suppose when comparing a number with a string we
# should auto-convert the number to string.

# Return the maximum element of a list, or 0 if the list is empty.
\max=(fold (\z\x if (> z x) z x) 0)
# Return the minimum element of a list, or 0 if the list is empty.
\min=(fold (\z\x if (< z x) z x) 0)

# The column function extracts column n from a matrix (list of rows).
\column=(\n map (entry n))

# The "columns" function takes a list of columns and produces the matrix with
# those columns.  This is also known as the "transpose" function.  For example:
#   (columns [["a" "b" "c"] [1 2 3]])) =
#   [["a" 1]
#    ["b" 2]
#    ["c" 3]]

\columns=
	(\xs
	map (\n column n xs) (range 1 (max (map length xs)))
	)

# TODO use the "properties" technique instead

# Convert nested data to a list of strings.
\flatten=
	(@\flatten\x
	\x==x
	is_string x [x];
	is_long x [(long_string x)];
	is_double x [(double_string x)];
	is_item x (\h\t append (flatten h) (flatten t));
	is_var x (flatten (var_get x));
	[]
	)

# Convert nested data to a string.
\to_string=(\x fold string_append "" (flatten x))

# Print nested data to a file handle.
\fprint=(\fh\x each (flatten x) (fwrite fh))

\print=(fprint stdout)
\warn=(fprint stderr)

\NL="
"
\nl=(print NL)

\say=(\x print x nl)

\die =
	(\msg
	warn [msg NL]
	exit 1
	)

\string_eq=(\x\y string_compare x y F T F)

\context =
	(\x
	\x==x
	\case=(\name\val string_eq x name [val])

	case "say" say;
	case "print" print;
	case "fprint" fprint;
	case "warn" warn;
	case "nl" nl;
	case "NL" NL;
	case "die" die;
	case "join" join;
	case "to_string" to_string;

	case "if" if;
	case "append" append;
	case "choose" choose;
	case "column" column;
	case "columns" columns;
	case "each" each;
	case "entry" entry;
	case "map" map;

	case "fold" fold;
	case "filter" filter;
	case "sort" sort;

	case "max" max;
	case "min" min;

	case "not" not;
	case "and" and;
	case "or" or;

	case "yes" yes;
	case "no" no;
	case "pair" pair;

	case "length" length;
	case "range" range;

	case "long_lt" long_lt;
	case "long_le" long_le;
	case "long_eq" long_eq;
	case "long_ne" long_ne;
	case "long_gt" long_gt;
	case "long_ge" long_ge;

	case "string_lt" string_lt;
	case "string_le" string_le;
	case "string_eq" string_eq;
	case "string_ne" string_ne;
	case "string_gt" string_gt;
	case "string_ge" string_ge;

	case "lt" lt;
	case "le" le;
	case "eq" eq;
	case "ne" ne;
	case "gt" gt;
	case "ge" ge;

	case "<"   <;
	case "<="  <=;
	case "="   =;
	case "!="  !=;
	case ">"   >;
	case ">="  >=;

	case "add" add;
	case "sub" sub;
	case "mul" mul;
	case "div" div;

	case "+" +;
	case "-" -;
	case "*" *;
	case "/" /;

	source_context x
	)

context
