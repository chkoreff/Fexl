# This parses the script specified on the command line and runs it in the
# standard context.  The standard context includes the functions built into C
# (names starting with "reduce_"), along with more functions written in Fexl
# (see "enhance" below).

# Synonyms
\T=C
\no=F

# Comparison
\long_eq = (\x\y order (long_cmp x y) F T F)
\string_eq = (\x\y order (string_cmp x y) F T F)

# I/O

\is_name = (\x type_named "name" (type_eq (type_of x)) F)

\to_string = (\x
	is_string x x;
	is_long x (long_string x);
	is_double x (double_string x);
	is_name x (name_string x);
	x
	)

# (fprint fh x) prints value x to file fh.
\fprint == (\fh\x fwrite fh; to_string x)

\print = (fprint stdout)
\warn = (fprint stderr)

\NL="
"

# (resolve_symbols symbols context exp error final)
#
# This looks up the definitions of all the symbols using the given context,
# applying each one in turn to the given expression.  For each symbol that is
# not defined, it calls (error name line) to indicate the name and line number
# of the missing symbol, and does not apply any definition to the expression.
#
# After applying all the definitions to the original expression exp, we end up
# with a new expression exp, and we return (final exp).

\resolve_symbols ==
	(\symbols\context\exp\error\final

	symbols (final exp) \sym\symbols
	sym \name\line

	\continue = (\exp resolve_symbols symbols context exp error final)

	context name
		(\val
		# The name is defined as val.
		continue (exp val)
		)
		(
		# The name is not defined.
		error name line;
		continue exp
		)
	)

# LATER 20120829
# The do_parse function is a temporary adaptor which maps the old result form
# returned from the built-in parse_string and parse_file routines, into a new
# cleaner mechanism where you just pass in handlers for various things.
\do_parse =
	(\parse\source\context\error_source\error_syntax\error_symbol\final

	parse source \ok\result result \exp\symbols

	ok ()
		(
		exp \error\line
		long_eq line 0
			(error_source)  # Could not open source
			(error_syntax error line)  # Syntax error
		);

	# Now resolve all the symbols with the given context.
	resolve_symbols symbols context exp error_symbol final
	)

# LATER 20120829 Fold the do_parse adaptor back into the C code.  This will
# require doing some tagged evaluation to simulate the operation of do_parse
# (and therefore resolve_symbols) within the C code itself, but that's no big
# deal.  I use that same technique for the built-in version of "fold".
#
# Here I override the built in C versions with the new versions.
\parse_string = (do_parse parse_string)
\parse_file = (do_parse parse_file)


# Print any errors in a parse result.
\print_parse_errors =
	(\result\label\print

	\nl = (print NL)

	# Report the error location.
	\error_at =
		(\line
		print " on line ";print line;
		print (string_eq label "" "" (string_append " of " label));
		nl;
		)

	\error_file ==
		(
		print "Can't open file ";print label;nl;
		)

	\error_syntax =
		(\error\line
		print error; error_at line;
		)

	\error_symbol =
		(\sym\line
		print "Undefined symbol "; print sym; error_at line;
		)

	result error_file error_syntax error_symbol (\_)
	)

# Get the expression from a parse result, returning (yes exp) if the result is
# good, or no if the result has errors.
\get_parsed_expression =
	(\result result (\_ no) (\_\_\_ no) (\_\_\_ no) yes)

# (check_parse result label good bad print)
#
# Check the result of a (parse source context) call, returning (good program)
# if there were no errors.  If there were errors, report them in English using
# the given print function, and return bad.

\check_parse =
	(\result\label\good\bad\print
	print_parse_errors result label print;
	get_parsed_expression result good bad
	)

\parse_script =
	(\name\context
	check_parse (parse_file name context) name I (exit 1) warn
	)

# Parse the module file with the given logical name.  This returns a value
# which, when applied to a context, returns the fully resolved function
# described in that file.
\module =
	(\name
	base_path \path
	\name =
		(
		string_append path;
		string_append "/share/fexl/";
		string_append name;
		".fxl"
		)

	parse_script name
	)

# (eval f) forces an evaluation of f and returns its value.
\eval = (\f \f=f f)

# LATER 20120828 simplify the module stuff.  I think I can do one-shot parsing
# without having to enumerate the available modules here.
# This wrapper caches the known module names so it never has to parse a file
# more than once.
\module =
	(
	\str
	\case=(string_eq str)
	case "a" (eval; module "a");
	case "c" (eval; module "c");
	case "compare" (eval; module "compare");
	case "d" (eval; module "d");
	case "double" (eval; module "double");
	case "e" (eval; module "e");
	case "f" (eval; module "f");
	case "g" (eval; module "g");
	case "ipc" (eval; module "ipc");
	case "l" (eval; module "l");
	case "list" (eval; module "list");
	case "long" (eval; module "long");
	case "math" (eval; module "math");
	case "meta" (eval; module "meta");
	case "m" (eval; module "m");
	case "n" (eval; module "n");
	case "p" (eval; module "p");
	case "rand" (eval; module "rand");
	case "r" (eval; module "r");
	case "ru_utime" (eval; module "ru_utime");
	case "run" (eval; module "run");
	case "s" (eval; module "s");
	case "string" (eval; module "string");
	case "v" (eval; module "v");
	module str
	)

# LATER 20120829 abstract the other modules so they don't use define, starts,
# sees, and void directly.

# This is the abstract description of the enhanced standard context.  Using an
# abstract description enables nice features in the future, such as automatic
# production of documentation.
\enhanced =
	(\standard\define\starts\see\void

	starts "+" (see "math");
	starts "-" (see "math");
	starts "*" (see "math");
	starts "/" (see "math");

	define "?" query;

	starts ">" (see "compare");
	starts "=" (see "compare");
	starts "<" (see "compare");
	starts "!=" (see "compare");

	starts "a" (see "a");
	starts "c"
		(
		define "check_parse" check_parse;
		see "c"
		);
	starts "d"
		(
		define "define" define;
		see "d"
		);
	starts "e"
		(
		define "eval" eval;
		see "e"
		);
	starts "f"
		(
		define "fprint" fprint;
		see "f"
		);
	starts "g" (see "g");
	starts "halt" (see "list");
	define "is_name" is_name;
	starts "l" (see "l");
	starts "m" (see "m");
	define "NL" NL;
	starts "n"
		(
		define "no" no;
		see "n"
		);
	starts "or" (see "list");
	starts "p"
		(
		define "print" print;
		see "p"
		);
	starts "quote_string" (see "meta");
	starts "r" (see "r");
	starts "s"
		(
		define "see" see;
		define "standard" standard;
		define "starts" starts;
		define "string_put" (fwrite stdout);
		define "string_stderr" (fwrite stderr);
		see "s"
		);
	define "T" T;
	starts "timer_" (see "ru_utime");
	define "to_string" to_string;
	starts "undefined" (see "list");
	starts "v"
		(
		define "void" void;
		see "v"
		);
	define "warn" warn;
	void
	)

# This is the standard context that resolves symbols in Fexl programs.
\standard ==
	(
	# Enhance the standard context.  We use the "enhanced" description above,
	# passing in values for its five parameters to create a fully functional
	# context.
	\standard =
		(
		\define = (\key\val\next \sym string_eq sym key (yes val) (next sym))

		\starts = (\key\inner\next
			\sym
			long_eq (string_common sym key) (string_len key) inner next
			sym
			)

		# The "see" function parses the file in the standard context.
		\see = (\file module file standard)

		\void = (\key no)

		enhanced standard define starts see void
		)

	# Here's the function which looks up the definition of a symbol.
	\sym
	\sym=sym  # Force evaluation in case it's a computed symbol.
	is_name sym
		(
		# LATER 20120829 This is a temporary hack to make the new parse
		# functions defined in this module override the core routines built
		# into C.
		\str=(name_string sym)
		string_eq str "parse_string" (yes parse_string);
		string_eq str "parse_file" (yes parse_file);

		# Look for a definition built into resolve.c.
		resolve sym yes;
		# We didn't find one there, so look through the enhancements.
		standard (name_string sym)
		);
	is_string sym (yes sym);  # Treat strings literally.
	no  # It's not a name or a string, so it's undefined.
	)

# Run the user's script in the standard context.
argv 1 \script
parse_script script standard;
