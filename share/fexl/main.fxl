# This script provides an enhanced context wrapped around another script.

### Boolean functions.

# Synonyms
\T=C
\no=F

# Logic functions
\and=(\x\y x y F)
\or=(\x\y x T y)
\not=(\x x F T)

# (defined x) is true if x is (yes val).
\defined = (\x x (\_ T) F)
# (undefined x) is true if x is no.
\undefined = (\x not (defined x))

# (default v x) =
#    v   if x is no
#    val if x is (yes val)
\default = (\v\x x I v)

# The halt function ends the evaluation of the current expression by consuming
# all arguments given to it.  It does not halt the entire program.
\halt==(\_ halt)

# (eval f) forces an evaluation of f and returns its value.
\eval = (\f \f=f f)

### Comparison functions
\long_eq = (\x\y order (long_cmp x y) F T F)
\string_eq = (\x\y order (string_cmp x y) F T F)

### List functions

# Define end as a synonym for C.  The item function is already built-in.
\end=C

# (map f xs) is the list of (f x) values for each x in xs.
\map == (\f\xs xs end \x\xs item (f x) (map f xs))

# Apply function f to each entry in xs, ending with next.  This is useful for
# producing a side-effect for each entry in a list.
\do == (\xs\f\next xs next \x\xs f x; do xs f next)

# (choose xs ys) returns the list of all y in ys where the corresponding x in
# xs is true.  The xs is a list of bits which serves as a "mask".
\choose ==
	(\xs\ys
	xs end \x\xs
	ys end \y\ys
	x (item y) I (choose xs ys)
	)

# LATER It's about 35% faster implemented in C, but let's revisit that after
# the rewrite.
\fold == (\fn\z\xs xs z \x\xs \z=(fn z x) fold fn z xs)

\list_and = (fold and T)
\list_or = (fold or F)

\all = (\f\xs list_and (map f xs))
\some = (\f\xs list_or (map f xs))

###

\is_name = (\x type_named "name" (type_eq (type_of x)) F)

\to_string = (\x
	is_string x x;
	is_long x (long_string x);
	is_double x (double_string x);
	is_name x (name_string x);
	x
	)

# (fprint fh x) prints value x to file fh.
\fprint == (\fh\x fwrite fh; to_string x)

\print = (fprint stdout)
\warn = (fprint stderr)

# LATER move putchar, NL, and die to separate files.

# Synonyms
\putchar = char_put
\getchar = char_get

\NL="
"

\die =
	(\msg
	warn msg; warn NL;
	exit 1;
	)

# (resolve_symbols syms context exp final error bad)
#
# This looks up the definitions of all the symbols using the given context,
# applying each one in turn to the given expression.  For each symbol that is
# not defined, it calls (error name place) to indicate the name and line number
# of the missing symbol, and uses the name itself as the dummy definition.
#
# After applying all the definitions to the original expression exp, we end up
# with a new expression exp.  If all the symbols were properly defined, we
# return (final exp).  If any symbols were undefined, we return (bad exp).

\resolve_symbols ==
	(\syms\context\exp\final\error\bad
	syms (final exp) \sym\syms
	sym \name\place

	\continue = (\val\final
		resolve_symbols syms context (exp val) final error bad)

	context name
		(\val
		# The name is defined as val.  We force an evaluation of the value,
		# which isn't strictly necessary on a functional basis, but useful when
		# using reflective features.  By forcing evaluation, the value is
		# reduced to its normal form, instead of lazily remaining as an
		# unevaluated form.
		\val=val
		continue val final
		)
		(
		error name place;
		continue name bad
		)
	)

# (check_parse parse source context label good bad print)
#
# Call the parse function on the source and resolve it in the given context,
# returning (good program) if there were no errors.  If there were errors,
# report them in English using the given print function, and return bad.  The
# label is the logical name used to identify the source in error messages.

\check_parse =
	(\parse\source\context\label\good\bad\print

	\nl = (print NL)

	# Report the error location.
	\error_at =
		(\line
		print " on line ";print line;
		(\next string_eq label "" next;
			print " of ";print label; next);
		nl;
		)

	\error_file ==
		(
		print "Can't open file ";print label;nl;
		)

	\error_syntax =
		(\error\line
		print error; error_at line;
		)

	\error_symbol =
		(\sym\line
		print "Undefined symbol "; print sym; error_at line;
		)

	parse source \ok\result result \exp\symbols

	# Report any syntax error.
	ok ()
		(
		exp \error\line
		long_eq line 0
			(error_file)
			(error_syntax error line)
		);

	# Resolve open symbols.
	resolve_symbols symbols context exp
		(
		\exp
		# All symbols were defined.
		ok exp bad
		)
		error_symbol
		(\exp
		# Some symbols were undefined.
		bad
		)
	)

\normal_parse_file =
	(\name\context
	check_parse parse_file name context name I (exit 1) warn
	)

# Parse the module file with the given logical name.  This returns a value
# which, when applied to a context, returns the fully resolved function
# described in that file.
\module =
	(\name
	base_path \path
	\name =
		(
		string_append path;
		string_append "/share/fexl/";
		string_append name;
		".fxl"
		)

	normal_parse_file name
	)

# LATER 20120828 simplify the module stuff.  I think I can do one-shot parsing
# without having to enumerate the available modules here.
# This wrapper caches the known module names so it never has to parse a file
# more than once.
\module =
	(
	\str
	string_eq str "a" (eval; module "a");
	string_eq str "compare" (eval; module "compare");
	string_eq str "double" (eval; module "double");
	string_eq str "ipc" (eval; module "ipc");
	string_eq str "list" (eval; module "list");
	string_eq str "long" (eval; module "long");
	string_eq str "math" (eval; module "math");
	string_eq str "meta" (eval; module "meta");
	string_eq str "m" (eval; module "m");
	string_eq str "rand" (eval; module "rand");
	string_eq str "r" (eval; module "r");
	string_eq str "ru_utime" (eval; module "ru_utime");
	string_eq str "run" (eval; module "run");
	string_eq str "s" (eval; module "s");
	string_eq str "string" (eval; module "string");
	string_eq str "v" (eval; module "v");
	module str
	)

# Context combinators

\void = (\key no)
\define = (\key\val\next \sym string_eq sym key (yes val) (next sym))
\starts = (\key\inner\next
	\sym
	long_eq (string_common sym key) (string_len key) inner next
	sym
	)

# Define an enhanced context in terms of the given standard context.
\enhance =
	(\standard
	# Parse the module file in the standard context.
	\see = (\file module file standard)

	starts "+" (see "math");
	starts "-" (see "math");
	starts "*" (see "math");
	starts "/" (see "math");

	define "?" query;

	starts ">" (see "compare");
	starts "=" (see "compare");
	starts "<" (see "compare");
	starts "!=" (see "compare");

	starts "a"
		(
		define "all" all;
		define "and" and;
		see "a"
		);
	starts "c"
		(
		define "choose" choose;
		starts "cmp" (see "compare");
		starts "compare" (see "compare");
		define "check_parse" check_parse;
		void
		);
	starts "d"
		(
		define "default" default;
		define "define" define;
		define "defined" defined;
		define "die" die;
		define "do" do;
		starts "double_" (see "double");
		void
		);
	starts "e"
		(
		define "end" end;
		starts "envs" (see "run");
		starts "eq" (see "compare");
		define "eval" eval;
		void
		);
	starts "f"
		(
		starts "filter" (see "list");
		starts "find" (see "list");
		define "fold" fold;
		define "fprint" fprint;
		void
		);
	starts "g"
		(
		define "getchar" getchar;
		starts "gt" (see "compare");
		starts "ge" (see "compare");
		void
		);
	define "halt" halt;
	define "is_name" is_name;
	starts "l"
		(
		starts "list"
			(
			define "list_and" list_and;
			define "list_or" list_or;
			see "list"
			);
		starts "long_" (see "long");
		starts "le" (see "compare");
		starts "lt" (see "compare");
		void
		);
	starts "m"
		(
		define "map" map;
		starts "min" (see "compare");
		starts "max" (see "compare");
		see "m"
		);
	define "NL" NL;
	starts "n"
		(
		define "no" no;
		define "not" not;
		starts "ne" (see "compare");
		void
		);
	define "or" or;
	define "print" print;
	define "putchar" putchar;
	starts "quote_string" (see "meta");
	starts "r"
		(
		see "r"
		);
	starts "s"
		(
		define "see" see;
		define "standard" standard;
		define "starts" starts;
		define "some" some;
		define "string_put" (fwrite stdout);
		define "string_stderr" (fwrite stderr);
		see "s"
		);
	define "T" T;
	starts "timer_" (see "ru_utime");
	define "to_string" to_string;
	define "undefined" undefined;
	starts "v"
		(
		define "void" void;
		see "v"
		);
	define "warn" warn;
	void
	)

# This is the standard context that resolves symbols in Fexl programs.
\standard ==
	(\sym
	\sym=sym  # Force evaluation in case it's a computed symbol.
	is_name sym
		(
		# Look for a definition built into resolve.c.
		resolve sym yes;
		# We didn't find one there, so look through the enhancements.
		enhance standard (name_string sym)
		);
	is_string sym (yes sym);  # Treat strings literally.
	no  # It's not a name or a string, so it's undefined.
	)

# Run the user's script in the standard context.
argv 1 \script
normal_parse_file script standard;
