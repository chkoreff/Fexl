# This parses the script specified on the command line and runs it in the
# standard context.  The standard context includes the functions built into C
# (names starting with "reduce_"), along with more functions written in Fexl
# (see "enhance" below).

# Synonyms
\T=C
\no=F

# Comparison
\long_eq = (\x\y order (long_cmp x y) F T F)
\string_eq = (\x\y order (string_cmp x y) F T F)

# I/O

\is_name = (\x type_named "name" (type_eq (type_of x)) F)

\to_string = (\x
	is_string x x;
	is_long x (long_string x);
	is_double x (double_string x);
	is_name x (name_string x);
	x
	)

# (fprint fh x) prints value x to file fh.
\fprint == (\fh\x fwrite fh; to_string x)

\print = (fprint stdout)
\warn = (fprint stderr)

\NL="
"

# (resolve_symbols symbols context)
# Resolve the symbols in the context.
#
# The symbols are a data structure like this:
#
#    (\:\.
#    : "a" 5;   # symbol "a" on line 5
#    : "b" 7;   # symbol "b" on line 7
#    : "c" 9;   # symbol "c" on line 9
#    .
#    )
#
# The context is a function mapping a symbol to its optional definition.
#
# The result is a data structure like this:
#
#    (\good\bad\end
#    good "a" 5 10;  # symbol "a" on line 5 defined with value 10
#    bad "b" 7;      # symbol "b" on line 7 not defined
#    good "c" 9 30;  # symbol "c" on line 9 defined with value 30
#    end
#    )
#
# This function forces evaluation all the way down the first time you use it,
# so subsequent uses do not evaluate the context again.

\resolve_symbols =
	(\symbols\context
	symbols
		(\name\line\next
		\good\bad\end
		context name
			(\val good name line val)
			(bad name line);
		next good bad end
		)
		(\good\bad\end end)
	)

# Get the optional final value from the resolved definitions.  This applies the
# original expression to each defined value in order, returning (yes value) if
# all the symbols were defined, or no otherwise.
#
# For example, if defs has three symbols defined as 10, 20, and 30, the value
# of (get_final_value defs exp) is (yes (exp 10 20 30)).  If defs has any
# undefined symbols, the value is no.
\get_final_value =
	(\defs\exp
	defs
		(\name\line\val\next\exp next (exp val) yes no)
		(\name\line\next\exp no)
		yes
		exp
	)

# These routines convert the old parse result from the inner C functions into a
# new parse result, which uses a more "functional data" technique to make it
# easier to use.  Eventually I'll fold these back into the C code to produce
# the new result directly.

\convert_parse_symbols ==
	(\symbols
	symbols (\:\. .) \entry\symbols
	entry \name\line
	\:\.
	: name line;
	convert_parse_symbols symbols : .
	)

\convert_parse_result =
	(\result
	result \ok\result result \exp\symbols
	\symbols = (convert_parse_symbols symbols)

	ok
		# Parse succeeded.
		(
		\form = (\ok\error ok exp)
		yes \: : form symbols
		)

		# Parse failed.
		(exp \error\line
		long_eq line 0
			# Source file is missing.
			no
			# Syntax is bad.
			(
			\form =
				(
				exp \msg\line
				\ok\error error msg line
				)

			yes \: : form symbols
			)
		)
	)

# Here I override the built in C versions with the new versions.
# LATER 20120902 Fold convert_parse_result back into the C code.

\parse_string = (\source convert_parse_result; parse_string source)
\parse_file = (\source convert_parse_result; parse_file source)


# (check_parse result context label good bad print)
#
# Check the result of a parse and resolve it in the context.  If there are no
# errors, return (good program).  If there are errors, report them in English
# using the given print function and return bad.  The label is used to identify
# the source of the parse in error messages, but it's omitted if null.
\check_parse =
	(\result\context\label\good\bad\print

	\nl = (print NL)

	# Report the error location.
	\error_at =
		(\line\next
		print " on line ";print line;
		print (string_eq label "" "" (string_append " of " label));
		nl;
		next
		)

	\error_file ==
		(\next
		print "Can't open file ";print label;nl;
		next
		)

	\error_syntax =
		(\error\line\next
		print error; error_at line;
		next
		)

	\error_symbol =
		(\name\line\next
		print "Undefined symbol ";print name;error_at line;
		next
		)

	\show_undefined_symbols =
		(\defs\next
		defs
			(\name\line\val\next next)
			error_symbol
			next
		)

	result
		(\result
		result \form\symbols
		\defs = (resolve_symbols symbols context)

		\final =
			(
			form
				(get_final_value defs)
				(\msg\line
				error_syntax msg line;
				no
				)
			)

		show_undefined_symbols defs;
		final good bad
		)
		( # Source file is missing.
		error_file;
		bad
		)
	)

# Parse the named script file and resolve it in the context.  If there are no
# errors, return the evaluable function denoted by that script in that context.
# If there are errors, report them to stderr and exit with status 1.
\eval_script =
	(\name\context
	check_parse (parse_file name) context name I (exit 1) warn
	)

# (eval f) forces an evaluation of f and returns its value.
\eval = (\f \f=f f)

# Context constructors.  A context is a function which maps a name (string) to
# an optional value, either (yes val) if defined or no if not defined.

# (define key val next name) is (yes val) if name equals key, or (next name)
# otherwise.
\define = (\key\val\next \sym string_eq sym key (yes val) (next sym))

# (starts key inner next name) is (inner name) if the name starts with key, or
# (next name) otherwise.
\starts = (\key\inner\next
	\sym
	long_eq (string_common sym key) (string_len key) inner next
	sym
	)

# (void name) is always no.
\void = (\name no)


# This function enhances the standard context with extra functions defined in
# the Fexl "share" directory.
\enhance =
	(
	# Parse the module file with the given logical name.  This returns a value
	# which, when applied to a context, returns the fully resolved function
	# described in that file.
	\module =
		(
		\full_path =
			(\name
			base_path \path
			string_append path;
			string_append "/share/fexl/";
			string_append name;
			".fxl"
			)

		\name
		eval_script (full_path name)
		)

	\standard

	# The "see" function parses the file in the standard context.
	\see =
		(\str
		\case=(string_eq str)
		case "a" (module "a" standard);
		case "c" (module "c" standard);
		case "compare" (module "compare" standard);
		case "d" (module "d" standard);
		case "double" (module "double" standard);
		case "e" (module "e" standard);
		case "f" (module "f" standard);
		case "g" (module "g" standard);
		case "ipc" (module "ipc" standard);
		case "l" (module "l" standard);
		case "list" (module "list" standard);
		case "long" (module "long" standard);
		case "math" (module "math" standard);
		case "meta" (module "meta" standard);
		case "m" (module "m" standard);
		case "n" (module "n" standard);
		case "p" (module "p" standard);
		case "rand" (module "rand" standard);
		case "r" (module "r" standard);
		case "ru_utime" (module "ru_utime" standard);
		case "run" (module "run" standard);
		case "s" (module "s" standard);
		case "string" (module "string" standard);
		case "v" (module "v" standard);
		void
		)

	starts "+" (see "math");
	starts "-" (see "math");
	starts "*" (see "math");
	starts "/" (see "math");

	define "?" query;

	starts ">" (see "compare");
	starts "=" (see "compare");
	starts "<" (see "compare");
	starts "!=" (see "compare");

	starts "a" (see "a");
	starts "c"
		(
		define "check_parse" check_parse;
		see "c"
		);
	starts "d"
		(
		define "define" define;
		see "d"
		);
	starts "e"
		(
		define "eval" eval;
		define "eval_script" eval_script;
		see "e"
		);
	starts "f"
		(
		define "fprint" fprint;
		see "f"
		);
	starts "g" (see "g");
	starts "halt" (see "list");
	define "is_name" is_name;
	starts "l" (see "l");
	starts "m" (see "m");
	define "NL" NL;
	starts "n"
		(
		define "no" no;
		see "n"
		);
	starts "or" (see "list");
	starts "p"
		(
		define "print" print;
		see "p"
		);
	starts "quote_string" (see "meta");
	starts "r" (see "r");
	starts "s"
		(
		define "see" see;
		define "standard" standard;
		define "starts" starts;
		define "string_put" (fwrite stdout);
		define "string_stderr" (fwrite stderr);
		see "s"
		);
	define "T" T;
	starts "timer_" (see "ru_utime");
	define "to_string" to_string;
	starts "undefined" (see "list");
	starts "v"
		(
		define "void" void;
		see "v"
		);
	define "warn" warn;
	void
	)

# This is the standard context that resolves symbols in Fexl programs.
\standard ==
	(
	\sym
	\sym=sym  # Force evaluation in case it's a computed symbol.
	is_name sym
		(
		# LATER 20120829 This is a temporary hack to make the new parse
		# functions defined in this module override the core routines built
		# into C.

		# LATER 20120905 any way to make enhanced functions override core
		# routines by default, instead of by exception?

		\str=(name_string sym)
		string_eq str "parse_string" (yes parse_string);
		string_eq str "parse_file" (yes parse_file);

		# Look for a definition built into resolve.c.
		resolve sym yes;
		# We didn't find one there, so look through the enhancements.
		enhance standard str
		);
	is_string sym (yes sym);  # Treat strings literally.
	no  # It's not a name or a string, so it's undefined.
	)

# Evaluate the user's script in the standard context.
argv 1 \script
eval_script script standard;
