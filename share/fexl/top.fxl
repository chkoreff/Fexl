# This script provides an enhanced context wrapped around another script.

### Boolean functions.

# Define T as a synonym for C.  F is already built-in.
\T=C

\and=(\x\y x y F)
\or=(\x\y x T y)
\not=(\x x F T)

# These functions represent a "possible" value, either (yes val) if you have a
# value or no if you don't.
\yes = (\val \yes\no yes val)
\no  = (     \yes\no no)

# (defined x) is true if x is (yes val).
\defined = (\x x (\_ T) F)
# (undefined x) is true if x is no.
\undefined = (\x not (defined x))

# (default v x) =
#    v   if x is no
#    val if x is (yes val)
\default = (\v\x x I v)

# The halt function ends the evaluation of the current expression by consuming
# all arguments given to it.  It does not halt the entire program.
\halt==(\_ halt)

# (eval f) forces an evaluation of f and returns its value.
\eval = (\f \f=f f)

### Comparison functions

\long_eq=(\x\y long_compare x y F T F)
\string_eq=(\x\y string_compare x y F T F)

### List functions

# Define end as a synonym for C.  The item function is already built-in.
\end=C

\map == (\f\xs xs end \x\xs item (f x) (map f xs))

# LATER more doc

# LATER perhaps implement fold in C to accelerate it.
\fold == (\f\z\xs xs z \x\xs \z=(f z x) fold f z xs)

# Apply function f to each entry in xs, returning next as the final value.
# This is used to produce a side-effect for each entry in a list.
\do == (\xs\f\next xs next \x\xs \x=(f x) do xs f next)

# (choose xs ys) returns the list of all y in ys where the corresponding x in
# xs is true.  The xs is a list of bits which serves as a "mask".
\choose ==
	(\xs\ys
	xs end \x\xs
	ys end \y\ys
	x (item y) I (choose xs ys)
	)

\list_and = (fold and T)
\list_or = (fold or F)

\all = (\f\xs list_and (map f xs))
\some = (\f\xs list_or (map f xs))

# (list_long x) is the list of all long values starting with x.
\list_long == (\x item x; \x=(long_add x 1) list_long x)

###

\is_name = (\x type_eq (type_of x) (type_named "name"))

\to_string = (\x
	is_string x x;
	is_long x (long_string x);
	is_double x (double_string x);
	is_name x (name_string x);
	x)

\print = (\data string_put (to_string data))
\warn = (\data string_stderr (to_string data))

# Resolve the result of parsing a file, where script is the name of the file,
# result is the return value from parse_file, context is the context for
# resolving undefined symbols, and next is what to do next.
#
# If there are any syntax or undefined symbol errors, it reports them to stderr
# and calls (exit 1).
\resolve_parse =
	(\script\result\context\next
	result \syntax_ok\result result \exp\symbols

	\defs = (map (\entry entry \sym\line context sym) symbols)
	\symbols_ok = (all defined defs)
	\ok = (and syntax_ok symbols_ok)
	\undef_symbols = (choose (map undefined defs) symbols)

	# Now we flatten all the yes/no entries into pure values, using a dummy
	# value of 0 for all no entries.  If we have any no entries we won't run
	# the program anyway, so these dummy values are never encountered anyway.
	\defs = (map (default 0) defs)

	# Now we rip through the list of defs and force an evaluation on each one.
	# This isn't strictly necessary on a functional basis, but it's useful when
	# you use reflective features like type_of, for example in a function such
	# as "show".  By forcing evaluation, a symbol like "C" is evaluated all the
	# way to its ultimate value, instead of lazily remaining as an unevaluated
	# function application.

	do defs (\val \val=val)

	# Now create the program, which is the result of applying exp to each of
	# the definitions in turn.
	\program == (ok (fold I exp defs) exp)

	# Override so we print to stderr instead of stdout.
	\print = warn
	\nl = (warn "
")

	# Report the error location.
	\error_at =
		(\line\next
		print " on line ";print line;print " of ";print script;nl;
		next
		)

	# Report any syntax error.
	syntax_ok ()
		(
		exp \error\line
		print error; error_at line;
		);

	# Report any undefined symbols.
	do undef_symbols
		(\sym
		sym \sym\line
		print "Undefined symbol "; print sym; error_at line;
		);

	# Run the program if it's ok, otherwise exit.
	ok program (exit 1);
	next
	)

# Parse the module file with the given logical name.  This returns a value
# which, when applied to a context, returns the actual fully resolved function 
# described in that file.
\module =
	(\name
	base_path \path
	\script =
		(
		string_append path;
		string_append "/share/fexl/";
		string_append name;
		".fxl"
		)
	parse_file script \result
	resolve_parse script result
	)

# This wrapper caches the known module names so it never has to parse a file
# more than once.
\module =
	(
	\str
	string_eq str "compare" (eval; module "compare");
	string_eq str "double" (eval; module "double");
	string_eq str "list" (eval; module "list");
	string_eq str "long" (eval; module "long");
	string_eq str "math" (eval; module "math");
	string_eq str "meta" (eval; module "meta");
	string_eq str "string" (eval; module "string");
	module str
	)

# This is the context which resolve symbols in Fexl programs.  If the symbol is
# a string, we treat that literally.  If the symbol is a name, we first look
# for a definition with the built-in "resolve" function.  If we don't find one
# there, we look for a definition among a large set of enhancements, which we
# can extend at will and partition across several files in the share directory.

\context ==
	(\sym

	is_name sym
	(
	resolve sym yes;  # First look for a built-in definition.

	# We didn't find one there, so convert the name to a string and let's
	# look among the enhancements.
	\sym = (name_string sym)

	# Make some helper functions.
	\if = (string_eq sym)

	\starts_with =
		(\prefix
		long_eq (string_common sym prefix) (string_len prefix)
		)

	\see = (\name module name context sym)

	# Now start looking.

	if "print" (yes print);
	if "warn" (yes warn);
	if "to_string" (yes to_string);

	if "T" (yes T);
	if "is_name" (yes is_name);
	if "halt" (yes halt);

	# a few synonyms
	if "?" (yes query);
	if "long_type" (yes is_long);
	if "double_type" (yes is_double);
	if "string_type" (yes is_string);

	if "eval" (yes eval);

	if "end" (yes end);
	if "fold" (yes fold);
	if "do" (yes do);
	if "map" (yes map);
	if "list_long" (yes list_long);

	if "yes" (yes yes);
	if "no" (yes no);

	if "and" (yes and);
	if "or" (yes or);
	if "not" (yes not);
	if "defined" (yes defined);
	if "undefined" (yes undefined);
	if "default" (yes default);
	if "all" (yes all);
	if "some" (yes some);
	if "choose" (yes choose);
	if "list_and" (yes list_and);
	if "list_or" (yes list_or);

	if "find" (see "list");
	if "append" (see "list");
	if "reverse" (see "list");
	if "list_prefix" (see "list");
	if "list_at" (see "list");
	if "list_entry" (see "list");
	if "filter" (see "list");
	if "sort" (see "list");

	starts_with "long_" (see "long");
	starts_with "double_" (see "double");
	starts_with "string_" (see "string");

	if "quote_string" (see "meta");
	if "show" (see "meta");
	if "value_put" (see "meta");
	if "value_string" (see "meta");

	if "rand" (see "rand");
	if "args" (see "run");
	if "envs" (see "run");

	if "compare" (see "compare");
	if "<" (see "compare");
	if "<=" (see "compare");
	if "=" (see "compare");
	if "==" (see "compare");
	if ">=" (see "compare");
	if ">" (see "compare");
	if "!=" (see "compare");
	if "min" (see "compare");
	if "max" (see "compare");

	if "+" (see "math");
	if "-" (see "math");
	if "*" (see "math");
	if "/" (see "math");

	no  # The symbol is not defined.
	)
	(yes sym)  # Treat strings literally.
	)

# Run the user's script in the standard context.
argv 1 \script
parse_file script \result
resolve_parse script result context;
