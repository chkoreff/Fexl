# This script provides an enhanced context wrapped around another script.

### Boolean functions.

# Define T as a synonym for C.  F is already built-in.
\T=C

\and=(\x\y x y F)
\or=(\x\y x T y)
\not=(\x x F T)

# These functions represent a "possible" value, either (yes val) if you have a
# value or no if you don't.
\yes = (\val \yes\no yes val)
\no  = (     \yes\no no)

# (defined x) is true if x is (yes val).
\defined = (\x x (\_ T) F)
# (undefined x) is true if x is no.
\undefined = (\x not (defined x))

# (default v x) =
#    v   if x is no
#    val if x is (yes val)
\default = (\v\x x I v)

# The halt function ends the evaluation of the current expression by consuming
# all arguments given to it.  It does not halt the entire program.
\halt==(\_ halt)

### Comparison functions

\long_lt=(\x\y long_compare x y T F F)
\long_le=(\x\y long_compare x y T T F)
\long_eq=(\x\y long_compare x y F T F)

\string_eq=(\x\y string_compare x y F T F)

### List functions

# Define end as a synonym for C.  The item function is already built-in.
\end=C

\map == (\f\xs xs end \x\xs item (f x) (map f xs))

# LATER more doc

# LATER perhaps implement fold in C to accelerate it.
\fold == (\f\z\xs xs z \x\xs \z=(f z x) fold f z xs)

\do == (\xs\f\end xs end \x\xs f x; do xs f end)

# (choose xs ys) returns the list of all y in ys where the corresponding x in
# xs is true.  The xs is a list of bits which serves as a "mask".
\choose ==
	(\xs\ys
	xs end \x\xs
	ys end \y\ys
	x (item y) I (choose xs ys)
	)

\list_and = (fold and T)
\list_or = (fold or F)

\all = (\f\xs list_and (map f xs))
\some = (\f\xs list_or (map f xs))

# (list_long x) is the list of all long values starting with x.
\list_long == (\x item x; \x=(long_add x 1) list_long x)

###

\is_name = (\x type_eq (type_of x) (type_named "name"))

\to_string = (\x
	is_string x x;
	is_long x (long_string x);
	is_double x (double_string x);
	is_name x (name_string x);
	x)

\print = (\data string_put (to_string data))
\warn = (\data string_stderr (to_string data))

# Resolve the result of parsing a file, where script is the name of the file,
# result is the return value from parse_file, context is the context for
# resolving undefined symbols, and next is what to do next.
#
# If there are any syntax or undefined symbol errors, it reports them to stderr
# and calls (exit 1).
\resolve_parse =
	(\script\result\context\next
	result \syntax_ok\result result \exp\symbols

	\defs = (map (\entry entry \sym\line context sym) symbols)
	\symbols_ok = (all defined defs)
	\ok = (and syntax_ok symbols_ok)
	\undef_symbols = (choose (map undefined defs) symbols)

	# Now we flatten all the yes/no entries into pure values, using a dummy
	# value of 0 for all no entries.  If we have any no entries we won't run
	# the program anyway, so these dummy values are never encountered anyway.
	\defs = (map (default 0) defs)

	# Now we rip through the list of defs and force an evaluation on each one.
	# This isn't strictly necessary on a functional basis, but it's useful when
	# you use reflective features like type_of, for example in a function such
	# as "show".  By forcing evaluation, a symbol like "C" is evaluated all the
	# way to its ultimate value, instead of lazily remaining as an unevaluated
	# function application.

	do defs (\val \val=val)

	# Now create the program, which is the result of applying exp to each of
	# the definitions in turn.
	\program == (ok (fold I exp defs) exp)

	# Override so we print to stderr instead of stdout.
	\print = warn
	\nl = (warn "
")

	# Report the error location.
	\error_at =
		(\line\next
		print " on line ";print line;print " of ";print script;nl;
		next
		)

	# Report any syntax error.
	syntax_ok ()
		(
		exp \error\line
		print error; error_at line;
		);

	# Report any undefined symbols.
	do undef_symbols
		(\sym
		sym \sym\line
		print "Undefined symbol "; print sym; error_at line;
		);

	# Run the program if it's ok, otherwise exit.
	ok program (exit 1);
	next
	)

# Parse the module file with the given logical name.  This returns a value
# which, when applied to a context, returns the actual fully resolved function 
# described in that file.
\module =
	(\name
	base_path \path
	\script =
		(
		string_append path;
		string_append "/share/fexl/";
		string_append name;
		".fxl"
		)
	parse_file script \result
	resolve_parse script result
	)

# This is the context which resolve symbols in Fexl programs.  If the symbol is
# a string, we treat that literally.  If the symbol is a name, we first look
# for a definition with the built-in "resolve" function.  If we don't find one
# there, we look for a definition among a large set of enhancements, which we
# can extend at will and partition across several files in the share directory.

\context ==
	(\sym

	is_name sym
	(
	resolve sym yes;  # First look for a built-in definition.

	# We didn't find one there, so convert the name to a string and let's
	# look among the enhancements.
	\sym = (name_string sym)

	# Make some helper functions.
	\if = (string_eq sym)

	\starts_with =
		(\prefix
		long_eq (string_common sym prefix) (string_len prefix)
		)

	# We create handles to all potential modules here, which prevents parsing
	# any module file more than once.
	\module_string == (module "string" context)
	\module_list == (module "list" context)
	\module_long == (module "long" context)
	\module_double == (module "double" context)
	\module_meta == (module "meta" context)
	\module_rand == (module "rand" context)
	\module_run == (module "run" context)
	\module_compare == (module "compare" context)
	\module_math == (module "math" context)

	# Now start looking.

	if "print" (yes print);
	if "warn" (yes warn);
	if "to_string" (yes to_string);

	if "T" (yes T);
	if "is_name" (yes is_name);
	if "halt" (yes halt);

	# a few synonyms
	if "?" (yes query);
	if "long_type" (yes is_long);
	if "double_type" (yes is_double);
	if "string_type" (yes is_string);

	if "end" (yes end);
	if "fold" (yes fold);
	if "do" (yes do);
	if "map" (yes map);
	if "list_long" (yes list_long);

	if "yes" (yes yes);
	if "no" (yes no);

	if "and" (yes and);
	if "or" (yes or);
	if "not" (yes not);
	if "defined" (yes defined);
	if "undefined" (yes undefined);
	if "default" (yes default);
	if "all" (yes all);
	if "some" (yes some);
	if "choose" (yes choose);
	if "list_and" (yes list_and);
	if "list_or" (yes list_or);

	if "find" (module_list sym);
	if "append" (module_list sym);
	if "reverse" (module_list sym);
	if "list_prefix" (module_list sym);
	if "list_at" (module_list sym);
	if "list_entry" (module_list sym);
	if "filter" (module_list sym);
	if "sort" (module_list sym);

	starts_with "long_" (module_long sym);
	starts_with "double_" (module_double sym);
	starts_with "string_" (module_string sym);

	if "quote_string" (module_meta sym);

	if "show" (module_meta sym);
	if "value_put" (module_meta sym);
	if "value_string" (module_meta sym);
	if "rand" (module_rand sym);
	if "args" (module_run sym);
	if "envs" (module_run sym);

	if "compare" (module_compare sym);
	if "<" (module_compare sym);
	if "<=" (module_compare sym);
	if "=" (module_compare sym);
	if "==" (module_compare sym);
	if ">=" (module_compare sym);
	if ">" (module_compare sym);
	if "!=" (module_compare sym);
	if "min" (module_compare sym);
	if "max" (module_compare sym);

	if "+" (module_math sym);
	if "-" (module_math sym);
	if "*" (module_math sym);
	if "/" (module_math sym);

	no  # The symbol is not defined.
	)
	(yes sym)  # Treat strings literally.
	)

# Run the user's script in the standard context.
argv 1 \script
parse_file script \result
resolve_parse script result context;
