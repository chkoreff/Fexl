# This script provides an enhanced context wrapped around another script.

#### [ auxiliary definitions

### Boolean functions.

# Define T as a synonym for C.  F is already built-in.
\T=C

\and=(\x\y x y F)
\or=(\x\y x T y)
\not=(\x x F T)

# These functions represent a "possible" value, either (yes val) if you have a
# value or no if you don't.
\yes = (\val \yes\no yes val)
\no  = (     \yes\no no)

# (defined x) is true if x is (yes val).
\defined = (\x x (\_ T) F)
# (undefined x) is true if x is no.
\undefined = (\x not (defined x))

# (default v x) =
#    v   if x is no
#    val if x is (yes val)
\default = (\v\x x I v)

# The halt function ends the evaluation of the current expression by consuming
# all arguments given to it.  It does not halt the entire program.
\halt==(\_ halt)

### Comparison functions

\long_lt=(\x\y long_compare x y T F F)
\long_le=(\x\y long_compare x y T T F)
\long_eq=(\x\y long_compare x y F T F)
\long_ge=(\x\y long_compare x y F T T)
\long_gt=(\x\y long_compare x y F F T)
\long_ne=(\x\y long_compare x y T F T)

\long_min = (\x\y long_compare x y  x x y)
\long_max = (\x\y long_compare x y  y x x)

\double_lt=(\x\y double_compare x y T F F)
\double_le=(\x\y double_compare x y T T F)
\double_eq=(\x\y double_compare x y F T F)
\double_ge=(\x\y double_compare x y F T T)
\double_gt=(\x\y double_compare x y F F T)
\double_ne=(\x\y double_compare x y T F T)

\double_min = (\x\y double_compare x y  x x y)
\double_max = (\x\y double_compare x y  y x x)

\string_lt=(\x\y string_compare x y T F F)
\string_le=(\x\y string_compare x y T T F)
\string_eq=(\x\y string_compare x y F T F)
\string_ge=(\x\y string_compare x y F T T)
\string_gt=(\x\y string_compare x y F F T)
\string_ne=(\x\y string_compare x y T F T)

\string_min = (\x\y string_compare x y  x x y)
\string_max = (\x\y string_compare x y  y x x)

### [ Comparison functions capable of handling long, double, and string.

\compare =
	(\x\y
	is_long x
		(
		is_long y (long_compare x y);
		is_double y (double_compare (long_double x) y);
		halt
		);
	is_double x
		(
		is_double y (double_compare x y);
		is_long y (double_compare x (long_double y));
		halt
		);
	is_string x
		(
		is_string y (string_compare x y);
		halt
		);
	halt
	)

\ <   =(\x\y compare x y  T F F)
\ <=  =(\x\y compare x y  T T F)
\ =   =(\x\y compare x y  F T F)
\ ==  =(\x\y compare x y  F T F)
\ >=  =(\x\y compare x y  F T T)
\ >   =(\x\y compare x y  F F T)
\ !=  =(\x\y compare x y  T F T)

\min  =(\x\y compare x y  x x y)
\max  =(\x\y compare x y  y x x)

### ]

### List functions
# Define end as a synonym for C.  The item function is already built-in.
\end=C

\append == (\xs\ys xs ys \x\xs item x; append xs ys)

# Push all entries in list xs onto list ys.
\push_all==(\xs\ys xs ys \x\xs push_all xs (item x ys))

# Reverse list xs.
\reverse=(\xs push_all xs end)

# LATER more doc

\map == (\f\xs xs end \x\xs item (f x) (map f xs))

# LATER perhaps implement fold in C to accelerate it.
\fold == (\f\z\xs xs z \x\xs \z=(f z x) fold f z xs)

\do == (\xs\f\end xs end \x\xs f x; do xs f end)

\list_and = (fold and T)
\list_or = (fold or F)

\all = (\f\xs list_and (map f xs))
\some = (\f\xs list_or (map f xs))

# (filter f xs) filters the list xs with function f, only returning the entries
# for which (f x) is true.
\filter == (\f\xs xs end \x\xs f x (item x) I; filter f xs)

# (choose xs ys) returns the list of all y in ys where the corresponding x in
# xs is true.  The xs is a list of bits which serves as a "mask".
\choose ==
	(\xs\ys
	xs end \x\xs
	ys end \y\ys
	x (item y) I (choose xs ys)
	)

# (sort keep compare xs) sorts the list xs using the three-way comparison
# function.  It keeps duplicates if the keep flag is true, otherwise it
# discards them and returns only the unique entries.
\sort ==
	(\keep\compare\xs
	xs end \x\xs

	\lo = (filter (\y compare y x T F F) xs)
	\hi = (filter (\y compare y x F keep T) xs)

	append (sort keep compare lo);
	item x;
	sort keep compare hi
	)

# Return the first N items of the list.
\list_prefix == (\list\N
	long_le N 0 end;
	list end \head\tail
	\N = (long_sub N 1)
	item head; list_prefix tail N
	)

# Return the possible entry at position n in list xs.
\list_entry == (\xs\n
	xs no \x\xs
	long_compare n 0 no (yes x)
	\n = (long_sub n 1)
	list_entry xs n
	)

# Return the entry at position n in list xs, or v if no such position.
\list_at = (\xs\n\v list_entry xs n I v)

# The math_op function is internal only to help us build the operators below.
\math_op = (\f\g
	\x\y
	is_long x
		(
		is_long y
			(f x y)
			(\x = (long_double x) g x y)
		)
		(
		is_long y
			(\y = (long_double y) g x y)
			(g x y)
		)
	)

\+ = (math_op long_add double_add)
\- = (math_op long_sub double_sub)
\* = (math_op long_mul double_mul)
\/ = (math_op long_div double_div)

\is_name = (\x type_eq (type_of x) (type_named "name"))

\to_string = (\x
	is_string x x;
	is_long x (long_string x);
	is_double x (double_string x);
	is_name x (name_string x);
	x)

\print = (\data string_put (to_string data))
\warn = (\data string_stderr (to_string data))

# Quote a string.
#
# If the string does not contain quotes, then wrap quotes around it.
#
# If the string does contain quotes, then wrap tilde terminators around it,
# including a space after the first one.  In choosing the terminator, the
# function tries the values "~", "~1", "~2" etc. until it finds one that is not
# contained within the string.

# LATER I could rewrite this far more simply by generating the infinite list of
# all possible terminators and choosing the first one that doesn't appear in
# the string.  No need to convolve the production of terminator candidates with
# the testing and application like this.  The procedural style used here just
# muddies the waters.

\quote_string =
	(
	\try_quote_level==
		(\level\str

		# Choose the terminator string for this level.
		\term =
			(
			(= level 0) ~ "~;  # Try quote first.
			(= level 1) "~";   # Try tilde next.
			# Beyond that, try appending tilde to level minus one.
			string_append "~" (long_string (- level 1))
			)

		# See if the terminator appears inside the string.
		\pos=(string_index str term 0)

		< pos 0
			# It does not appear, so enclose string in pair of terminators.
			(
			# Start with the first terminator.
			string_append term;

			(= level 0
				# Using a quote, so don't use a space.
				()
				# Using a tilde, so use a space.
				(string_append " ")
			);

			# Then follow with the string itself and the terminator again.
			string_append str; term
			)

			# It does appear, so try again with the next level.
			(try_quote_level (+ level 1) str)
		)

	try_quote_level 0
	)

# Convert the value to a tree with the given leaf and branch functions.
\value_tree =
	(\value\leaf\branch

	is_apply value branch;

	\if_type=(type_eq (type_of value))

	\if_basic=(\val\type_name
		if_type (type_of val) (leaf type_name))

	\if_data=(\type_name\to_string
		if_type (type_named type_name) (leaf (to_string value)))

	if_data "long" long_string;
	if_data "double" double_string;
	if_data "string" quote_string;
	if_data "name" name_string;
	if_basic C "C";
	if_basic S "S";
	if_basic I "I";
	if_basic Y "Y";
	if_basic L "L";
	if_basic R "R";
	if_basic F "F";
	if_basic query "?";
	if_basic parse "parse";
	if_basic lambda "lam";
	if_basic resolve "resolve";
	if_basic long_add "long_add";
	if_basic double_add "double_add";
	if_basic string_append "string_append";
	if_basic is_long "is_long";
	if_basic long_double "long_double";
	if_basic end "end";
	if_basic item "item";
	if_basic pair "pair";
	if_basic nl "nl";

	leaf "_" # unknown
	)

# Print a value.
\value_put ==
	(\value\next
	value_tree value (\x string_put x next)
	\L\R
	string_put "(";
	value_put L;
	string_put " ";
	value_put R;
	string_put ")";
	next
	)

# Convert value to a string representation.
\value_string ==
	(\value
	value_tree value I
	\L\R
	string_append "(";
	string_append (value_string L);
	string_append " ";
	string_append (value_string R);
	string_append ")";
	""
	)

# Show a value (shorthand for value_put).
\show = value_put

# Collect an array into a list.
\array_list =
	(\f_count\f_get
	f_count \n

	\collect ==
		(\i
		long_lt i n
			(
			f_get i \val
			\i = (long_add i 1)
			item val; collect i
			)
			end
		)
	
	collect 0
	)

# The list of command-line arguments.
\args = (array_list argc argv)
# The list of shell environment bindings (name=value strings).
\envs = (array_list envc envp)

# Here's an example of how you could print those two lists:
# \print_entry = (\val print "  ";print val;nl;)
# print "args:";nl; do args print_entry;
# print "envs:";nl; do envs print_entry;


# (rand x) is the infinite list of pseudo-random long numbers, starting with
# seed x, generated by the linear congruential generator with the constants
# chosen by Donald Knuth.  See:
#     https://en.wikipedia.org/wiki/Linear_congruential_generator
#
# This one however uses signed 64-bit long values, not unsigned values as
# suggested by that Wiki page.  I suppose this is OK, and we can just let it
# roll with signed numbers, letting them underflow and overflow at will,
# because 64 bits are 64 bits and it doesn't really matter if one of them is a
# sign bit.  I need to analyze it a bit further to make sure this is true.
#
# Just for reference, here are a few relevant constants:
#
#   m = 2^64 = 18446744073709551616
#       2^63 =  9223372036854775808
#          a =  6364136223846793005
#          c =  1442695040888963407
#
# Signed longs are in the range -2^63 .. 2^63-1.

\rand ==
	(\x
	\a = 6364136223846793005
	\c = 1442695040888963407
	\x = (long_add c; long_mul a x)
	item x; rand x
	)

#### ] auxiliary definitions

###########################

# Run a program in the normal way, resolving it in the given context and
# reporting any errors, running the program only if there were no errors.
\run_program =
	(\script\result\context\next
	result \syntax_ok\result result \exp\symbols

	\defs = (map (\entry entry \sym\line context sym) symbols)
	\symbols_ok = (all defined defs)
	\ok = (and syntax_ok symbols_ok)
	\undef_symbols = (choose (map undefined defs) symbols)

	# Now we flatten all the yes/no entries into pure values, using a dummy
	# value of 0 for all no entries.  If we have any no entries we won't run
	# the program anyway, so these dummy values are never encountered anyway.
	\defs = (map (default 0) defs)

	# Now we rip through the list of defs and force an evaluation on each one.
	# This isn't strictly necessary on a functional basis, but it's useful when
	# you use reflective features like type_of, for example in a function such
	# as "show".  By forcing evaluation, a symbol like "C" is evaluated all the
	# way to its ultimate value, instead of lazily remaining as an unevaluated
	# function application.

	do defs (\val \val=val)

	# Now create the program, which is the result of applying exp to each of
	# the definitions in turn.
	\program == (ok (fold I exp defs) exp)

	# Override so we print to stderr instead of stdout.
	\print = warn
	\nl = (warn "
")

	# Report the error location.
	\error_at =
		(\line\next
		print " on line ";print line;print " of ";print script;nl;
		next
		)

	# Report any syntax error.
	syntax_ok ()
		(
		exp \error\line
		print error; error_at line;
		);

	# Report any undefined symbols.
	do undef_symbols
		(\sym
		sym \sym\line
		print "Undefined symbol "; print (is_name sym I quote_string sym);
		error_at line;
		);
	
	# Run the program if it's ok, otherwise exit.
	ok program (exit 1);
	next
	)

# The enhanced context for Fexl programs.
\enhanced_context =
	(\sym

	# LATER read enhancements on-demand from separate files.
	\if=(\name\def string_eq sym name (yes def))

	if "print" print;
	if "warn" warn;
	if "to_string" to_string;

	if "show" show;
	if "quote_string" quote_string;
	if "value_put" value_put;
	if "value_string" value_string;

	if "T" T;
	if "is_name" is_name;
	if "halt" halt;

	# a few synonyms
	if "?" query;
	if "long_type" is_long;
	if "double_type" is_double;
	if "string_type" is_string;

	if "end" end;
	if "append" append;
	if "reverse" reverse;
	if "fold" fold;
	if "do" do;
	if "map" map;

	if "list_prefix" list_prefix;
	if "list_at" list_at;
	if "list_entry" list_entry;

	if "yes" yes;
	if "no" no;

	if "+" +;
	if "-" -;
	if "*" *;
	if "/" /;

	if "compare" compare;
	if "<" <;
	if "<=" <=;
	if "=" =;
	if "==" ==;
	if ">=" >=;
	if ">" >;
	if "!=" !=;
	if "min" min;
	if "max" max;

	if "and" and;
	if "or" or;
	if "not" not;
	if "defined" defined;
	if "undefined" undefined;
	if "default" default;
	if "all" all;
	if "some" some;
	if "filter" filter;
	if "choose" choose;
	if "sort" sort;
	if "list_and" list_and;
	if "list_or" list_or;

	if "long_lt" long_lt;
	if "long_le" long_le;
	if "long_eq" long_eq;
	if "long_ge" long_ge;
	if "long_gt" long_gt;
	if "long_ne" long_ne;
	if "long_min" long_min;
	if "long_max" long_max;

	if "double_lt" double_lt;
	if "double_le" double_le;
	if "double_eq" double_eq;
	if "double_ge" double_ge;
	if "double_gt" double_gt;
	if "double_ne" double_ne;
	if "double_min" double_min;
	if "double_max" double_max;

	if "string_lt" string_lt;
	if "string_le" string_le;
	if "string_eq" string_eq;
	if "string_ge" string_ge;
	if "string_gt" string_gt;
	if "string_ne" string_ne;
	if "string_min" string_min;
	if "string_max" string_max;

	if "args" args;
	if "envs" envs;

	if "rand" rand;
	no
	)

# Here's the context we actually use.  It resolves a name by first looking for
# a definition using the built-in "resolve" function.  If it doesn't find one
# there, it looks for a definition using the enhanced context.
\context =
	(\sym
	is_name sym
		(
		resolve sym yes;  # First look for a built-in definition.
		enhanced_context (name_string sym) yes;  # Now try the enhanced.
		no  # Oh well, the symbol is not defined.
		)
		(yes sym)  # Treat strings literally.
	)

# NOTE: You can do this sort of thing to impose limits on the script.
#put_max_steps 1000000;
#put_max_bytes 1000000;

# Now let's put it all together and run the user's script in the enhanced
# context.

argv 1 \script
parse_file script \result
run_program script result context;
