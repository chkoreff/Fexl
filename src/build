#!/bin/sh
# NOTE: This script cannot handle spaces in file names.

[ "$verbose" = "" ] && verbose=1

# stale $target $source1 ... $sourceN
# Return true if $target does not exist or is older than any $source.
stale()
	{
	local target="$1"; shift

	if [ ! -e $target ]; then
		true
		return
	fi

	for source in "$@"; do
		if [ $source -nt $target ]; then
			true
			return
		fi
	done

	false
	}

trace()
	{
	if [ $verbose -lt 1 ]; then return; fi
	echo $@
	}

# Run a system command and exit if unsuccessful.
run()
	{
	if [ $verbose -gt 1 ]; then
		trace $@
	fi
	$@
	local code=$?
	if [ $code -ne 0 ]; then exit $code; fi
	}

# Erase a file if it exists and remove any empty parent directories.
erase()
	{
	local name="$1"
	rm -f $name
	while [ true ]; do
		name=`dirname $name`
		if [ $name = . ]; then break; fi
		if [ -d $name ]; then
			rmdir --ignore-fail-on-non-empty $name
		fi
	done
	}

# We compile with -fdata-sections and -ffunction-sections so the linker can
# prune any unused data or functions with -Wl,--gc-sections.
compile="gcc -c -Wall -Werror -std=c99 -pedantic -Wunused-parameter \
-fdata-sections -ffunction-sections -O3"

link="gcc -s -Wl,--gc-sections"

# Establish .h dependencies for all .c files.
for file_c in `find . -name "*.c" | sort`; do
	file_c=${file_c#./}
	file_cache=../cache/h/$file_c
	stale $file_cache $file_c
	if [ $? -eq 0 ]; then
		mkdir -p `dirname $file_cache`
		grep -e "^#include" $file_c |
		sed "s/^#include *[<\"]\(.*\)[>\"].*$/\1/" >$file_cache
	fi
done

# See if any .c files have disappeared since the last run.
for file_dep in `find ../cache/h -name "*.c" 2>/dev/null | sort`; do
	file_c=${file_dep#../cache/h/}
	if [ ! -e $file_c ]; then
		base=${file_c%.c}
		erase $file_dep
		erase ../obj/$base.o
		erase ../bin/$base
		erase ../cache/o/$file_c
	fi
done

# List of updated .c files that are main programs.
list_main=""

# Compile any .c files that are out of date.
for file_c in `find . -name "*.c" | sort`; do
	file_c=${file_c#./}
	file_o=../obj/${file_c%.c}.o
	stale $file_o $file_c `cat ../cache/h/$file_c`
	if [ $? -eq 0 ]; then
		mkdir -p `dirname $file_o`
		trace Compile $file_c
		run $compile $file_c -I . -o $file_o
		erase ../cache/o/$file_c
		grep -q "^int main(" $file_c
		if [ $? -eq 0 ]; then
			list_main="$list_main $file_c"
		fi
	fi
done

# Update the list of .o files that need to be linked with any updated main
# programs.  This does a transitive closure of the .h dependencies.
for file_main in $list_main; do
	list_file_c=$file_main
	queue=$file_main
	while [ "$queue" != "" ]; do
		new_queue=""
		for file_c in $queue; do
			for file_h in `cat ../cache/h/$file_c`; do
				other_file_c=${file_h%.h}.c
				if [ -e $other_file_c ]; then
					found=0
					for entry in $list_file_c; do
						if [ "$entry" = "$other_file_c" ]; then
							found=1
							break
						fi
					done
					if [ $found -eq 0 ]; then
						list_file_c="$list_file_c $other_file_c"
						new_queue="$new_queue $other_file_c"
					fi
				fi
			done
		done
		queue=$new_queue
	done
	file_cache=../cache/o/$file_main
	mkdir -p `dirname $file_cache`
	objects=""
	for file_c in $list_file_c; do
		objects="$objects ../obj/${file_c%.c}.o"
	done
	echo $objects >$file_cache
done

# Link any main programs that are out of date.
for file_cache in `find ../cache/o -name "*.c" 2>/dev/null | sort`; do
	file_main=${file_cache#../cache/o/}
	objects=`cat $file_cache`
	file_e=../bin/${file_main%.c}
	stale $file_e $objects
	if [ $? -eq 0 ]; then
		trace Link $file_main
		mkdir -p `dirname $file_e`
		run $link $objects -o $file_e
	fi
done
