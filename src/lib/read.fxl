#
\is_eol=(\ch eq ch CR T; eq ch LF T; F)
\is_white=(\ch lt (ord ch) 33)

evaluate
(
define "is_eol" is_eol;
define "is_white" is_white;
standard
) \;

\make_context=
(\get\look

\skip==(\ch=get)

# Skip matching characters.
\skip_match=
	(\match
	@\loop
	\ch=look
	not (match ch) ();
	skip
	loop
	)

# Collect characters up to an ending condition.
\collect_to=
	(\end
	\buf=buf_new
	@\loop
	\ch=look
	end ch (buf_get buf);
	buf_put buf ch
	skip
	loop
	)

# Get a sequence of items with a given separator and end condition.
\get_seq=
	(\read\sep\end

	\sep=(\ch is_void ch F; sep ch)
	\end=(\ch is_void ch T; end ch)

	@\loop
	skip_match sep
	\ch=look
	end ch [];
	\x=read
	\xs=loop
	[x;xs]
	)

define "get" get;
define "look" look;
define "skip" skip;
define "skip_match" skip_match;
define "collect_to" collect_to;
define "get_seq" get_seq;
standard
)

\read_stream=
	(\read\get\look
	\context=(make_context get look)
	evaluate context read
	)

\read_string=
	(\read\str
	\fh=(readstr str)
	read_stream read (sgetc fh) (slook fh)
	)

\read_chars=
	(\read\chars
	\str=(to_str chars)
	read_string read str
	)

\read_file=
	(\read\name

	\fh=(fopen name "r")
	if (is_void fh) (error ["Could not open "name])
	\result=(read_stream read (fgetc fh) (flook fh))

	fclose fh
	result
	)

define "read_string" read_string;
define "read_chars" read_chars;
define "read_file" read_file;
standard
