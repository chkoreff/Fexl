# Parse the SSV (space-separated value) format.
# This is the "command line" syntax I use to specify event histories.
evaluate
(
:: standard;
:: (load "read.fxl");
:: (load "list.fxl");
void
) \;

# Collect a string up to the next occurrence of the terminator string.
\collect_string=
	(\term
	is_void term void;
	\term=(str_bytes term)

	\buf_result=buf_new
	\buf_match=buf_new

	\collect=
		(@\collect\in_term\term_tail
		term_tail (buf_get buf_result) \term_ch\term_tail

		\x=look
		eq x term_ch
			(
			# Current char matches the next term char, so save it.
			buf_put buf_match x
			skip
			collect T term_tail
			);

		# Current char does not match the next term char.
		in_term
			(
			# Add the previously matched terminator chars to the result.
			\matched=(buf_get buf_match)
			buf_put buf_result matched
			)
			(
			# Add current char to the result and proceed.
			buf_put buf_result x
			skip
			)
		collect F term
		)

	collect F term
	)

\get_plain_item==
	(
	collect_to
		(\x
		is_void x T;
		eq x QU T;
		eq x "~" T;
		is_white x
		)
	)

\get_item==
	(
	\x=look
	eq x QU
		(
		skip
		\str=(collect_to (eq QU))
		skip
		str
		);
	eq x "~"
		(
		skip
		\term=(collect_to is_white)
		skip
		collect_string (. x term)
		);
	get_plain_item
	)

\get_row==
	(@\loop
	skip_match (\x is_eol x F; is_white x)
	\x=look
	is_void x [];
	is_eol x [];
	\item=get_item
	is_void item [];
	\list=loop
	[item;list]
	)

\get_rows==
	(@\loop
	skip_match is_white
	\x=look
	is_void x [];
	\row=get_row
	\list=loop
	[row;list]
	)

\read_ssv_string=(read_string get_rows)
\read_ssv_chars=(read_chars get_rows)
\read_ssv_file=(read_file get_rows)

def "read_ssv_string" read_ssv_string;
def "read_ssv_chars" read_ssv_chars;
def "read_ssv_file" read_ssv_file;
void
