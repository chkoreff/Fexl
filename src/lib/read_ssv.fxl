# Parse the SSV (space-separated value) format.
# This is the "command line" syntax I use to specify event histories.
evaluate
(
use_lib "read.fxl";
standard
) \;

\read=
(\;

# Collect a string up to the next occurrence of the terminator string.
\collect_string=
	(\term
	\term=(str_bytes term)

	\buf_result=buf_new
	\buf_match=buf_new

	\collect=
		(@\collect\in_term\term_tail
		term_tail (buf_get buf_result) \term_ch\term_tail
		\ch=peek

		eq ch "" void; # end of stream
		eq ch term_ch
			(
			# Current char matches the next term char, so save it.
			buf_put buf_match ch
			skip
			collect T term_tail
			);

		# Current char does not match the next term char.
		in_term
			(
			# Add the previously matched terminator chars to the result.
			\matched=(buf_get buf_match)
			buf_put buf_result matched
			)
			(
			# Add current char to the result and skip forward.
			buf_put buf_result ch
			skip
			)
		collect F term
		)

	collect F term
	)

\get_plain_item==
	(
	collect_to
		(\ch eq ch QU T; eq ch "~" T; is_white ch)
	)

\get_item==
	(
	\ch=peek
	eq ch QU
		(
		skip
		\str=(collect_to (eq QU))
		skip
		str
		);
	eq ch "~"
		(
		skip
		\term=(collect_to is_white)
		skip
		collect_string (. ch term)
		);
	get_plain_item
	)

\get_row==
	(
	get_seq
		get_item
		(\ch is_eol ch F; is_white ch)
		is_eol
	)

\get_rows==
	(
	get_seq
		get_row
		is_white
		(\ch F)
	)

get_rows
)

\read_ssv_string=(read_string read)
\read_ssv_chars=(read_chars read)
\read_ssv_file=(read_file read)

define "read_ssv_string" read_ssv_string;
define "read_ssv_chars" read_ssv_chars;
define "read_ssv_file" read_ssv_file;
standard
