# Append lists xs and ys.
\append=
	(\xs\ys
	(@\loop\xs
	xs ys \x\xs
	\tail=(once; loop xs)
	[x;tail]
	)
	xs
	)

# Do f for each item in list xs.
\each=
	(\xs\f
	(@\loop\xs xs () \x\xs f x loop xs)
	xs
	)

# Apply f to each element in list xs.
\map=
	(\f @\loop \xs
	xs [] \x\xs
	\x=(f x)
	\tail=(once; loop xs)
	[x;tail]
	)

# Apply f to each element in list xs, but only keep the good results.
\map_good=
	(\fn @\loop \xs
	xs [] \x\xs
	\y=(fn x)
	\tail=(once; loop xs)
	is_good y (cons y) ();
	tail
	)

# (filter f xs) is the list of items x in xs for which (f x) is true.
\filter=
	(\f @\loop \xs
	xs [] \x\xs
	\tail=(once; loop xs)
	f x [x;tail] tail
	)

# Reverse list xs.
\reverse=
	(\xs
	# Push all entries in list xs onto list ys.
	(@\loop\xs\ys xs ys \x\xs loop xs [x;ys])
	xs []
	)

# Append a list of lists together.
\append_all=
	(@\loop\list
	list [] \top\list
	append top;
	loop list
	)

# Shift the first item off a list.
\shift=(\xs xs {void []} \x\xs {x xs})

# NOTE: Only used by deprecated g_sort.
\group_items_by_cmp=
	(\lt\eq\gt @\loop\xs
	xs [] \x\xs

	\ltx=(filter (gt x) xs)
	\eqx=(filter (eq x) xs)
	\gtx=(filter (lt x) xs)

	append (loop ltx);
	cons [x;eqx];
	loop gtx
	)

# Return the ordered list of items in xs.  Discard duplicates if opt_unique is
# true.  Use the given comparison functions to compare items.
# NOTE 20180119 This is deprecated.  For arbitrary objects, using a single
# key extraction function is far simpler than using three comparison functions,
# and even more efficient.  This also still uses quicksort which gives bad
# performance for lists with large numbers of items already in ascending or
# descending order.
\g_sort=
	(\lt\eq\gt \opt_unique\xs
	opt_unique (map (\row shift row \x\_ x)) append_all;
	group_items_by_cmp lt eq gt xs
	)

# Sort the list of {key val} pairs xs.  Use the combine function to combine
# values with the same key.
\combine_keys=
	(\combine\xs

	# Merge two segments together.  A segment is a list of groups.
	\merge_segments=
		(@\loop\xs\ys
		xs ys \x\xt
		ys xs \y\yt

		x \kx\vx
		y \ky\vy

		lt kx ky (\tail=(loop xt ys) cons x tail);
		gt kx ky (\tail=(loop xs yt) cons y tail);

		\vx=(combine vx vy)
		\tail=(loop xt yt)
		cons {kx vx} tail
		)

	# Merge each adjoining pair of segments in a list of segments.
	\merge_adjoining_segments=
		(@\loop\xs
		xs [] \x\ys
		ys xs \y\zs
		\z=(merge_segments x y)
		\zs=(loop zs)
		cons z zs
		)

	# Merge all the segments in a list into a single segment.
	\merge_all_segments=
		(@\loop\xs
		xs [] \x\ys
		ys x \_\_
		\xs=(merge_adjoining_segments xs)
		loop xs
		)

	\segments=(map (\x [x]) xs)
	merge_all_segments segments
	)

# Group a list of items xs into a list of groups.  Use extract to get the key
# from an item for comparison purposes.  Each group is {key list}, where list
# is the list of all items with that common key, in the same order as they
# appear in the original list (i.e. the grouping is stable).  The groups are
# listed in ascending order of key.
\group_items=
	(\extract\xs
	\xs=(map (\x \k=(extract x) {k [x]}) xs)
	combine_keys append xs
	)

# Sort a list of items with a key extraction function.  If opt_unique is true,
# only keep the first item with a given key.  Otherwise keep all duplicates.
\sort_items=
	(
	\get_values=(map (\p p \_\v v))
	\extract\opt_unique\xs
	opt_unique
		(
		\xs=(map (\x \k=(extract x) {k x}) xs)
		\xs=(combine_keys (\x\_ x) xs) # Keep the first.
		get_values xs
		)
		(
		\xs=(group_items extract xs)
		append_all; get_values xs
		)
	)

# The sort and unique functions operate on lists whose elements are all either
# strings or numbers.
\sort=(sort_items I F)
\unique=(sort_items I T)

# Using function f and starting value z, run the function forward for each
# element in the list.
\fold=
	(\f @\loop \z\xs
	xs z \x\xs
	\z=(f z x)
	loop z xs
	)

# Return the first n items of a list.
\first=
	(@\loop\n\xs
	\n=n
	le n 0 [];
	xs [] \x\xs
	[x;loop (- n 1) xs]
	)

# (skip n xs) Skip the first n items in list xs.
\skip=
	(@\loop\n\xs
	\n=n
	le n 0 xs;
	xs [] \x\xs
	loop (- n 1) xs
	)

\list_sum=(fold + 0)
\list_length=(fold (\n\_ + 1 n) 0)
\is_null=(\xs xs T \_\_ F)

# Produce the list of values in the range x through y.
\range=
	(\x\y
	\x=(round x)
	\y=(round y)
	\d=(le x y 1 -1)
	(@\loop\x
	cons x;
	eq x y [];
	\x=(+ x d)
	loop x
	) x
	)

# (list_at xs n) is the item at position n in list xs, counting from 0.
\list_at=
	(@\loop\xs\n
	xs void \x\xs
	\n=n
	lt n 0 void;
	eq n 0 x;
	loop xs (- n 1)
	)

# Combine the elements of two lists pairwise.
\list_combine=
	(\f @\loop\xs\ys
	xs ys \x\xt
	ys xs \y\yt
	\z=(f x y)
	cons z (loop xt yt)
	)

# Get the nth column of a table.
\column=(\n\xs map (\row list_at row n) xs)

# Given a list of rows, return a function which maps the key at key_pos to the
# value at val_pos.
\match_column=
	(\key_pos\val_pos @\loop \rows
	rows void \row\rows

	\key=(list_at row key_pos)
	\val=(list_at row val_pos)

	with key val;
	loop rows
	)

# (stream_values fn) is the infinite list of values of function fn.  This is
# useful for generating streams of random values.
\stream_values=
	(\fn @\loop
	\x=(once fn)
	\xs=(once loop)
	[x;xs]
	)

# Gather input items into a list.
\get_list=
	(\get @\loop
	\x=get
	is_void x [];
	\xs=(once loop)
	[x;xs]
	)

# Flatten a piece of data (string, number, boolean, or list) into a string.
\to_str=
	(\x
	\buf=buf_new
	\put=(buf_put buf)
	(@\loop\x
	\x=x
	is_str x (put x);
	is_num x (put (num_str x));
	is_bool x (put (x "T" "F"));
	is_list x
		(
		x () \x\xs
		loop x
		loop xs
		);
	) x
	buf_get buf
	)

# Gather input strings into a string.
\get_str=
	(\get
	\buf=buf_new
	(@\loop
	\x=get
	is_void x ();
	buf_put buf x
	loop
	)
	buf_get buf
	)

# Gather a list of strings into a string.
\list_str=
	(\xs
	\buf=buf_new
	(@\loop\xs
	xs () \x\xs
	buf_put buf x
	loop xs
	)
	xs
	buf_get buf
	)

# Convert a string to a list with a given function.
\get_str_list=
	(\get\str
	\in=(readstr str)
	get_list (get in)
	)

# Return the list of individual bytes in a string.
\str_bytes=(get_str_list sgetc)

# Return the list of UTF-8 characters in a string.
\str_chars=(get_str_list sget)

# Apply a function to each logical character of a string.
\str_map=(\f\str list_str; map f; str_chars str)

# Insert separators between elements of a list.
\join=
	(\sep\xs
	to_str;
	(
	@\loop\slash\xs
	xs [] \x\xs
	slash (cons sep) ();
	cons x;
	loop T xs
	) F xs
	)

\join_path=(join "/")

\split=
	(\sep\str
	\len_sep=(length sep)
	eq len_sep 0 [str];

	(@\loop\offset
	\pos=(search str sep offset)
	is_void pos
		(
		\len_str=(length str)
		\top=(slice str offset (- len_str offset))
		[top]
		);

	\top=(slice str offset (- pos offset))
	cons top;
	\pos=(+ pos len_sep)
	loop pos
	) 0
	)

# Return the (lazy) list of bytes read from the file handle.
\file_bytes=
	(\fh @\loop
	\ch=(fgetc fh)
	is_void ch [];
	\tail=(once loop)
	cons ch tail
	)

# Return the entire string contained within a file.
\file_content=
	(\fh
	\buf=buf_new
	(@\loop
	\text=(fread fh 8192)
	eq text "" ();
	buf_put buf text
	loop
	)
	buf_get buf
	)

define "append" append;
define "each" each;
define "map" map;
define "map_good" map_good;
define "filter" filter;
define "reverse" reverse;
define "append_all" append_all;
define "shift" shift;
define "g_sort" g_sort;
define "combine_keys" combine_keys;
define "group_items" group_items;
define "sort_items" sort_items;
define "sort" sort;
define "unique" unique;
define "fold" fold;
define "first" first;
define "skip" skip;
define "list_sum" list_sum;
define "list_length" list_length;
define "is_null" is_null;
define "range" range;
define "list_at" list_at;
define "list_combine" list_combine;
define "column" column;
define "match_column" match_column;
define "stream_values" stream_values;
define "get_list" get_list;
define "to_str" to_str;
define "get_str" get_str;
define "list_str" list_str;
define "str_bytes" str_bytes;
define "str_chars" str_chars;
define "str_map" str_map;
define "join" join;
define "join_path" join_path;
define "split" split;
define "file_bytes" file_bytes;
define "file_content" file_content;
standard
