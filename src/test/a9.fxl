#
use "test/common.fxl" \;

(
\test_1=
(
say "== test_1" # says PING 1 time
\ping=(once; say "PING")
I
ping
ping
ping
)

\test_2=
(
say "== test_2" # says PING 5 times
\ping=(say "PING")
\talk=(ping (once ping))
\talk=(talk talk)
\talk=(talk talk)
talk
)

\test_3=
(
say "== test_3" # says PING 3 times
\ping=(say "PING")
\talk=(\x==ping x)
talk talk talk
)

\test_4=
(
say "== test_4" # says PING pong PING PING PING
\ping=(say "PING")
\talk=(ping (once (say "pong")))
\talk=(talk talk)
\talk=(talk talk)
talk
)

\test_5=
(
say "== test_5"
\try=
	(\talk
	div
	\talk=(talk talk)
	\talk=(talk talk)
	talk
	)

# Says PING 4 times with a pong only after the first one.
try (say "PING"; once; say "pong")

# Says PING 4 times with a pong after each one.  The missing semicolon means
# that we evaluate (say "PING" once) = (I once) = once, however because of the
# side effect it is not replaced inline, which nullifies the effect of the
# once.
try (say "PING" once; say "pong")
)

\test_6=
(
say "== test_6" # says PING twice.
# Here I apply once to a value with no side effects, which has no purpose other
# than test coverage.
\ping=(say (once "PING"))
\talk=(ping ping)
talk
)

\test_7=
(
# This verifies that I, T, and F still use the technique of reducing to type_J
# instead of direct replacement.
say "== test_7"
(
say "type_I"
\I=I
\ping=(once; say "PING")
I ping ping ping
)

(
say "type_T"
\I=(\x T x ())
\ping=(once; say "PING")
I ping ping ping
)

(
say "type_F"
\I=(\x F () x)
\ping=(once; say "PING")
I ping ping ping
)
(
say "type_subst"
\I=(\x x)
\ping=(once; say "PING")
I ping ping ping
)
)

test_1
test_2
test_3
test_4
test_5
test_6
test_7
)
