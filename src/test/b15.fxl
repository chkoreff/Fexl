# INDEX CONCEPT
#
# An index is a highly efficient structure for mapping string keys to arbitrary
# values.  It uses the longest common prefix of keys to narrow the search
# quickly and eliminate repeated initial key material.
#
# INDEX REPRESENTATION
#
# An index is either [] or [{key val child}; tail].
#
# The key is a string.
# The val, which may be void, is the arbitrary value associated with the key.
# The child is the index of entries that start with key.
# The tail is the index of entries greater than key.
# The keys in an index share no common prefix.

# (index_get key index)
# Return the value associated with key, or void if none.
\index_get=
	(@\loop\new_key\index
	index void \top\tail
	top \old_key\old_val\child

	eq new_key old_key old_val; # new_key and old_key are identical.

	\len_common=(length_common new_key old_key)
	eq 0 len_common
		(
		# new_key and old_key have no prefix in common.
		lt new_key old_key void;
		loop new_key tail
		);

	\len_new_suffix=(- (length new_key) len_common)
	eq 0 len_new_suffix void; # new_key is a proper prefix of old_key
	ne (length old_key) len_common void;

	# old_key is a proper prefix of new_key.
	\new_suffix=(slice new_key len_common len_new_suffix)
	loop new_suffix child
	)

# (index_put key val index)
# Return a new index with key mapped to val.
\index_put=
	(@\loop\new_key\new_val\index

	index [{new_key new_val []}]
	\top\tail
	top \old_key\old_val\child

	eq new_key old_key
		(
		# new_key and old_key are identical.
		[{old_key new_val child}; tail]
		);

	\len_common=(length_common new_key old_key)
	eq 0 len_common
		(
		# new_key and old_key have no prefix in common.
		lt new_key old_key [{new_key new_val []} top; tail];
		\tail=(loop new_key new_val tail)
		[top;tail]
		);

	\len_new_suffix=(- (length new_key) len_common)
	\len_old_suffix=(- (length old_key) len_common)

	eq 0 len_new_suffix
		(
		# new_key is a proper prefix of old_key
		\old_suffix=(slice old_key len_common len_old_suffix)
		[{new_key new_val [{old_suffix old_val child}]}; tail]
		);

	\prefix=(slice new_key 0 len_common)
	\new_suffix=(slice new_key len_common len_new_suffix)

	eq 0 len_old_suffix
		(
		# old_key is a proper prefix of new_key.
		\new_child=(loop new_suffix new_val child)
		[{prefix old_val new_child}; tail]
		)
		(
		# new_key and old_key share a common proper prefix.
		\old_suffix=(slice old_key len_common len_old_suffix)
		\new_child=(loop new_suffix new_val [{old_suffix old_val child}])
		[{prefix void new_child}; tail]
		)
	)

# (index_del key index)
# Return a new index with key deleted.
\index_del=
	(@\loop\new_key\index
	index [] \top\tail
	top \old_key\old_val\child

	eq new_key old_key
		(
		# new_key and old_key are identical.
		is_null child tail;
		[{old_key void child}; tail]
		)

	\len_common=(length_common new_key old_key)
	eq 0 len_common
		(
		# new_key and old_key have no prefix in common.
		lt new_key old_key [top;tail];
		\tail=(loop new_key tail)
		[top;tail]
		);

	\len_new_suffix=(- (length new_key) len_common)
	eq 0 len_new_suffix [top;tail]; # new_key is a proper prefix of old_key
	ne (length old_key) len_common [top;tail];

	# old_key is a proper prefix of new_key.
	\new_suffix=(slice new_key len_common len_new_suffix)
	\new_child=(loop new_suffix child)

	\prefix=(slice new_key 0 len_common)
	is_null new_child
		(
		is_defined old_val
			[{prefix old_val []}; tail]
			tail
		)
		[{prefix old_val new_child}; tail]
	)

# (index_put_pairs pairs index)
# Put all the {key val} pairs into the index.
\index_put_pairs=
	(@\loop\pairs\index
	pairs index \pair\pairs
	pair \key\val
	\index=(index_put key val index)
	loop pairs index
	)

# (index_pairs index)
# Return the list of {key val} pairs defined in the index.
\index_pairs=
	(
	(@\loop\prefix\index
	index [] \top\tail
	top \key\val\child
	\key=(. prefix key)
	\pairs==(append (loop key child) (loop prefix tail))
	is_defined val [{key val};pairs] pairs
	)
	""
	)

# Test index_get.
\validate_pairs==
	(\pairs\index
	each pairs
		(\pair
		pair \key\val
		\val2=(index_get key index)
		eq val val2 ();
		say ["BAD "(as_str key)" "(as_str val)" "(as_str val2)]
		)
	)

\test_1==
	(
	say "= test_1"

	\index=
	(
	index_put "bcqr" "1889";
	index_put "bcccda" "1618";
	index_put "bccc" "5233";
	index_put "bc" void;
	index_put "bc" "9381";
	index_put "bcda" "0724";
	index_put "bccc" "6247";
	index_put "bcccxyzb" "2173";
	index_put "bcccxyza" "4610";
	index_put "" "9972";
	index_put "bcccxyzabc" "3291";
	index_put "bcccxyza" "3291";
	index_put "bcccxyz" "3364";
	index_put "" "3972";
	index_put "d" "1974";
	index_put "a" "6870";
	index_put "bcccxyz" "4954";
	[]
	)

	(
	say "index:"
	say_data index

	say "pairs:"
	\pairs=(index_pairs index)
	say_data pairs

	validate_pairs pairs index

	# Try some keys not in the index.
	\try==
		(\key
		\val=(index_get key index)
		is_undef val ();
		say ["BAD "(as_str key)]
		)
	try "bx"
	try "bcc"
	try "bca"
	try "bcccz"
	)

	(
	# Test delete.
	say "delete:"
	say_data
	(
	index_del "d";
	index_del "abcdefg";
	index_del "";
	index_del "a";
	index_del "abcdefh";
	index_del "bcccda";
	index_del "bcqr";
	index_del "bcccxyzzzz";
	index_del "bcccxyzabc";
	index_del "bcccxyz";
	index_del "bcda";
	index_del "bcccxyzb";
	index_del "bcccxyza";
	index_del "bcc";
	index_del "bccc";
	index_del "b";
	index_del "bc";
	index_del "c";
	index_del "x";
	index_del "a";
	# Add a couple keys first to make it interesting.
	index_put "abcdefg" "6674";
	index_put "bc" "9941";
	index
	)
	)
	)

# Sort unique pairs, keeping the latest one.
\sort_pairs==(combine_keys (\x\y y))

# Compare lists of string pairs.
\eq_pairs==
	(@\loop\xs\ys
	xs (ys T \_\_ F) \x\xs
	ys F \y\ys

	x \kx\vx
	y \ky\vy

	ne kx ky F;
	ne vx vy F;
	loop xs ys
	)

\test_pairs==
	(\pairs

	say ["length = "(list_length pairs)]
	\index=(index_put_pairs pairs [])

	\list_pairs=(index_pairs index)

	validate_pairs list_pairs index

	\check_pairs=(sort_pairs pairs)
	\ok=(eq_pairs list_pairs check_pairs)
	say (ok "GOOD" "BAD")
	)

\test_pairs_both==
	(\pairs
	test_pairs pairs
	\pairs=(reverse pairs)
	test_pairs pairs
	)

\test_2==
	(
	say "= test_2"
	test_pairs_both
	[
	{"123456" "v1_123456"}
	{"" "5763"}
	{"a" "4999"}
	{"a" "4999"}
	{"abc" "4113"}
	{"mnog" "0053"}
	{"mnof" "1285"}
	{"123456" "v2_123456"}
	{"def" "7249"}
	{"abcd" "2174"}
	{"xyz" "4113"}
	{"mnof" "1286"}
	{"xy" "2113"}
	{"fghj" "3674"}
	{"fghi" "5851"}
	]
	)

\test_3==
	(
	say "= test_3"
	test_pairs_both
	[
	{"abcd" "2174"}
	{"abc" "4113"}
	{"a" "4998"}
	]
	)

\test_4==
	(
	say "= test_4"
	test_pairs_both
	[
	{"123456" "v1_123456"}
	{"" "5763"}
	{"a" "4999"}
	{"a" "4999"}
	{"abc" "4113"}
	{"mnog" "0053"}
	{"mnof" "1285"}
	{"123456" "v2_123456"}
	{"def" "7249"}
	{"abcd" "2174"}
	{"xyz" "4113"}
	{"mnof" "1286"}
	{"xy" "2113"}
	{"fghj" "3674"}
	{"fghi" "5851"}
	]
	)

\test_5==
	(
	say "= test_5"

	\index=
	(
	index_put_pairs
	[
	{"" "3785"}
	{"aaaabc" "9114"}
	{"aaabcc" "2014"}
	{"aaabcd" "7679"}
	{"aaacde" "3161"}
	{"bbabc" "4682"}
	{"bbabd" "1863"}

	{"bbacde" "6455"}
	{"bbacd" "1553"}
	{"bbac" "8261"}

	{"bbacdf" "3986"}
	{"bbacef" "9370"}
	{"e" "1067"}

	{"" "3785"}
	{"aa" "8059"}
	{"aaaabc" "9114"}
	{"aaabcc" "2014"}
	{"aaabcd" "7679"}
	{"aaacde" "3161"}
	{"bbabc" "4682"}
	{"bbabd" "1863"}
	{"bbac" "8259"}
	{"bbacde" "6455"}
	{"bbacd" "1553"}
	{"bbacdf" "3986"}
	{"bbacef" "9369"}
	{"cab" "1546"}
	{"cac" "7869"}
	{"cacd" "1055"}
	{"e" "1067"}

	{"bbac" "8260"}
	{"bbacef" "9370"}
	{"aa" "8060"}
	{"bbac" "8261"}

	{"" "3785"}
	{"aaaabc" "9114"}
	{"aaabcc" "2014"}
	{"aaabcd" "7679"}
	{"aaacde" "3161"}
	{"bbabc" "4682"}
	{"bbabd" "1863"}
	{"bbac" "8261"}
	{"bbacd" "1553"}
	{"bbacde" "6455"}
	{"bbacdf" "3986"}
	{"bbacef" "9370"}
	{"cab" "1546"}
	{"cac" "7869"}
	{"cacd" "1055"}
	{"e" "1067"}

	{"abcdefg" "0825"}
	{"abcdef" "2039"}
	{"abcde" "7596"}
	{"abcd" "2936"}
	{"abc" "7010"}
	{"bba" "1569"}
	]
	[]
	)

	say "before delete:"
	say_data index

	say "pairs:"
	say_data (index_pairs index)
	nl

	\index=(index_del "d" index)
	\index=(index_del "bb" index)

	\index=(index_del "bbx" index)
	\index=(index_del "aaaax" index)

	\index=(index_del "bbacdf" index)
	\index=(index_del "bbacde" index)

	\index=(index_del "bbac" index)

	\index=(index_del "ca" index)
	\index=(index_del "bbacd" index)
	\index=(index_del "abcd" index)
	\index=(index_del "abcdef" index)
	\index=(index_del "abcde" index)
	\index=(index_del "abcdefg" index)
	\index=(index_del "" index)

	\index=(index_del "aaabcc" index)
	\index=(index_del "aaabcd" index)
	\index=(index_del "aa" index)
	\index=(index_del "abc" index)
	\index=(index_del "aaacdx" index)
	\index=(index_del "aaacde" index)

	\index=(index_del "aaaab" index)
	\index=(index_del "aaaabcx" index)
	\index=(index_del "aaaabc" index)

	\index=(index_del "x" index)
	\index=(index_del "e" index)

	\index=(index_del "cab" index)
	\index=(index_del "cacd" index)

	say "after delete:"
	say_data index

	say "pairs:"
	say_data (index_pairs index)
	nl
	)

# Generate a list of {key val} pairs with an iterated seed.
\gen_pairs==
	(\f @\loop\n\seed
	lt n 1 [];
	f seed \key\val\seed
	\n=(- n 1)
	\tail=(loop n seed)
	[{key val}; tail]
	)

\test_hash==
	(
	say "= test_hash"

	\pairs=
		(
		gen_pairs
		(\seed
		\seed=(sha256 seed)
		\q_seed=(unpack seed)
		\key=(slice q_seed 0 16)
		\val=(slice q_seed 16 4)
		{key val seed}
		)
		1000
		"start"
		)

	# Add a few more keys to test override.
	\pairs==
	[
	{"abc" "1027"}
	{"abc" "2866"}

	{"bcccxyz" "4954"}
	{"a" "6870"}
	{"d" "1974"}
	{"" "3972"}

	{"bcccxyz" "3364"}
	{"bcccxyza" "3291"}
	{"bcccxyzabc" "3291"}
	{"" "9972"}
	{"bcccxyza" "4610"}
	{"bcccxyzb" "2173"}

	{"bccc" "6247"}
	{"bcda" "0724"}

	{"bc" "9381"}
	{"bccc" "5233"}
	{"bcccda" "1618"}
	{"bcqr" "1889"}

	;pairs
	]

	#\pairs=(append pairs pairs)

	test_pairs pairs
	)

#trace_elapsed;
show_benchmark;
test_1
test_2
test_3
test_4
test_5
test_hash
