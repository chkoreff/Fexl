#
\NL="
"

# (append xs ys) is the list consisting of list xs followed by list ys.
\append=(@\append\xs\ys xs ys \x\xs [x;append xs ys])

# (filter f xs) is the list of items x in xs for which (f x) is true.
\filter=(@\filter\f\xs xs [] \x\xs f x (cons x) (); filter f xs)

# Sort the list xs with the ordering functions lt and gt.
\sort_with =
	(@\sort_with\lt\gt\xs
	xs [] \x\xs 
	\sort=(sort_with lt gt)
	\lo=(sort; filter (gt x) xs)
	\hi=(sort; filter (lt x) xs)
	append lo; [x; hi]
	)

# Normal sort with the predefined ordering functions.
\sort=(sort_with <= >)

# Insert a separator between the elements of a list.
\join=
	(@\join\sep\xs
	xs [] \x\xs
	xs [x] \_\_ [x sep; join sep xs]
	)

say "==="
say ["source_label = " source_label]
say ["source_line = " source_line]

(
say "==="
\x=42
say ["Hello world." NL "x = " x]
say (+ x 5)
say (- x 5)
say (* x 5)
say (/ x 5)
say (/ x 0)

say "==="
say (< 2 3 "T" "F")
say (= 2 2 "T" "F")
say (> 3 2 "T" "F")
say (>= 3 4 "T" "F")
say (>= 3 3 "T" "F")
say (>= 3 2 "T" "F")
say (= "x" "y" "T" "F")
say (= "x" "x" "T" "F")
say (< "x" "y" "T" "F")
say (< "x" "x" "T" "F")
say (< "y" "x" "T" "F")
say (< "y" "" "T" "F")
say (< "" "" "T" "F")
say (< "" "x" "T" "F")
say (<= "" "x" "T" "F")
say (<= "x" "x" "T" "F")
say (<= "x" "w" "T" "F")
say (!= "x" "x" "T" "F")
say (!= "x" "y" "T" "F")
say (>= "x" "x" "T" "F")
say (>= "x" "y" "T" "F")
say (>= "x" "w" "T" "F")
say (> "x" "x" "T" "F")
say (> "x" "y" "T" "F")
say (> "x" "w" "T" "F")

say "==="
say (+ -9.77 4.8)
say (- 211034.117654902 231.197659)
say (* 1.85 2.63)
say (round; * 1.85 2.63)
say (/ 130.08 2.63)
say (/ (* 2 (+ (- 100000000000.00 0.01) 0.02)) 2)

say (285)

say ["A""a"]

say (. "" "")
say (. "" "a")
say (. "a" "b")
say (. "a" "")
say (. "abcde" "fgh")

say (length "")
say (length "a")
say (length "abc")
say (length (. "ab" "c"))

\who="world"
put "Hello "
put [who"."]
put NL
)

say "==="
# Test deferred evaluation.

\ping== (say "ping!")

\g==
	(
	\f==(ping ping)
	\f==(f f)
	f
	)
g g

say "==="
# Test eager evaluation.
\f=(ping ping ping)


say "==="
\list=(append ["x" "y"] ["z"])
\list=(append list; append list; ["!"])
say list

say "==="
say ~| "Ain't nothin' simple when you're doin' it for real." (Gus Baird)|
nl
say ~@
"My fathers sleep on the sunrise plains,
And each one sleeps alone.
Their trails may dim to the grass and rains,
For I choose to make my own.
I lay proud claim to their blood and name,
But I lean on no dead kin;
My name is mine, for the praise or scorn,
And the world began when I was born
And the world is mine to win. ..."

  (Badger Clark, "The Westerner")
@

say "==="
# Multiple layers of quotation.
say "hello"
say ~(1) "hello"(1)
say ~(2) ~(1) "hello"(1)(2)
say ~(3) ~(2) ~(1) "hello"(1)(2)(3)

say "==="
(\x\y\z x; y z) ping say "hi"
(\x\y\z x z; y z) put say "zzz"
(\x) die say "q237"
say (\x="y" x)
say ""
say "aa"
put"
"
say "bb"
say ~" a"
say ~" "
say ~"
"

say ~| a|
(\x="!" say ["hi"x])
say ~EOM aEOM

# Tricky string terminators here
say ~ABC abcdABAABC
say [~ABCD AABABCABCD"ABCD"]

say "==="
\x=var_new
var_put x 12.6
say x
\v=(var_get x)
say v
var_put x (+ (var_get x) 5.0)
say ["x = " x]

say "==="
# Test some funky syntax cases.
\ =:= =say

=:= "line 1"
=:= "line 2"

\Talk== (say "Hello world!")
\talk==Talk
\ talk == talk
talk
talk
talk

say "==="
\x="1234567890123456"
# Now make a string with length 16*(2^20) = 16,777,216 bytes.
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
say ["length is " (length x)]

say "==="
# Test the tuple notation.
say ({} ["0"])
say ({"x"} \x ["1" " " x])
say ({"x" "y"} \x\y ["2" " " x " " y])
say ({"x" "y" ["z""z"]} \x\y\z ["3" " " x " " y " " z])

say "==="
# Test sorting.
\show=(\list say (join " " list))
\list=["bread" "toothpaste" "bananas" "apples" "bananas"]
show list
show (sort list) # normal
nl
show (sort_with <= > list) # forward (same as normal)
show (sort_with > <= list) # reverse
show (sort_with < > list) # forward unique
show (sort_with > < list) # reverse unique

say "==="
# Test str_num directly.
say (str_num "42")
say (str_num "42x") # invalid returns []
say (str_num "-7.8")
say (str_num "")
say (str_num "0")
say (str_num "-0")

\\
Extra stuff not parsed.
