# Big number calculations
# LATER 20210808 Implement in C with base 2^32.

# The maximum safe value for base_digits is 7.  Anything greater can yield
# incorrect results due to overflow in multiplication.
\base_digits=7

\base=(^ 10 base_digits)

\nat_eq0=is_null

# Return (B*x) for nat x in any base B.
\nat_shift=(\x x [] \x0\xt [0;[x0;xt]])

# Return (x0 + B*xt) for digit x0 and nat xt in any base B.
\nat_new=
	(\x0\xt
	eq 0 x0 (xt [] \_\_ [x0;xt]) [x0;xt]
	)

# Return (B^n * x) for nat x in any base B.
\nat_scale=
	(@\loop\n\x
	le n 0 x;
	\n=(- n 1)
	loop n [0;x]
	)

# Compare x and y, returning the sign s such that:
# (s =  0 and x = y) or
# (s =  1 and x > y) or
# (s = -1 and x < y)
\nat_cmp=
	(@\loop\x\y
	x (y 0 \_\_ -1) \x0\xt
	y 1 \y0\yt
	\s=(loop xt yt)
	ne 0 s s;
	eq x0 y0 0;
	lt x0 y0 -1;
	1
	)

\make_cmp=(\f\x\y f (nat_cmp x y) 0)

\nat_lt=(make_cmp lt)
\nat_le=(make_cmp le)
\nat_eq=(make_cmp eq)
\nat_ne=(make_cmp ne)
\nat_gt=(make_cmp gt)
\nat_ge=(make_cmp ge)

# Get the top digit x0 and length xn.
\nat_msd=
	(@\loop\x
	x {0 0} \d0\xt
	xt {d0 1} \d1\xtt
	xtt {d1 2} \_\_
	loop xt \x0\xn
	\xn=(+ 1 xn)
	{x0 xn}
	)

# Get the top two digits x0 and x1 and length xn.
# nat_msd2
\nat_msd2=
	(@\loop\x
	x {0 0 0} \d0\xt
	xt {d0 0 1} \d1\xtt
	xtt {d1 d0 2} \_\_
	loop xt \x0\x1\xn
	\xn=(+ 1 xn)
	{x0 x1 xn}
	)

# Convert a number to a string of decimal digits.
\nat_str=
	(
	\pad0=(\s . (repeat_str "0"; - base_digits (length s)) s)
	@\nat_str\x
	x "0" \x0\xt
	nat_eq0 xt
		(num_str x0)
		(.  (nat_str xt) (pad0; num_str x0))
	)

# Convert a string of decimal digits to a number.
\str_nat=
	(@\str_nat\x
	\x=x
	\len=(length x)
	le len base_digits
		(
		\x0=(str_num x)
		is_undef x0 void;
		nat_new x0 []
		)
		(
		\pos=(- len base_digits)
		\x0=(str_num; slice x pos base_digits)
		is_undef x0 void;

		\xp=(slice x 0 pos)
		\xt=(str_nat xp)
		is_undef xt void;
		nat_new x0 xt
		)
	)

# Return x+y.
\nat_add=
	(@\nat_add\x\y
	x y \x0\xt
	y [x0;xt] \y0\yt

	\zt=(nat_add xt yt)
	\z0=(+ x0 y0)

	lt z0 base
		[z0;zt]
		(
		\z0=(- z0 base)
		\zt=(nat_add [1] zt)
		[z0;zt]
		)
	)

# Return x*y.
\nat_mul=
	(@\nat_mul\x\y
	x [] \x0\xt
	y [] \y0\yt

	\zt=
		(
		nat_add (nat_shift; nat_mul xt yt);
		nat_add
			(nat_mul yt [x0])
			(nat_mul xt [y0])
		)
	\z0=(* x0 y0)

	lt z0 base
		[z0;zt]
		(
		\carry=(trunc; / z0 base)
		\z0=(- z0; * base carry)
		\zt=(nat_add [carry] zt)
		[z0;zt]
		)
	)

# Compute z = x-y.  This only works if x >= y.  If x < y, it subtracts as far
# as it can go but the result is generally useless.
\nat_sub_clip=
	(@\loop\x\y
	x [] \x0\xt
	y [x0;xt] \y0\yt

	\z0=(- x0 y0)
	gt z0 0
		(
		\zt=(loop xt yt)
		[z0;zt]
		);
	lt z0 0
		(
		\z0=(+ base z0)
		\zt=(loop xt (nat_add [1] yt))
		[z0;zt]
		)
		(
		\zt=(loop xt yt)
		zt [] \_\_ [z0;zt]
		)
	)

# Compute x-y and return {sign d} where:
#   (sign = F and d = x-y) or
#   (sign = T and d = y-x)
\nat_sub=
	(\x\y
	\sign=(nat_lt x y)
	\d=
		(
		sign
			(nat_sub_clip y x)
			(nat_sub_clip x y)
		)
	{sign d}
	)

# Return q + qd*(base^qn)
# Equals (nat_add q (nat_scale qn [qd]))
\nat_add_scale=
	(@\loop\qd\q\qn
	eq qn 0 (nat_add q [qd]);
	q (nat_scale qn [qd]) \q0\qt
	\qn=(- qn 1)
	\zt=(loop qd qt qn)
	zt void \_\_ [q0;zt]
	)

# Return x - y * qd*(base^qn)
# Equals (nat_sub_clip x (nat_scale qn (nat_mul y [qd])))
\nat_sub_scale=
	(@\loop\y\qd\qn\x
	eq 0 qn (nat_sub_clip x (nat_mul y [qd]));
	x void \x0\xt
	\qn=(- qn 1)
	\zt=(loop y qd qn xt)
	eq 0 x0 (zt [] \_\_ [x0;zt]) [x0;zt]
	)

# Divide x by y, returning quotient q and remainder r such that:
#   x = q*y + r  and  (y=0 or 0 <= r < y)
#
# On each round I calculate a guess with digits {qd qn} such that:
#   (qd = 0 and x < y) or
#   (qd > 0 and x >= (y * qd * base^qn))
\nat_div=
	(\x\y
	nat_msd y \y0\yn
	eq 0 yn {[] x};

	(@\loop\q\x
	\next==
		(\qd\qn
		\q=(nat_add_scale qd q qn)
		\r=(nat_sub_scale y qd qn x)
		loop q r
		)

	nat_msd2 x \x0\x1\xn
	lt xn yn {q x};

	\yd=(eq yn 1 y0 (+ 1 y0))
	ge x0 yd
		(
		\qd=(trunc; / x0 yd)
		\qn=(- xn yn)
		next qd qn
		);
	eq xn yn
		(
		nat_lt x y {q x};
		next 1 0
		)
		(
		\qd=(trunc; / (+ x1 (* x0 base)) yd)
		\qn=(- xn (+ 1 yn))
		next qd qn
		)
	)
	[] x
	)

\nat_mod=(\x\n nat_div x n \q\r r)

# Greatest common denominator
\nat_gcd=
	(@\nat_gcd\a\b
	\a=a
	\b=b
	nat_eq0 a b;
	nat_eq0 b a;
	nat_lt a b
		(nat_gcd a (nat_mod b a))
		(nat_gcd b (nat_mod a b))
	)

\form
def "nat_eq0" nat_eq0;
def "nat_cmp" nat_cmp;
def "nat_lt" nat_lt;
def "nat_le" nat_le;
def "nat_eq" nat_eq;
def "nat_ne" nat_ne;
def "nat_gt" nat_gt;
def "nat_ge" nat_ge;
def "nat_str" nat_str;
def "str_nat" str_nat;
def "nat_add" nat_add;
def "nat_mul" nat_mul;
def "nat_sub_clip" nat_sub_clip;
def "nat_sub" nat_sub;
def "nat_div" nat_div;
def "nat_mod" nat_mod;
def "nat_gcd" nat_gcd;
form
