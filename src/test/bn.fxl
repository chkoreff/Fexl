# Big number calculations

# The maximum safe value for base_digits is 7.  Anything greater can yield
# incorrect results due to overflow in multiplication.
\base_digits=7

\base=(^ 10 base_digits)

# LATER 20210808 Perhaps implement in C with base 2^32.

# Return (x0 + base*xt), where x0 is a base digit and xt is a bn.
\nat_new=
	(\x0\xt
	eq x0 0 (xt [] \_\_ [x0;xt]) [x0;xt]
	)

\nat_eq0=is_null

# Convert a number to a string of decimal digits.
\nat_str=
	(
	\pad0=(\s . (repeat_str "0"; - base_digits (length s)) s)
	@\nat_str\x
	x "0" \x0\xt
	nat_eq0 xt
		(num_str x0)
		(.  (nat_str xt) (pad0; num_str x0))
	)

# Convert a string of decimal digits to a number.
\str_nat=
	(@\str_nat\x
	\x=x
	\len=(length x)
	le len base_digits
		(
		\x0=(str_num x)
		is_undef x0 void;
		nat_new x0 []
		)
		(
		\pos=(- len base_digits)
		\x0=(str_num; slice x pos base_digits)
		is_undef x0 void;

		\xp=(slice x 0 pos)
		\xt=(str_nat xp)
		is_undef xt void;
		nat_new x0 xt
		)
	)

# Compare x and y, returning the sign s such that:
#
# (s =  0 and x = y) or
# (s =  1 and x > y) or
# (s = -1 and x < y)
\nat_cmp=
	(@\loop\x\y
	x (y 0 \_\_ -1) \x0\xt
	y 1 \y0\yt
	\s=(loop xt yt)
	ne 0 s s;
	eq x0 y0 0;
	lt x0 y0 -1;
	1
	)

# Return x+y.
\nat_add=
	(@\nat_add\x\y
	x y \x0\xt
	y [x0;xt] \y0\yt

	\zt=(nat_add xt yt)
	\z0=(+ x0 y0)

	lt z0 base
		[z0;zt]
		(
		\z0=(- z0 base)
		\zt=(nat_add [1] zt)
		[z0;zt]
		)
	)

# Return x*y.
\nat_mul=
	(
	\nat_shift=(\x x [] \x0\xt [0;[x0;xt]])

	@\nat_mul\x\y
	x [] \x0\xt
	y [] \y0\yt

	\zt=
		(
		nat_add (nat_shift; nat_mul xt yt);
		nat_add
			(nat_mul yt [x0])
			(nat_mul xt [y0])
		)
	\z0=(* x0 y0)

	lt z0 base
		[z0;zt]
		(
		\carry=(trunc; / z0 base)
		\z0=(- z0; * base carry)
		\zt=(nat_add [carry] zt)
		[z0;zt]
		)
	)

# Compute z = x-y.  This only works if x >= y.  If x < y, it subtracts as far
# as it can go but the result is generally useless.
\nat_sub_clip=
	(@\loop\x\y
	x [] \x0\xt
	y [x0;xt] \y0\yt

	\z0=(- x0 y0)
	gt z0 0
		(
		\zt=(loop xt yt)
		[z0;zt]
		);
	lt z0 0
		(
		\z0=(+ base z0)
		\zt=(loop xt (nat_add [1] yt))
		[z0;zt]
		)
		(
		\zt=(loop xt yt)
		zt [] \_\_ [z0;zt]
		)
	)

# Compute x-y and return {sign d} where:
#   (sign = F and d = x-y) or
#   (sign = T and d = y-x)
\nat_sub=
	(\x\y
	\sign=(eq (nat_cmp x y) -1)
	\d=
		(
		sign
			(nat_sub_clip y x)
			(nat_sub_clip x y)
		)
	{sign d}
	)

# Return a guess q such that:
#   (y = 0  and q=0) or
#   (x < y  and q=0) or
#   (x >= y and q>0 and x >= q*y)
\nat_guess=
	(@\loop\x\y
	x [] \x0\xt
	y [] \y0\yt
	yt
		(
		xt
			(
			\q=(trunc; / x0 y0)
			eq q 0 [] [q]
			)
			\x1\xtt
		xtt
			(
			\q=(trunc; / (+ x0; * base x1) y0)
			lt q base [q];
			\q1=(trunc; / q base)
			\q0=(- q; * q1 base)
			[q0 q1]
			)
			\_\_

		\q=(loop xt [y0])
		[0;q]
		)
		\_\_

	eq y0 0 (loop xt yt);

	loop xt (nat_add [1] yt)
		(eq -1 (nat_cmp x y) [] [1])
		cons
	)

# Divide x by y, returning quotient q and remainder r which satisfy:
#   x = q*y + r  and  (y=0 or 0 <= r < y)
\nat_div=
	(\x\y
	(@\loop\q\r
	\g=(nat_guess r y)
	is_null g {q r};
	\q=(nat_add g q)
	\r=(nat_sub_clip r (nat_mul y g))
	loop q r
	)
	[] x
	)

\make_cmp=(\f\x\y f (nat_cmp x y) 0)

\nat_lt=(make_cmp lt)
\nat_le=(make_cmp le)
\nat_eq=(make_cmp eq)
\nat_ne=(make_cmp ne)
\nat_gt=(make_cmp gt)
\nat_ge=(make_cmp ge)

\nat_mod=(\x\n nat_div x n \q\r r)

# Greatest common denominator
\nat_gcd=
	(@\nat_gcd\a\b
	\a=a
	\b=b
	nat_eq0 a b;
	nat_eq0 b a;
	nat_lt a b
		(nat_gcd a (nat_mod b a))
		(nat_gcd b (nat_mod a b))
	)

\form
def "nat_eq0" nat_eq0;
def "nat_str" nat_str;
def "str_nat" str_nat;
def "nat_cmp" nat_cmp;
def "nat_add" nat_add;
def "nat_mul" nat_mul;
def "nat_sub_clip" nat_sub_clip;
def "nat_sub" nat_sub;
def "nat_div" nat_div;
def "nat_lt" nat_lt;
def "nat_le" nat_le;
def "nat_eq" nat_eq;
def "nat_ne" nat_ne;
def "nat_gt" nat_gt;
def "nat_ge" nat_ge;
def "nat_mod" nat_mod;
def "nat_gcd" nat_gcd;
form
