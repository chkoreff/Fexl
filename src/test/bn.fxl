# Big number calculations

# The maximum safe value for base_digits is 7.  Anything greater can yield
# incorrect results due to overflow in multiplication.
\base_digits=7

\base=(^ 10 base_digits)

# LATER 20210808 Perhaps implement in C with base 2^32.

# Return (x0 + base*xt), where x0 is a base digit and xt is a bn.
\nat_new=
	(\x0\xt
	eq 0 x0 (xt [] \_\_ [x0;xt]) [x0;xt]
	)

\nat_eq0=is_null

# Convert a number to a string of decimal digits.
\nat_str=
	(
	\pad0=(\s . (repeat_str "0"; - base_digits (length s)) s)
	@\nat_str\x
	x "0" \x0\xt
	nat_eq0 xt
		(num_str x0)
		(.  (nat_str xt) (pad0; num_str x0))
	)

# Convert a string of decimal digits to a number.
\str_nat=
	(@\str_nat\x
	\x=x
	\len=(length x)
	le len base_digits
		(
		\x0=(str_num x)
		is_undef x0 void;
		nat_new x0 []
		)
		(
		\pos=(- len base_digits)
		\x0=(str_num; slice x pos base_digits)
		is_undef x0 void;

		\xp=(slice x 0 pos)
		\xt=(str_nat xp)
		is_undef xt void;
		nat_new x0 xt
		)
	)

# Compare x and y, returning the sign s such that:
#
# (s =  0 and x = y) or
# (s =  1 and x > y) or
# (s = -1 and x < y)
\nat_cmp=
	(@\loop\x\y
	x (y 0 \_\_ -1) \x0\xt
	y 1 \y0\yt
	\s=(loop xt yt)
	ne 0 s s;
	eq x0 y0 0;
	lt x0 y0 -1;
	1
	)

# Return x+y.
\nat_add=
	(@\nat_add\x\y
	x y \x0\xt
	y [x0;xt] \y0\yt

	\zt=(nat_add xt yt)
	\z0=(+ x0 y0)

	lt z0 base
		[z0;zt]
		(
		\z0=(- z0 base)
		\zt=(nat_add [1] zt)
		[z0;zt]
		)
	)

# Return x*y.
\nat_mul=
	(
	\nat_shift=(\x x [] \x0\xt [0;[x0;xt]])

	@\nat_mul\x\y
	x [] \x0\xt
	y [] \y0\yt

	\zt=
		(
		nat_add (nat_shift; nat_mul xt yt);
		nat_add
			(nat_mul yt [x0])
			(nat_mul xt [y0])
		)
	\z0=(* x0 y0)

	lt z0 base
		[z0;zt]
		(
		\carry=(trunc; / z0 base)
		\z0=(- z0; * base carry)
		\zt=(nat_add [carry] zt)
		[z0;zt]
		)
	)

# Compute z = x-y.  This only works if x >= y.  If x < y, it subtracts as far
# as it can go but the result is generally useless.
\nat_sub_clip=
	(@\loop\x\y
	x [] \x0\xt
	y [x0;xt] \y0\yt

	\z0=(- x0 y0)
	gt z0 0
		(
		\zt=(loop xt yt)
		[z0;zt]
		);
	lt z0 0
		(
		\z0=(+ base z0)
		\zt=(loop xt (nat_add [1] yt))
		[z0;zt]
		)
		(
		\zt=(loop xt yt)
		zt [] \_\_ [z0;zt]
		)
	)

# Compute x-y and return {sign d} where:
#   (sign = F and d = x-y) or
#   (sign = T and d = y-x)
\nat_sub=
	(\x\y
	\sign=(eq (nat_cmp x y) -1)
	\d=
		(
		sign
			(nat_sub_clip y x)
			(nat_sub_clip x y)
		)
	{sign d}
	)

# Return (base^n * x).
\nat_scale=
	(@\loop\n\x
	le n 0 x;
	\n=(- n 1)
	loop n [0;x]
	)

# Return q + (base^pow * top)
# Equals (nat_add q (nat_scale pow top))
\nat_add_scale=
	(@\loop\top\q\pow
	eq pow 0 (nat_add q top);
	q (nat_scale pow top) \q0\qt
	\pow=(- pow 1)
	\zt=(loop top qt pow)
	zt void \_\_ [q0;zt]
	)

# Return r - (base^pow * y * top)
# Equals (nat_sub_clip r (nat_scale pow (nat_mul y top)))
\nat_sub_scale=
	(@\loop\y\top\r\pow
	eq 0 pow (nat_sub_clip r (nat_mul y top));
	r void \r0\rt
	\pow=(- pow 1)
	\zt=(loop y top rt pow)
	eq 0 r0 (zt [] \_\_ [r0;zt]) [r0;zt]
	)

\nat_measure=
	(@\loop\x
	x {0 0} \x0\xt
	xt {x0 0} \x1\xtt
	xtt
		(
		\qd=(+ x0; * base x1)
		{qd 0}
		) \_\_
	loop xt \qd\xn
	\xn=(+ 1 xn)
	{qd xn}
	)

# Divide x by y, returning quotient q and remainder r which satisfy:
#   x = q*y + r  and  (y=0 or 0 <= r < y)
\nat_div=
	(\x\y
	nat_measure y \yd\yn
	eq yd 0 {[] x};

	(@\loop\q\x
	nat_measure x \xd\xn
	(
	lt xn yn {0 yd yn};
	eq xn yn
		(
		eq 0 yn {xd yd yn};
		gt xd yd {xd (+ 1 yd) yn};
		eq xd yd
			{(eq -1 (nat_cmp x y) 0 xd) yd yn}
			{0 yd yn}
		)
		(
		le xd yd
			{(* xd base) (eq 0 yn yd (+ 1 yd)) (+ 1 yn)}
			{xd (eq 0 yn yd (+ 1 yd)) yn}
		)
	)
	\xd\yd\yn
	\qd=(trunc; / xd yd)
	eq 0 qd {q x};
	\top=
		(
		lt qd base [qd];
		\q1=(trunc; / qd base)
		\q0=(- qd; * q1 base)
		[q0 q1]
		)
	\pow=(- xn yn)
	\q=(nat_add_scale top q pow)
	\x=(nat_sub_scale y top x pow)
	loop q x
	)
	[] x
	)

\make_cmp=(\f\x\y f (nat_cmp x y) 0)

\nat_lt=(make_cmp lt)
\nat_le=(make_cmp le)
\nat_eq=(make_cmp eq)
\nat_ne=(make_cmp ne)
\nat_gt=(make_cmp gt)
\nat_ge=(make_cmp ge)

\nat_mod=(\x\n nat_div x n \q\r r)

# Greatest common denominator
\nat_gcd=
	(@\nat_gcd\a\b
	\a=a
	\b=b
	nat_eq0 a b;
	nat_eq0 b a;
	nat_lt a b
		(nat_gcd a (nat_mod b a))
		(nat_gcd b (nat_mod a b))
	)

\form
def "nat_eq0" nat_eq0;
def "nat_str" nat_str;
def "str_nat" str_nat;
def "nat_cmp" nat_cmp;
def "nat_add" nat_add;
def "nat_mul" nat_mul;
def "nat_sub_clip" nat_sub_clip;
def "nat_sub" nat_sub;
def "nat_div" nat_div;
def "nat_lt" nat_lt;
def "nat_le" nat_le;
def "nat_eq" nat_eq;
def "nat_ne" nat_ne;
def "nat_gt" nat_gt;
def "nat_ge" nat_ge;
def "nat_mod" nat_mod;
def "nat_gcd" nat_gcd;
form
