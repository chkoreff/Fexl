# Big number calculations

# The maximum safe value for base_digits is 7.  Anything greater can yield
# incorrect results due to overflow in multiplication.
\base_digits=7

\base=(^ 10 base_digits)

# LATER 20210808 Perhaps implement in C with base 2^32.

# Return (x0 + base*xt), where x0 is a base digit and xt is a bn.
\nat_new=
	(\x0\xt
	eq x0 0 (xt [] \_\_ [x0;xt]) [x0;xt]
	)

\nat_eq0=is_null

# Convert a number to a string of decimal digits.
\nat_str=
	(
	\pad0=(\s . (repeat_str "0"; - base_digits (length s)) s)
	@\nat_str\x
	x "0" \x0\xt
	nat_eq0 xt
		(num_str x0)
		(.  (nat_str xt) (pad0; num_str x0))
	)

# Convert a string of decimal digits to a number.
\str_nat=
	(@\str_nat\x
	\x=x
	\len=(length x)
	le len base_digits
		(
		\x0=(str_num x)
		is_undef x0 void;
		nat_new x0 []
		)
		(
		\pos=(- len base_digits)
		\x0=(str_num; slice x pos base_digits)
		is_undef x0 void;

		\xp=(slice x 0 pos)
		\xt=(str_nat xp)
		is_undef xt void;
		nat_new x0 xt
		)
	)

# Return x+y.
\nat_add=
	(@\nat_add\x\y
	x y \x0\xt
	y [x0;xt] \y0\yt

	\zt=(nat_add xt yt)
	\z0=(+ x0 y0)

	lt z0 base
		[z0;zt]
		(
		\z0=(- z0 base)
		\zt=(nat_add [1] zt)
		[z0;zt]
		)
	)

# Return x*y.
\nat_mul=
	(
	\nat_shift=(\x x [] \x0\xt [0;[x0;xt]])

	@\nat_mul\x\y
	x [] \x0\xt
	y [] \y0\yt

	\zt=
		(
		nat_add (nat_shift; nat_mul xt yt);
		nat_add
			(nat_mul yt [x0])
			(nat_mul xt [y0])
		)
	\z0=(* x0 y0)

	lt z0 base
		[z0;zt]
		(
		\carry=(trunc; / z0 base)
		\z0=(- z0; * base carry)
		\zt=(nat_add [carry] zt)
		[z0;zt]
		)
	)

# Compute z = x-y, returning a vector.  This only works if x >= y.  If x < y,
# it subtracts as far as it can go but the result is generally useless.
\nat_sub_clip=
	(@\nat_sub_clip\x\y
	x [] \x0\xt
	y [x0;xt] \y0\yt

	\zt=(nat_sub_clip xt yt)
	\z0=(- x0 y0)

	gt z0 0 [z0;zt];
	eq z0 0 (zt [] \_\_ [z0;zt]);

	\z0=(+ base z0)
	\zt=(nat_sub_clip zt [1])
	[z0;zt]
	)

# Compare x and y, returning the sign s such that:
#
# (s =  0 and x = y) or
# (s =  1 and x > y) or
# (s = -1 and x < y)
\nat_cmp=
	(@\loop\x\y
	x (y 0 \_\_ -1) \x0\xt
	y 1 \y0\yt
	\s=(loop xt yt)
	ne 0 s s;
	eq x0 y0 0;
	lt x0 y0 -1;
	1
	)

# Return the top digit in x.
\nat_msd=
	(@\loop\x
	x 0 \x0\xt
	xt x0 \_\_
	loop xt
	)

# Return the top two digits in x.
\nat_msd2=
	(@\loop\x
	x {0 0} \x0\xt0
	xt0 {x0 0} \x1\xt1
	xt1 {x1 x0} \_\_
	loop xt0
	)

# Return (x * base^n).  Assumes x > 0 so result is in normal form.
\nat_scale=
	(@\loop\x\n
	le n 0 x;
	\n=(- n 1)
	loop [0;x] n
	)

# Return the number of significant digits in x.
\nat_len=
	(@\loop\x
	x 0 \_\xt
	+ 1 (loop xt)
	)

# Divide x by y, returning quotient q and remainder r which satisfy:
#   x = q*y + r and 0 <= r < y
# If y=0, return q=0 and r=0.
\nat_div=
	(\x\y

	\y=y
	\yn=(nat_len y)
	eq yn 0 {[] []}; # y = 0

	\yd=(nat_msd y)

	\x=x
	(@\loop\q\r

	\cmp==(nat_cmp r y)
	eq cmp -1 {q r}; # r < y

	(
	\rn=(nat_len r)
	nat_msd2 r \d1\d2
	gt d1 yd
		(
		\pow=(- rn yn)
		{d1 pow}
		);
	eq rn yn
		(
		\top==(+ 1 yd)
		{top 0}
		)
		(
		\top==(+ d2; * base d1)
		\pow=(- rn (+ 1 yn))
		{top pow}
		)
	)
	\top\pow
	\qd=(trunc; / top (+ 1 yd))
	\q=(nat_add q (nat_scale [qd] pow))
	\r=
		(
		\g==(nat_mul y [qd])
		\g==(nat_scale g pow)
		nat_sub_clip r g
		)
	loop q r
	)
	[] x
	)

\make_cmp=(\f\x\y f (nat_cmp x y) 0)

\nat_lt=(make_cmp lt)
\nat_le=(make_cmp le)
\nat_eq=(make_cmp eq)
\nat_ne=(make_cmp ne)
\nat_gt=(make_cmp gt)
\nat_ge=(make_cmp ge)

\nat_mod=(\x\n nat_div x n \q\r r)

# Greatest common denominator
\nat_gcd=
	(@\nat_gcd\a\b
	\a=a
	\b=b
	nat_eq0 a b;
	nat_eq0 b a;
	nat_lt a b
		(nat_gcd a (nat_mod b a))
		(nat_gcd b (nat_mod a b))
	)

\form
def "nat_eq0" nat_eq0;
def "nat_str" nat_str;
def "str_nat" str_nat;
def "nat_add" nat_add;
def "nat_mul" nat_mul;
def "nat_sub_clip" nat_sub_clip;
def "nat_div" nat_div;
def "nat_cmp" nat_cmp;
def "nat_lt" nat_lt;
def "nat_le" nat_le;
def "nat_eq" nat_eq;
def "nat_ne" nat_ne;
def "nat_gt" nat_gt;
def "nat_ge" nat_ge;
def "nat_mod" nat_mod;
def "nat_gcd" nat_gcd;
form
