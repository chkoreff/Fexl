#
# Append lists xs and ys.
\append=
	(\xs\ys
	(@\loop\xs xs ys \x\xs [x; loop xs])
	xs
	)

# Do f for each item in list xs.
\each=
	(\xs\f
	(@\loop\xs xs () \x\xs f x loop xs)
	xs
	)

# Apply f to each element in list xs.
\map=
	(\f @\loop \xs
	xs [] \x\xs [(f x); loop xs]
	)

# (filter f xs) is the list of items x in xs for which (f x) is true.
\filter=
	(\f @\loop \xs
	xs [] \x\xs f x (cons x) (); loop xs
	)

# Reverse list xs.
\reverse=
	(\xs
	# Push all entries in list xs onto list ys.
	(@\loop\xs\ys xs ys \x\xs loop xs [x;ys])
	xs []
	)

# (unique xs) is the ordered list of unique elements in list xs.
\unique=
	(@\unique\xs
	xs [] \x\xs
	append (unique; filter (gt x) xs); # all the items less than x
	cons x;                            # x itself
	unique; filter (lt x) xs           # all the items greater than x
	)

# (sort xs) is the ordered list of all elements in list xs.
\sort=
	(@\sort\xs
	xs [] \x\xs
	append (sort; filter (gt x) xs);   # all the items less than x
	cons x; append (filter (eq x) xs); # all the items equal to x
	sort; filter (lt x) xs             # all the items greater than x
	)

# Using function f and starting value z, run the function forward for each
# element in the list.
\fold=
	(\f @\loop \z\xs
	xs z \x\xs
	\z==(f z x)
	loop z xs
	)

# Return the first n items of a list.
\first=
	(@\loop\n\xs
	le n 0 [];
	xs [] \x\xs
	[x;loop (- n 1) xs]
	)

\list_sum=(fold + 0)
\list_length=(fold (\n\_ + 1 n) 0)

\and=(\x\y x y F)
\or=(\x\y x T y)

\neg=(- 0)

# Compute x modulo n.
\mod=(\x\n - x; * n; trunc; / x n)

\pi=3.14159265358979
\tau=(* 2 pi)

# (check x y) = x if x is good, otherwise y.
\check=(\x\y is_good x x y)

# Produce the list of values in the range x through y.
\range=
	(\x\y
	\x=(round x)
	\y=(round y)
	\d=(le x y 1 -1)
	(@\loop\x
	cons x;
	eq x y [];
	loop (+ x d)
	) x
	)

# Flatten a piece of data (string, number, or list) into a string.
\to_str=
	(\x
	\buf==buf_new
	\put=(buf_put buf)
	(@\loop\x
	is_str x (put x);
	is_num x (put (num_str x));
	is_list x
		(
		x () \x\xs
		loop x
		loop xs
		);
	) x
	buf_get buf
	)

# (list_at xs n) is the item at position n in list xs, counting from 0.
\list_at=
	(@\loop\xs\n
	xs void \x\xs
	lt n 0 void;
	eq n 0 x;
	loop xs (- n 1)
	)

# Combine the elements of two lists pairwise.
\list_combine=
	(\f @\loop\xs\ys
	xs ys \x\xt
	ys xs \y\yt
	cons (f x y) (loop xt yt)
	)

\column=(\n\xs map (\row list_at row n) xs)

\format_num=
(
# Repeat string x n times
\repeat_str=
	(\x @\loop \n
	le n 0 "";
	. x; loop (- n 1)
	)

# Split string x into groups of three with the given separator.
\split3=
	(\sep @\loop \x
	\len=(length x)
	le len 3 x
	\pos=(- len 3)
	\prefix=(slice x 0 pos)
	\suffix=(slice x pos 3)
	. (loop prefix) (. sep suffix)
	)

# Format number x to n decimal places, with an optional separator for the
# integer part.
\format_num=
	(\n\sep\x
	# Get the list of all digits without the decimal point.
	\factor=(^ 10 n)
	\digits=(num_str; round; * factor (abs x))

	# Pad 0s on the front as needed.
	\pad=(repeat_str "0" (+ 1 (- n (length digits))))
	\digits=(. pad digits)

	# Extract integer and fractional part.
	\pos=(- (length digits) n)
	\xi=(slice digits 0 pos)
	\xf=(slice digits pos n)

	# Insert separator if desired.
	\xi=(eq sep "" xi (split3 sep xi))

	# Put a "." in front of any fractional part.
	\xf=(eq xf "" "" (. "." xf))
	# Determine the sign of result.
	\sign=(lt x 0 "-" "")

	\result=(. sign; . xi xf)
	result
	)
format_num
)

\format_money=(format_num 2 ",")
\format_pct=(\amount . (format_num 4 "," (* 100 amount)) "%")

\shift=(\xs xs {void []} \x\xs {x xs})

\long_month_names=
[
"January"
"February"
"March"
"April"
"May"
"June"
"July"
"August"
"September"
"October"
"November"
"December"
]
\short_month_names=(map (\name slice name 0 3) long_month_names)

\long_month_name=(\n list_at long_month_names (- n 1))
\short_month_name=(\n list_at short_month_names (- n 1))

\date_year=(\date slice date 0 4)
\date_month=(\date slice date 0 6)

\date_ymd =
	(\date
	\year=(date_year date)
	\month=(slice date 4 2)
	\day=(slice date 6 2)
	{year month day}
	)

\date_normal=
	(\date
	date_ymd date \year\month\day
	[month "/" day "/" year]
	)

\date_quarter=
	(\date
	date_ymd date \year\month\day
	\month=(str_num month)
	\quarter=(+ 1; trunc; / (- month 1) 3)
	\quarter=(. year; num_str quarter)
	quarter
	)

\collect_chunks=
	(\len\get_chunk
	\buf==buf_new

	(@\loop\pos
	ge pos len ();
	get_chunk pos \chunk\pos
	buf_put buf chunk
	loop pos
	) 0

	buf_get buf
	)

# Convert a string to a list of individual bytes.
\str_bytes=
	(\str
	(@\loop\pos
	\ch=(slice str pos 1)
	eq ch "" [];
	cons ch; loop (+ pos 1)
	) 0
	)

# Apply a function to each logical character of a string.
\str_map=
	(\f\str
	collect_chunks (length str) \pos
	\n=(char_width str pos)
	\ch=(f; slice str pos n)
	{ ch (+ pos n) }
	)

\quote_ch=
	(\ch
	eq ch "&" "&amp;" ;
	eq ch ~ "~ "&quot;" ;
	eq ch "<" "&lt;" ;
	eq ch ">" "&gt;" ;
	ch
	)

# Quote a string for embedding in HTML.
\quote=(str_map quote_ch)

\month_ym=
	(\month
	\y=(str_num; slice month 0 4)
	\m=(str_num; slice month 4 2)
	{y m}
	)

\two_digits=(\x lt x 10 (. "0") (); num_str x)

\ym_month=
	(\y\m
	. (num_str y) (two_digits m)
	)

\ymd_date=
	(\y\m\d
	. (ym_month y m) (two_digits d)
	)

\month_before=
	(\month
	month_ym month \y\m
	eq m 1 {(- y 1) 12} {y (- m 1)} ym_month
	)

\month_after=
	(\month
	month_ym month \y\m
	eq m 12 {(+ y 1) 1} {y (+ m 1)} ym_month
	)

# Compute the number of days for a given year and month.
# I note that "cal 2 1700" shows 29 days, even though according to these rules
# it should only have 28.
#
# Test cases:
# try 1700 2 28
# try 1900 2 28
# try 2000 2 29
# try 2001 2 28
# try 2004 2 29
# try 2015 2 28
# try 2015 3 31

\ym_num_days=
	(\y\m
	\case=(eq m)
	case 1 31 ;
	case 2
		(
		\case=(\n ne 0 (mod y n))
		case 4 28 ;
		case 100 29 ;
		case 400 28 ;
		29
		);
	case 3 31 ;
	case 4 30 ;
	case 5 31 ;
	case 6 30 ;
	case 7 31 ;
	case 8 31 ;
	case 9 30 ;
	case 10 31 ;
	case 11 30 ;
	case 12 31 ;
	void
	)

# If the day is missing, fill in the last day of the month.
\fill_day=
	(\date
	eq (length date) 6
		(
		\y=(str_num; slice date 0 4)
		\m=(str_num; slice date 4 2)
		\d=(ym_num_days y m)
		ymd_date y m d
		);
	date
	)

\day_after=
	(\date
	date_ymd date \y\m\d
	\y=(str_num y)
	\m=(str_num m)
	\d=(str_num d)

	\max=(ym_num_days y m)

	\d=(+ d 1)

	\ymd=
		(
		le d max { y m d };
		\m=(+ m 1)
		\d=1
		le m 12 { y m d };
		\y=(+ y 1)
		\m=1
		{ y m d }
		)

	ymd ymd_date
	)

\colgroup=
	(\widths
	say "<colgroup>"
	each widths (\width say ["<col width=" width ">"])
	say "</colgroup>"
	)

# Quote a string, enclosing it within terminators to make it suitable for
# reading as a Fexl string.
\fexl_quote=
	(\x
	\QU=~ "~
	\term=
		(
		\check=(\y (is_void (search x y 0)) y)
		check QU;
		(@\loop\count
		\term=(. "~"; num_str count)
		check term;
		loop (+ count 1)
		) 1
		)
	. term; . (eq term QU "" " "); . x; term
	)

# Map number 0-15 to one hex digit (lower-case).
\hex_digit=
	(\n
	lt n 10 (chr (+ 48 n));
	chr (+ 97 (- n 10))
	)

# Map number 0-255 to two hex digits.
\hex_byte=
	(\n
	\hi=(trunc; / n 16)
	\lo=(mod n 16)
	. (hex_digit hi) (hex_digit lo)
	)

# Map digit "0"-"9" or "a"-"f" or "A"-"F" to a decimal number 0-15.
\hex_digit_to_dec=
	(\ch
	\n=(ord ch)
	and (ge n 48) (le n 57) (- n 48);  # 0-9
	and (ge n 97) (le n 102) (- n 87); # a-f
	and (ge n 65) (le n 70) (- n 55);  # A-F
	void
	)

# Map a string specified in hexadecimal into the raw bytes.
\map_hex_to_raw_bytes=
	(\str
	collect_chunks (length str) \pos
	\get_nibble=
		(\pos
		\x=(hex_digit_to_dec; slice str pos 1)
		{ x (+ pos 1) }
		)
	get_nibble pos \x\pos
	get_nibble pos \y\pos
	\byte=(chr; + (* 16 x) y)
	{ byte pos }
	)

# Map raw bytes to their hexadecimal values.
\map_raw_bytes_to_hex=
	(\str
	collect_chunks (length str) \pos
	\ch=(hex_byte; ord; slice str pos 1)
	{ ch (+ pos 1) }
	)

# XOR two hex digit strings together.
\xor_hex=
	(\x\y
	\xl=(map hex_digit_to_dec; str_bytes x)
	\yl=(map hex_digit_to_dec; str_bytes y)
	\zl=(list_combine xor xl yl)
	\zl=(map hex_digit zl)
	to_str zl
	)

## Context operations

# Take a context cx and return a new context where key is defined as val.
\def=
	(\key\val\cx
	\x
	eq x key (later val);
	cx x
	)

# Overlay context cx_new on top of context cx_old.
\chain=
	(\cx_new\cx_old
	\x
	\def==(cx_new x)
	defined def (later def);
	cx_old x
	)

\parse_file=
	(\name\context
	\fh==(fopen name "r")
	is_void fh
		(
		put_to stderr;
		say ["Could not open source file " name]
		die
		);
	get_from fh;
	parse name context
	)

# (extend cx) Takes the context cx and returns an extended context where all of
# cx is defined, but also the special functions "extend", "standard", and "use"
# are redefined to refer to the extended context instead of the original
# context.
\extend=
	(@\extend\cx

	\standard=
		(@\standard
		\extend=(\cx extend; chain cx; standard)

		\use=
			(\file
			\cx=(once; parse_file file standard)
			extend cx
			)

		def "extend" extend;
		def "standard" standard;
		def "use" use;
		cx
		)

	standard
	)

extend;
def "and" and;
def "append" append;
def "chain" chain;
def "check" check;
def "colgroup" colgroup;
def "collect_chunks" collect_chunks;
def "column" column;
def "date_month" date_month;
def "date_normal" date_normal;
def "date_quarter" date_quarter;
def "date_year" date_year;
def "date_ymd" date_ymd;
def "day_after" day_after;
def "def" def;
def "each" each;
def "extend" extend;
def "fexl_quote" fexl_quote;
def "fill_day" fill_day;
def "filter" filter;
def "first" first;
def "fold" fold;
def "format_money" format_money;
def "format_num" format_num;
def "format_pct" format_pct;
def "hex_byte" hex_byte;
def "hex_digit" hex_digit;
def "hex_digit_to_dec" hex_digit_to_dec;
def "list_at" list_at;
def "list_combine" list_combine;
def "list_length" list_length;
def "list_sum" list_sum;
def "long_month_name" long_month_name;
def "map" map;
def "map_hex_to_raw_bytes" map_hex_to_raw_bytes;
def "map_raw_bytes_to_hex" map_raw_bytes_to_hex;
def "mod" mod;
def "month_after" month_after;
def "month_before" month_before;
def "month_ym" month_ym;
def "neg" neg;
def "or" or;
def "parse_file" parse_file;
def "pi" pi;
def "quote" quote;
def "quote_ch" quote_ch;
def "range" range;
def "reverse" reverse;
def "shift" shift;
def "short_month_name" short_month_name;
def "sort" sort;
def "str_bytes" str_bytes;
def "str_map" str_map;
def "tau" tau;
def "to_str" to_str;
def "unique" unique;
def "xor_hex" xor_hex;
def "ym_month" ym_month;
def "ym_num_days" ym_num_days;
def "ymd_date" ymd_date;
standard
