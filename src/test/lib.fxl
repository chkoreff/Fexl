#
# Append lists xs and ys.
\append==(\xs\ys xs ys \x\xs [x; append xs ys])

# Do f for each item in list xs.
\each=
	(\xs\f
	\each==(\xs xs () \x\xs f x each xs)
	each xs
	)

# Apply f to each element in list xs.
\map=
	(\f\xs
	\map==(\xs xs [] \x\xs [(f x); map xs])
	map xs
	)

# (filter f xs) is the list of items x in xs for which (f x) is true.
\filter=
	(\f\xs
	\filter==(\xs xs [] \x\xs f x (cons x) (); filter xs)
	filter xs
	)

# Using function f and starting value z, run the function forward for each
# element in the list.
\fold=
	(\f\z\xs
	\fold==(\z\xs xs z \x\xs \z=(f z x) fold z xs)
	fold z xs
	)

# Return the first n items of a list.
\first==
	(\n\xs
	le n 0 [];
	xs [] \x\xs
	[x;first (- n 1) xs]
	)

\list_sum=(fold + 0)
\list_length=(fold (\n\_ + 1 n) 0)

\neg=(- 0)
\mod=(\x\n - x; * n; trunc; / x n)

\pi=3.14159265358979
\tau=(* 2 pi)

# (check x y) = x if x is good, otherwise y.
\check=(\x\y is_good x x y)

# Produce the list of values in the range x through y.
\range=
	(\x\y
	\x=(round x)
	\y=(round y)
	\d=(le x y 1 -1)
	\loop==
		(\x
		cons x;
		eq x y [];
		loop (+ x d)
		)
	loop x
	)

# Flatten a piece of data (string, number, or list) into a string.
\flatten=
	(\x
	buf_new \buf
	\put=(buf_put buf)
	\flatten==
		(\x
		is_str x (put x);
		is_num x (put (num_str x));
		is_list x
			(
			x () \x\xs
			flatten x
			flatten xs
			);
		)
	flatten x
	buf_get buf I
	)

\format_num=
(
# Repeat string x n times
\repeat_str=
	(\x\n
	\repeat_str==
		(\n
		le n 0 "";
		. x; repeat_str (- n 1)
		)
	repeat_str n
	)

# Split string x into groups of three with the given separator.
\split3=
	(\sep\x
	\split3==
		(\x
		\len=(length x)
		le len 3 x
		\pos=(- len 3)
		\prefix=(slice x 0 pos)
		\suffix=(slice x pos 3)
		. (split3 prefix) (. sep suffix)
		)
	split3 x
	)

# Format number x to n decimal places, with an optional separator for the
# integer part.
\format_num=
	(\n\sep\x
	# Get the list of all digits without the decimal point.
	\factor=(^ 10 n)
	\digits=(num_str; round; * factor (abs x))

	# Pad 0s on the front as needed.
	\pad=(repeat_str "0" (+ 1 (- n (length digits))))
	\digits=(. pad digits)

	# Extract integer and fractional part.
	\pos=(- (length digits) n)
	\xi=(slice digits 0 pos)
	\xf=(slice digits pos n)

	# Insert separator if desired.
	\xi=(eq sep "" xi (split3 sep xi))

	# Put a "." in front of any fractional part.
	\xf=(eq xf "" "" (. "." xf))
	# Determine the sign of result.
	\sign=(lt x 0 "-" "")

	\result=(. sign; . xi xf)
	result
	)
format_num
)

## Context operations

# Take a context cx and return a new context where key is defined as val.
\def=
	(\key\val\cx
	\x
	eq x key {val};
	cx x
	)

# Overlay context cx_new on top of context cx_old.
\chain=
	(\cx_new\cx_old
	\x
	check (cx_new x);
	cx_old x
	)

# (extend cx) Takes the context cx and returns an extended context where all of
# cx is defined, but also the special functions "extend", "standard", and "use"
# are redefined to refer to the extended context instead of the original
# context.
\extend==
	(\cx

	\standard==
		(
		\extend=(\cx extend; chain cx; standard)

		\use=
			(\file
			\cx=(once; parse_file file standard I)
			extend cx
			)

		def "extend" extend;
		def "standard" standard;
		def "use" use;
		cx
		)

	standard
	)

extend;
def "append" append;
def "chain" chain;
def "check" check;
def "def" def;
def "each" each;
def "extend" extend;
def "filter" filter;
def "first" first;
def "flatten" flatten;
def "fold" fold;
def "format_num" format_num;
def "list_length" list_length;
def "list_sum" list_sum;
def "map" map;
def "mod" mod;
def "neg" neg;
def "pi" pi;
def "range" range;
def "tau" tau;
standard
