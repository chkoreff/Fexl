#
# Append lists xs and ys.
\append==(\xs\ys xs ys \x\xs [x; append xs ys])

# Do f for each item in list xs.
\each=
	(\xs\f
	\each==(\xs xs () \x\xs f x each xs)
	each xs
	)

# Apply f to each element in list xs.
\map=
	(\f\xs
	\map==(\xs xs [] \x\xs [(f x); map xs])
	map xs
	)

# (filter f xs) is the list of items x in xs for which (f x) is true.
\filter=
	(\f\xs
	\filter==(\xs xs [] \x\xs f x (cons x) (); filter xs)
	filter xs
	)

# Reverse list xs.
\reverse=
	(\xs
	# Push all entries in list xs onto list ys.
	\push_all==(\xs\ys xs ys \x\xs push_all xs [x;ys])
	push_all xs []
	)

# (unique xs) is the ordered list of unique elements in list xs.
\unique==
	(\xs
	xs [] \x\xs
	append (unique; filter (gt x) xs); # all the items less than x
	cons x;                            # x itself
	unique; filter (lt x) xs           # all the items greater than x
	)

# (sort xs) is the ordered list of all elements in list xs.
\sort==
	(\xs
	xs [] \x\xs
	append (sort; filter (gt x) xs);   # all the items less than x
	cons x; append (filter (eq x) xs); # all the items equal to x
	sort; filter (lt x) xs             # all the items greater than x
	)

# Using function f and starting value z, run the function forward for each
# element in the list.
\fold=
	(\f\z\xs
	\fold==(\z\xs xs z \x\xs \z=(f z x) eval z fold z xs)
	fold z xs
	)

# Return the first n items of a list.
\first==
	(\n\xs
	le n 0 [];
	xs [] \x\xs
	[x;first (- n 1) xs]
	)

\list_sum=(fold + 0)
\list_length=(fold (\n\_ + 1 n) 0)

\and=(\x\y x y F)
\or=(\x\y x T y)

\neg=(- 0)

# Compute x modulo n.
\mod=(\x\n - x; * n; trunc; / x n)

\pi=3.14159265358979
\tau=(* 2 pi)

# (check x y) = x if x is good, otherwise y.
\check=(\x\y is_good x x y)

# Produce the list of values in the range x through y.
\range=
	(\x\y
	\x=(round x)
	\y=(round y)
	\d=(le x y 1 -1)
	\range==
		(\x
		cons x;
		eq x y [];
		range (+ x d)
		)
	range x
	)

# Flatten a piece of data (string, number, or list) into a string.
\to_str=
	(\x
	buf_new \buf
	\put=(buf_put buf)
	\to_str==
		(\x
		is_str x (put x);
		is_num x (put (num_str x));
		is_list x
			(
			x () \x\xs
			to_str x
			to_str xs
			);
		)
	to_str x
	buf_get buf I
	)

\list_at==
	(\xs\n
	xs void \x\xs
	lt n 0 void;
	eq n 0 x;
	list_at xs (- n 1)
	)

\column=(\n\xs map (\row list_at row n) xs)

\format_num=
(
# Repeat string x n times
\repeat_str=
	(\x\n
	\repeat_str==
		(\n
		le n 0 "";
		. x; repeat_str (- n 1)
		)
	repeat_str n
	)

# Split string x into groups of three with the given separator.
\split3=
	(\sep\x
	\split3==
		(\x
		\len=(length x)
		le len 3 x
		\pos=(- len 3)
		\prefix=(slice x 0 pos)
		\suffix=(slice x pos 3)
		. (split3 prefix) (. sep suffix)
		)
	split3 x
	)

# Format number x to n decimal places, with an optional separator for the
# integer part.
\format_num=
	(\n\sep\x
	# Get the list of all digits without the decimal point.
	\factor=(^ 10 n)
	\digits=(num_str; round; * factor (abs x))

	# Pad 0s on the front as needed.
	\pad=(repeat_str "0" (+ 1 (- n (length digits))))
	\digits=(. pad digits)

	# Extract integer and fractional part.
	\pos=(- (length digits) n)
	\xi=(slice digits 0 pos)
	\xf=(slice digits pos n)

	# Insert separator if desired.
	\xi=(eq sep "" xi (split3 sep xi))

	# Put a "." in front of any fractional part.
	\xf=(eq xf "" "" (. "." xf))
	# Determine the sign of result.
	\sign=(lt x 0 "-" "")

	\result=(. sign; . xi xf)
	result
	)
format_num
)

\format_money=(format_num 2 ",")
\format_pct=(\amount . (format_num 4 "," (* 100 amount)) "%")

\shift=(\xs xs {void []} \x\xs {x xs})

\long_month_names=
[
"January"
"February"
"March"
"April"
"May"
"June"
"July"
"August"
"September"
"October"
"November"
"December"
]
\short_month_names=(map (\name slice name 0 3) long_month_names)

\long_month_name=(\n \n=(- n 1) list_at long_month_names n)
\short_month_name=(\n \n=(- n 1) list_at short_month_names n)

\date_year=(\date slice date 0 4)
\date_month=(\date slice date 0 6)

\date_ymd =
	(\date
	\year=(date_year date)
	\month=(slice date 4 2)
	\day=(slice date 6 2)
	{year month day}
	)

\date_normal=
	(\date
	date_ymd date \year\month\day
	[month "/" day "/" year]
	)

\date_quarter=
	(\date
	date_ymd date \year\month\day
	\month=(str_num month)
	\quarter=(+ 1; trunc; / (- month 1) 3)
	\quarter=(. year; num_str quarter)
	quarter
	)

# Apply a function to each logical character of a string.
\str_map=
	(\fn\str
	buf_new \buf
	\loop==
		(\pos
		\n=(char_width str pos)
		is_void n (buf_get buf I);
		\ch=(slice str pos n)
		\ch=(fn ch)
		buf_put buf ch
		loop (+ pos n)
		)
	loop 0
	)

\quote_ch=
	(\ch
	eq ch "&" "&amp;" ;
	eq ch ~ "~ "&quot;" ;
	eq ch "<" "&lt;" ;
	eq ch ">" "&gt;" ;
	ch
	)

# Quote a string for embedding in HTML.
\quote=(str_map quote_ch)

\month_ym=
	(\month
	\y=(str_num; slice month 0 4)
	\m=(str_num; slice month 4 2)
	{y m}
	)

\two_digits=(\x lt x 10 (. "0") (); num_str x)

\ym_month=
	(\y\m
	. (num_str y) (two_digits m)
	)

\ymd_date=
	(\y\m\d
	. (ym_month y m) (two_digits d)
	)

\month_before=
	(\month
	month_ym month \y\m
	eq m 1 {(- y 1) 12} {y (- m 1)} ym_month
	)

\month_after=
	(\month
	month_ym month \y\m
	eq m 12 {(+ y 1) 1} {y (+ m 1)} ym_month
	)

# Compute the number of days for a given year and month.
# I note that "cal 2 1700" shows 29 days, even though according to these rules
# it should only have 28.
#
# Test cases:
# try 1700 2 28
# try 1900 2 28
# try 2000 2 29
# try 2001 2 28
# try 2004 2 29
# try 2015 2 28
# try 2015 3 31

\ym_num_days=
	(\y\m
	\case=(eq m)
	case 1 31 ;
	case 2
		(
		\case=(\n ne 0 (mod y n))
		case 4 28 ;
		case 100 29 ;
		case 400 28 ;
		29
		);
	case 3 31 ;
	case 4 30 ;
	case 5 31 ;
	case 6 30 ;
	case 7 31 ;
	case 8 31 ;
	case 9 30 ;
	case 10 31 ;
	case 11 30 ;
	case 12 31 ;
	void
	)

# If the day is missing, fill in the last day of the month.
\fill_day=
	(\date
	eq (length date) 6
		(
		\y=(str_num; slice date 0 4)
		\m=(str_num; slice date 4 2)
		\d=(ym_num_days y m)
		ymd_date y m d
		);
	date
	)

\day_after=
	(\date
	date_ymd date \y\m\d
	\y=(str_num y)
	\m=(str_num m)
	\d=(str_num d)

	\max=(ym_num_days y m)

	\d=(+ d 1)

	\ymd=
		(
		le d max { y m d };
		\m=(+ m 1)
		\d=1
		le m 12 { y m d };
		\y=(+ y 1)
		\m=1
		{ y m d }
		)

	ymd ymd_date
	)

\colgroup=
	(\widths
	say "<colgroup>"
	each widths (\width say ["<col width=" width ">"])
	say "</colgroup>"
	)

# Quote a string, enclosing it within terminators to make it suitable for
# reading as a Fexl string.
\fexl_quote=
	(\x
	\QU=~ "~
	\term=
		(
		\check=(\y (is_void (search x y 0)) y)
		check QU;
		\loop==
			(\count
			\term=(. "~" (eq count 0 ""; eq count 1 "~"; (num_str count)))
			check term;
			loop (+ count 1)
			)
		loop 0
		)
	. term; . (eq term QU "" " "); . x; term
	)

## Context operations

# Take a context cx and return a new context where key is defined as val.
\def=
	(\key\val\cx
	\x
	eq x key {val};
	cx x
	)

# Overlay context cx_new on top of context cx_old.
\chain=
	(\cx_new\cx_old
	\x
	check (cx_new x);
	cx_old x
	)

# (extend cx) Takes the context cx and returns an extended context where all of
# cx is defined, but also the special functions "extend", "standard", and "use"
# are redefined to refer to the extended context instead of the original
# context.
\extend==
	(\cx

	\standard==
		(
		\extend=(\cx extend; chain cx; standard)

		\use=
			(\file
			\cx=(once; parse_file file standard I)
			extend cx
			)

		def "extend" extend;
		def "standard" standard;
		def "use" use;
		cx
		)

	standard
	)

extend;
def "and" and;
def "append" append;
def "chain" chain;
def "check" check;
def "colgroup" colgroup;
def "column" column;
def "date_month" date_month;
def "date_normal" date_normal;
def "date_quarter" date_quarter;
def "date_year" date_year;
def "date_ymd" date_ymd;
def "day_after" day_after;
def "def" def;
def "each" each;
def "extend" extend;
def "fexl_quote" fexl_quote;
def "fill_day" fill_day;
def "filter" filter;
def "first" first;
def "fold" fold;
def "format_money" format_money;
def "format_num" format_num;
def "format_pct" format_pct;
def "list_at" list_at;
def "list_length" list_length;
def "list_sum" list_sum;
def "long_month_name" long_month_name;
def "map" map;
def "mod" mod;
def "month_after" month_after;
def "month_before" month_before;
def "month_ym" month_ym;
def "neg" neg;
def "or" or;
def "pi" pi;
def "quote" quote;
def "quote_ch" quote_ch;
def "range" range;
def "reverse" reverse;
def "shift" shift;
def "short_month_name" short_month_name;
def "sort" sort;
def "str_map" str_map;
def "tau" tau;
def "to_str" to_str;
def "unique" unique;
def "ym_month" ym_month;
def "ym_num_days" ym_num_days;
def "ymd_date" ymd_date;
standard
