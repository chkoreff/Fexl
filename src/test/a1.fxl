#
\=(use "test/lib.fxl")
\=(use "test/common.fxl")

\show=
	(\x
	\type=(\t put [t " "] say x)
	is_str x (type "str");
	is_num x (type "num");
	is_bool x (type "bool");
	is_void x (say "void");
	say "other"
	)

\parse_string=
	(\text\context
	get_from text;
	parse "" context
	)

\eval_file=(\name parse_file name standard)
\eval_str=(\str parse_string str standard)

(
\ping=(say "ping")
div
ping
div
I ping

div
\talk=(ping)
\talk=(talk talk talk)
\talk=(talk talk)
\talk=(talk talk)
talk

div
# Should say PING six times.
\ping=(say "ping")
# LATER 20151128 This test fails due to the copy-up behavior in type_I.  Until
# I fix that, I work around the problem by calling "once" twice.
#\talk=(ping (once ping))
\talk=(ping (once; once ping))
talk
talk
talk
talk
ping
)

div
show "abc"
show (I "abc")
show ("abc" "de")
show (. "abc" "de")
show (I (I "abc") "de")
show (. (I "abc") "de")
show (. ((\x\y x) "abc") "de")
show (. (I I "abc") (. "" "de"))
show void
show 3.14159265358979
show 42
show (length "12345")
show (length (. (I "abc") (. "" "d")))
show (slice (T (. "abcd" "efghi") I) 2 5)

show (+ -14.87 482.73)
show ((/ ((+ 1) (sqrt 5))) 2)

show (ge (I 5.9) 5.8)
show (lt 5.9 (I 5.8))
show (ge (I "ab") "a")
show (lt (I "ab") (I "a"))
show (eq (I "x") "x")
show (eq (I -7.2) -7.2)
show (lt (I 5.9) (I "ab"))
show (lt (I "ab") (I 5.9))
show (eq (I T) (I T))
div

show (num_str; / (+ 1 (sqrt 5)) 2)
show (str_num; . "+"; . "1." "61803398874989")
show (I I)
show (str_num (I 5.8))
show (str_num (I T))
show (num_str 5.8)
show (num_str "abc")
show (sqrt 9)
show (sqrt "abc")
show (+ "x" (I 3) 4)
show (sqrt "abc" 25)
show (length "abc")
show (length F)
show (str_num "42")
show (str_num "42x")
show (str_num "-7.8")
show (str_num "0")
show (str_num "-0")
show (+ (str_num "1"); str_num; num_str; str_num "42.8")

# Test slice.
(
div
show (slice "" 0 0)
show (slice "" 0 7)
show (slice "" 1 2)
div
show (slice "a" 0 1)
show (slice "a" 1 1)
show (slice "a" 2 1)
div
show (slice "abcd" 0 0)
show (slice "abcd" 0 1)
show (slice "abcd" 0 2)
show (slice "abcd" 0 3)
show (slice "abcd" 0 4)
show (slice "abcd" 0 5)
div
show (slice "abcd" 1 0)
show (slice "abcd" 1 1)
show (slice "abcd" 1 2)
show (slice "abcd" 1 3)
show (slice "abcd" 1 4)
div
show (slice "abcd" 2 0)
show (slice "abcd" 2 1)
show (slice "abcd" 2 2)
show (slice "abcd" 2 3)
div
show (slice "abcd" 3 0)
show (slice "abcd" 3 1)
show (slice "abcd" 3 2)
div
# Negative cases return void.
show (slice "abcd" -2 3)
show (slice "abcd" 2 -3)
show (slice "" -1 2)
show (slice "abc" -1 -2)
)

# Test search.
(
div
\try=(\x\y\offset show (search x y offset))

# These cases agree with the Perl "index" function.  Where Fexl returns void,
# Perl returns -1.
try "abcdefg" "de" 0 # 3
try "abcdefg" "cde" 0 # 2
try "abcdefg" "cdx" 0 # void
try "abcdefg" "cde" 2 # 2
try "abcdefg" "cde" 3 # void
try "abcdefg" "de" 2 # 3
try "abcdefg" "de" 3 # 3
try "abcdefg" "de" 4 # void
try "" "a" 0 # void
try "" "" -1 # void
try "abcdefghijklmnop" "" 0 # 0
try "abcdefghijklmnop" "" 7 # 7
try "abcdefghijklmnop" "" 15 # 15
try "abcdefghijklmnop" "ghI" 0 # void
try "abcdefghijklmnop" "ghi" 0 # 6
try "abcdefghijklmnop" "mnop" 0 # 12
try "abcdefghijklmnop" "mnopq" 0 # void
try "abcdefghijklmnop" "p" 0 # 15
try "abcdefghijklmnop" "q" 0 # void
try "abcdefghijklmnop" "abcdefghijklmnop" 0 # 0
try "abcdefghijklmnop" "abcdefghijklmnop" 1 # void
try "abcdefghijklmnop" "abcdefghijklmnopq" 0 # void
try "a" "ab" 0 # void
try "a" "a" 0 # 0

# These cases diverge from the Perl "index" function.  Fexl returns void, but
# Perl shows a match at position 0.  The difference is because str_search does
# not use -1 to indicate not found, since I use unsigned longs.  Instead, it
# returns a position which points beyond the end of the subject string, and
# when the subject string is empty, any value does that.  I find this
# difference acceptable.
try "" "" 0 # void
try "" "" 8 # void
)

(
say "== test char_width"

# Return the list of UTF-8 chars starting from the given position.
\str_chars=
	(\str @\loop \pos
	ge pos (length str) [];
	\n=(char_width str pos)
	\ch=(slice str pos n)
	[ch; loop (+ pos n)]
	)

\str="hej åabcüdef üä 1≠0 包子x"
\list=(str_chars str 0)

say ["str " str]
each list (\ch say ["ch " ch])
)

(
say "== test buf"
\buf==buf_new
\put=(buf_put buf)
\get=(\x==(buf_get buf) say [": " x])
put "abc"
put "defg"
get
get
put "abc"
put "d"
put ""
put ""
put "e"
get
put "tuvwxyz"
get

say (to_str [["ab" "c "] [[] [] ""] [2.3 " " -3.8] " defg"])
)

div
show (is_str I)
show (is_str 4)
show (is_str "x")
show (is_str; . "x" "y")
show (is_num "x")
show (is_num 4.2)
show (is_num (* 3.9 4.2))
show (is_num; str_num "4.87")
show (is_num; str_num "  4.87")

# The str_num function allows leading white space, but forbids any trailing
# invalid chars, including white space.  This reflects how strtod works.
show (is_num; str_num " 4.87 ")
show (is_num; str_num "4.87x")

show (is_num; str_num "-4.6")
show (is_num; str_num "-4.6x")

# Test some more good and void cases.
div
show void
show (void 3)
show (length 3)
show (length "abc")
show (length 3 "abc")
show (lt 3 4)
show (lt 3 "4")
show (lt 3 "4" "5")
show (+ "x" 4)
show (+ "x" 4 5)
show (sqrt 16)
show (sqrt "x")
show (sqrt "x" 16)
show 3
show (3 "x")
show (num_str 42)
show (num_str "abc")
show (num_str "abc" 42)
show (is_void void)
show "abc"
show ("abc" "x")
show (. "abc" "de")
show (. 3 "de")
show (. 3 "de" "fg")
show (length "abc")
show (length 27)
show (length 27 "abc")
show (slice "abcdefg" 3 2)
show (slice "abcdefg" 3 5)
show (slice "abcdefg" -3 5)
show (slice "abcdefg" "3" 5)
show (str_num "42")
show (str_num "42x")
show (str_num 42)

div
# Test some tricky string terminators.
say ~ABC abcd~ABA~ABC
say ~ABCD AAB~ABC~ABCD

# Multiple layers of quotation.
say "hello"
say ~(1) "hello"~(1)
say ~(2) ~(1) "hello"~(1)~(2)
say ~(3) ~(2) ~(1) "hello"~(1)~(2)~(3)

say ~ "Ain't nothin' simple when you're doin' it for real." (Gus Baird)~
nl
say ~
"My fathers sleep on the sunrise plains,
And each one sleeps alone.
Their trails may dim to the grass and rains,
For I choose to make my own.
I lay proud claim to their blood and name,
But I lean on no dead kin;
My name is mine, for the praise or scorn,
And the world began when I was born
And the world is mine to win. ..."

  (Badger Clark, "The Westerner")
~

# Test single evaluation.
(
div
\show_x=
	(
	once (say "(CALC)")
	\x=(* 5 6)
	say ["x = " x]
	)

say "["
show_x
show_x
show_x
show_x
say "]"

(
\hi=(once; say "Hi")

# Calling the I function here used to break this test, printing "Hi" three
# times instead of once.  That's fixed now.
I
# LATER 20151128 I've changed type_once so that (once x) no longer reduces x in
# place, but instead reduces the entire (once x) form in place.  This exposes
# an issue with how type_I copies up its argument, and I need to find a way to
# avoid that.  Consequently the semicolon on the next line is necessary to
# preserve the desired behavior here.
;

hi
hi
hi
)

(
# This used to cause a segfault when the once function attempted to replace
# the nl with I, because the replace function was only designed to replace a
# non-atomic value.  This is fixed now.
\f=(once nl)
f
f
)

(
\x=(once (put "(CALC)") (+ 2 (* 7 6)))

\make_square=
	(\x
	later;
	once (put ["square " x "="])
	* x x
	)

div

say (* x x)
say (+ x x)
\s4==(make_square 4)
\s7==(make_square 7)

say s4
say s7
say s4
say s7
)
)

div
eval_file "test/hello.fxl"
div
eval_file "test/utf8.fxl"
div
eval_file "test/beer.fxl"
div
eval_file "test/hailstone.fxl"

div
eval_str ~END
\x=(+ 33 48)
say ["x = " x]
~END

div

# This demonstrates that (\x f x) is not strictly equivalent to f, when side
# effects are taken into account.
\say_x=(\x put "x = " say x)
say_x 3
say_x 4
say_x 5

(
# Here I extend the standard context to include the "show" routine so the test
# code below the "use" can run.  I could have just moved the test code above
# the use, but I wanted to test "extend" explicitly here.
\=
(
extend;
def "show" show;
void
)

\=(use "test/misc.fxl")

(
show "x"
show (+ 2 3)
show (is_good; standard "show")
# Demonstrate that the standard context points directly to itself.
show (
	\def==
		(
		\cx=standard
		\cx==(cx "standard")
		\cx==(cx "standard")
		cx "show"
		)
	defined def
	)
)
try_fib
)

div
(
\x="1234567890123456"
# Now make a string with length 16*(2^20) = 16,777,216 bytes.
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
put "length is " put (length x) nl
)

div
\x=42
say "Hello world."
put "x = " put x nl
say (+ x 5)
say (- x 5)
say (* x 5)
say (/ x 5)
say (/ x 0)

div
say (lt 2 3 "T" "F")
say (eq 2 2 "T" "F")
say (gt 3 2 "T" "F")
say (ge 3 4 "T" "F")
say (ge 3 3 "T" "F")
say (ge 3 2 "T" "F")
say (eq "x" "y" "T" "F")
say (eq "x" "x" "T" "F")
say (lt "x" "y" "T" "F")
say (lt "x" "x" "T" "F")
say (lt "y" "x" "T" "F")
say (lt "y" "" "T" "F")
say (lt "" "" "T" "F")
say (lt "" "x" "T" "F")
say (le "" "x" "T" "F")
say (le "x" "x" "T" "F")
say (le "x" "w" "T" "F")
say (ne "x" "x" "T" "F")
say (ne "x" "y" "T" "F")
say (ge "x" "x" "T" "F")
say (ge "x" "y" "T" "F")
say (ge "x" "w" "T" "F")
say (gt "x" "x" "T" "F")
say (gt "x" "y" "T" "F")
say (gt "x" "w" "T" "F")

div
say (+ -9.77 4.8)
say (- 211034.117654902 231.197659)
say (* 1.85 2.63)
say (round; * 1.85 2.63)
say (/ 130.08 2.63)
say (/ (* 2 (+ (- 100000000000.00 0.01) 0.02)) 2)
say (285)
say (round 125867.2)
say (round 7.2)
say (round -7.2)
say (round 7.8)
say (round -7.8)
say (trunc 7.2)
say (trunc -7.2)
say (trunc 7.8)
say (trunc -7.8)
say (^ 10 4)
say (^ 2.71828182845905 1.09861228866811)  # (^ e (ln 3))
say (exp; log 3) # more exact

say (. "" "")
say (. "" "a")
say (. "a" "b")
say (. "a" "")
say (. "abcde" "fgh")

say (length "")
say (length "a")
say (length "abc")
say (length (. "ab" "c"))

div

show_list (null)
show_list [1 2]
show_list (cons 1; cons 2; null)

# Test rand.

\demo_rand=
	(\list
	div
	show_list (first 5 list)
	show_list (first 5 list)
	)

seed_rand 0.1964

(
\list_rand=(@\loop once; \x==rand [x;loop])
demo_rand list_rand
)
(
\list_rand=(@\loop once; \x==rand [x;loop])
demo_rand list_rand
)

div
eval_file "test/stats.fxl"

div
eval_file "test/resolve.fxl"

div
\x=T say (is_bool x)
\x=F say (is_bool x)
\x=(T 1) say (is_bool x)
\x=(F 1) say (is_bool x)
\x=(T 1 2) say (is_num x)
\x=(F 1 2) say (is_num x)

div
(
\try=(\x say (is_list x))
try []
try ["a"]
try ["a" 3]
try [1]
try [1;2]
try null
try (cons 1 [])
div
try (null 1)
try cons
try (cons 1)
try T
try F
try 3
try ""
)

div
say (is_good 2)
say (is_good (say "hi"))
say (is_good [])
say (is_good void)
div
say (is_void 2)
say (is_void (say "hi"))
say (is_void [])
say (is_void void)

# Test tuples
div
(
\show=
	(@\loop\keys
	keys () \key\keys
	\val
	put [key "=" val " "]
	loop keys
	)

\try=
	(\keys\vals
	vals (show keys) nl
	)

try [] {}
try ["x"] {(+ 1 2)}
try ["x" "y"] {3 4}
try ["x" "y" "z"] {"ab" (. "cd" "efg") (^ 4 8)}
try ["x" "y"] {(+ 1 2) (* 3 4)}

(
\x=(+ 1 2)
\y=(* x 4)
try ["x" "y" "z"] {x y (* x y)}
)

try ["a""b""c""d""e""f""g"] {1 2 3 4 5 6 7}
)

div
\NL="
"

say []
say [""]
say ["a"]
say ["a""b"]
say ["a""b"3]
say ["a""b"(/ 6 4)]

(\x=(* 77 44) say ["x = " x])

(\x=(* 77 44) \y=(* 66 55)
say [["x = "x]", "["y = "y]]
)

say (cons "a")
say (cons "a" null)
say T
say F
say [T T F T F F]
say (T 1)
say (F 1)

(
\list=[(. "Hell" "o") " " (+ 4 5) NL "Bye" NL]
\list=(append list list)
\list=(append list list)
put list
)

(
# Test a function defined with UTF-8 characters.
\åabcüdef=say
åabcüdef "=="
åabcüdef ["x = " (+ 2 3)]
åabcüdef ["y = " (* 2 3)]
)

(
# Demonstrate that not all side effects repeat.
div
\talk=(say (^ (put "(L)" (+ 1 1)) (say "(R)" (- 8 5))))
talk
talk
talk
)

eval_file "test/sort.fxl"
eval_file "test/mf.fxl"

\test_context=
(
\case_1=
	(
	say "["

	\context=
	(\x
	say ["symbol " x]
	eq x "fred" (later; say "I am Fred.");
	eq x "wilma" (later; say "I am Wilma.");
	eq x "barney" (later; say "I am Barney.");
	eq x "is_void" is_void;
	eq x "say" say;
	eq x "void" (later void);
	void
	)

	say "== resolve"

	\=context

	say "== run"
	fred
	wilma
	say ["test void: " (is_void void)]
	barney

	say "]"
	)

\case_2=
	(
	say "["
	\form=(\context parse_string "say (+ 7 8)" context)

	say "Run in standard context."
	form standard

	say "Run in weird context."
	\context=(\x eq x "say" say; eq x "+" *; void)
	form context

	say "]"
	)

case_1
case_2
)

test_context

(
div
\try=
(
once (say "Let's parse.")
eval_file "test/hello.fxl"
)

try
try
try
)

(
div
\try=
(
\source=
~~
\x say [x " " (* 3 x)]
~~

once (say "Let's parse.")
eval_str source
)

try 5
try 7.2
try -1.3
)

\test_file=
(
\tmp_file="test/tmp.txt"

\write_file=
	(\content
	\fh==(fopen tmp_file "w")
	put_to fh;
	put content
	)

\show_chars=
	(\f
	\fh==(fopen tmp_file "r")
	get_from fh;
	@\loop
	\ch==get
	is_void ch ();
	f ch
	loop
	)

\remove_file=
	(
	\code==(remove tmp_file)
	say [(eq code 0 "Removed" "Could not remove") " " tmp_file]
	)

\test_1=
	(
	div
	say ["Write " tmp_file ":"]
	write_file
~
Test data
here
üä 1≠0 包子
~
	say ["Read " tmp_file ":"]
	show_chars (\ch say ["ch " ch])
	remove_file
	)

\test_2=
	(
	div
	write_file
	[
~
This goes to the file.
~
(put_to stdout; say "This should go to stdout.")
~
This also goes to the file.
~
	]

	show_chars put
	remove_file
	)

test_1
test_2
)

test_file

\test_var=
(
# In this test I created a little "assembly language" where I hide all the var
# operations in one place.

# The "!" function creates a read and write pair.
\!=(\v==var_new {(\x==(var_get v) {x}) (var_put v)})

\fib=
	(\max
	say ["The first " max " Fibonacci numbers:"]

	! \n?\n:
	! \x?\x:
	! \y?\y:

	n: 0
	x: 1
	y: 1

	@\loop
	n? \n
	ge n max ();
	x? \x
	y? \y
	say x
	x: y
	y: (+ x y)
	n: (+ n 1)
	loop
	)

fib 16
fib 5
)

div
(
\v==var_new
\x==(var_get v)
var_put v x
say "Passed var test of 20150907."
)
test_var

div
say (argv 0)
say (argv 1)
say (argv 2)

div
eval_file "test/var.fxl"

# Test evaluation order.
(
(
div
put "("
\x=(put "x=" 3)
put ")"
say x
say x
say x
)
(
div
put "("
\x==(put "x=" 3) # Force the evaluation.
put ")"
say x
say x
say x
)
(
div
\x=(say "hi" 3)
\x==x  # The effect only happens once.
\x==x
\x==x
)
)

# Test numeric formatting.
div
(
\try=
	(\n\sep\x
	say (format_num n sep x)
	say (format_num n sep (neg x))
	say (format_num n "" x)
	nl
	)

try 8 "," 123456.789012
try 7 "," 123456.789012
try 6 "," 123456.789012
try 2 "|" 123456.789012
try 5 "," 12345678.789012
try 8 "," .789012
try 0 "," 00.789012
try 0 "," 0
try 3 "," 0
try 7 "," 314.159
try 7 "," 0.159
try 3 "," 0.159265
)

(
div
\talk=(say "Hi")
talk
talk
)

(
div
\talk=(say "Hi")
\x==talk
\x==talk
)

(
div
\talk==(say "Hi")
talk
talk
)

(
\try=
	(\list
	div
	each list (\x put [x " "]) nl
	)
try (reverse ["a" "b" "c"])
try (reverse; range 1 5)
)

(
div
\indent=
	(@\loop\n
	le n 0 ();
	put " ";
	loop (- n 1)
	)

\test_quote=
	(@\loop\x\n
	le n 0 nl;
	\x=(fexl_quote x)
	\n=(- n 1)
	indent (* 3 n); say x
	loop x n
	)

test_quote "abc" 7
test_quote "ab~1c" 3
test_quote ~1 a"b"~2c~1 4
)

(
div
\x = ~ a & "b" 1<3~
say x
\x=(quote x)
say x
)

(
div
\list=["a" "b" "c"]
\try=(\n say [n " : " (check (list_at list n) "(void)")])
try -1
try 0
try 1
try 2
try 3
)

(
div
\hello=(say "Hello")

(
# Test drop buffer without getting its content.
\buf==buf_new
buf_put buf "x"
)

# Now test redirecting output to a buffer.
\result=
(
\buf==buf_new
(
put_to buf;
hello
say "line 1"
say "line 2"
put "line 3" nl
)
buf_get buf
)

say "result:"
put result
)

(
div
\run=
	(
	(@\loop\x
	ge x 900000 ();
	#ge x 4000000 ();
	loop (+ x 1)
	) 1
	)

say "["

# LATER 20151128 Without the semicolon on the line below, this test fails by
# running out of memory or stack.  That too is a symptom of the copy-up
# behavior in type_I.
;

run
say "]"
)

(
div
# Here I test the existence of the flock_ and limit_ function calls, though I'm
# not yet testing their effects.

\fh==(fopen "test/hello.fxl" "r")
say (is_good fh)
say (is_good; flock_ex fh)
say (is_good; flock_sh fh)
say (is_good; flock_un fh)
say (is_good; flock_ex "foo")

limit_time 20
limit_memory 1000000
limit_stack 20000
# The following would test either out of memory or stack overflow.
#\list=(@\list append list list)
#each list say
)

\\
Extra stuff not parsed.
