#
\show=
	(\x
	\x=x
	is_str x (put "str " say x);
	is_num x (put "num " say x);
	is_bool x (put "bool " say x);
	is_void x (say "void");
	say "other"
	)

\div=(later; say "==")

(
\ping=(later; say "ping")
div
ping
div
I ping

div
\talk=(later; ping)
\talk=(later; talk talk talk)
\talk=(later; talk talk)
\talk=(later; talk talk)
talk
)

div
show "abc"
show (I "abc")
show ("abc" "de")
show (. "abc" "de")
show (I (I "abc") "de")
show (. (I "abc") "de")
show (. ((\x\y x) "abc") "de")
show (. (I I "abc") (. "" "de"))
show void
show 3.14159265358979
show 42
show (length "12345")
show (length (. (I "abc") (. "" "d")))
show (slice (T (. "abcd" "efghi") I) 2 5)

show (+ -14.87 482.73)
show ((/ ((+ 1) (sqrt 5))) 2)

show (ge (I 5.9) 5.8)
show (lt 5.9 (I 5.8))
show (ge (I "ab") "a")
show (lt (I "ab") (I "a"))
show (eq (I "x") "x")
show (eq (I -7.2) -7.2)
show (lt (I 5.9) (I "ab"))
show (lt (I "ab") (I 5.9))
show (eq (I T) (I T))
div

show (num_str; / (+ 1 (sqrt 5)) 2)
show (str_num; . "+"; . "1." "61803398874989")
show (I I)
show (str_num (I 5.8))
show (str_num (I T))
show (num_str 5.8)
show (num_str "abc")
show (sqrt 9)
show (sqrt "abc")
show (+ "x" (I 3) 4)
show (sqrt "abc" 25)
show (length "abc")
show (length F)
show (str_num "42")
show (str_num "42x")
show (str_num "-7.8")
show (str_num "0")
show (str_num "-0")
show (+ (str_num "1"); str_num; num_str; str_num "42.8")

div
show (slice "abcd" 2 3)
show (slice "abcd" 2 2)
show (slice "abcd" 2 0)
show (slice "abcd" -2 3)
show (slice "abcd" 2 -3)
show (slice "" 1 2)
show (slice "abc" 1 2)
show (slice "abc" 0 3)
show (slice "abc" 0 4)
show (slice "abc" 2 1)
show (slice "abc" -1 2)

\val_is_num=(\x \x=x is_num x)
\val_is_str=(\x \x=x is_str x)

div
show (is_str I)
show (is_str 4)
show (is_str "x")
show (val_is_str; . "x" "y")
show (is_num "x")
show (is_num 4.2)
show (val_is_num (* 3.9 4.2))
show (val_is_num; str_num "4.87")
show (val_is_num; str_num "  4.87")

# The str_num function allows leading white space, but forbids any trailing
# invalid chars, including white space.  This reflects how strtod works.
show (val_is_num; str_num " 4.87 ")
show (val_is_num; str_num "4.87x")

show (val_is_num; str_num "-4.6")
show (val_is_num; str_num "-4.6x")

# Test some more good and void cases.
div
show void
show (void 3)
show (length 3)
show (length "abc")
show (length 3 "abc")
show (eval_file 32)
show (lt 3 4)
show (lt 3 "4")
show (lt 3 "4" "5")
show (+ "x" 4)
show (+ "x" 4 5)
show (sqrt 16)
show (sqrt "x")
show (sqrt "x" 16)
show 3
show (3 "x")
show (num_str 42)
show (num_str "abc")
show (num_str "abc" 42)
show (is_void void)
show "abc"
show ("abc" "x")
show (. "abc" "de")
show (. 3 "de")
show (. 3 "de" "fg")
show (length "abc")
show (length 27)
show (length 27 "abc")
show (slice "abcdefg" 3 2)
show (slice "abcdefg" 3 5)
show (slice "abcdefg" -3 5)
show (slice "abcdefg" "3" 5)
show (str_num "42")
show (str_num "42x")
show (str_num 42)

div
# Test some tricky string terminators.
say ~ABC abcdABAABC
say ~ABCD AABABCABCD

# Multiple layers of quotation.
say "hello"
say ~(1) "hello"(1)
say ~(2) ~(1) "hello"(1)(2)
say ~(3) ~(2) ~(1) "hello"(1)(2)(3)

say ~| "Ain't nothin' simple when you're doin' it for real." (Gus Baird)|
nl
say ~@
"My fathers sleep on the sunrise plains,
And each one sleeps alone.
Their trails may dim to the grass and rains,
For I choose to make my own.
I lay proud claim to their blood and name,
But I lean on no dead kin;
My name is mine, for the praise or scorn,
And the world began when I was born
And the world is mine to win. ..."

  (Badger Clark, "The Westerner")
@

# Test delayed evaluation.
div
\show_x=
	(
	say "(CALC)"
	\x=(* 5 6)
	later;
	put "x = " say x
	)

say "["
show_x
show_x
show_x
show_x
say "]"

div
eval_file "test/hello.fxl"
div
eval_file "test/utf8.fxl"
div
eval_file "test/beer.fxl"

div
eval_str ~END
\x=(+ 33 48)
put "x = " say x
END

div
# This demonstrates that (\x f x) is not strictly equivalent to f, when side
# effects are taken into account.
\say_x=(\x put "x = " say x)
say_x 3
say_x 4
say_x 5

div

\for=
	(\x\y\f
	\x=(round x)
	\y=(round y)
	\d=(le x y 1 -1)
	\loop==
		(\x
		f x
		eq x y ();
		\x=(+ x d)
		loop x
		)
	loop x
	)

# (fib n) returns the nth Fibonacci number starting at 0. */
\fib=
	(
	\fib==
		(\x\y\n
		le n 0 x;
		\z=(+ x y)
		\n=(- n 1)
		fib y z n
		)
	fib 0 1
	)

\try=
	(\x\y
	for x y \n
	put "fib " put n put " = " say (fib n)
	)

try 0 8
div
try 8 0
div
try 30 30
div
try 11.2 20.5

div
(
\x="1234567890123456"
# Now make a string with length 16*(2^20) = 16,777,216 bytes.
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
put "length is " put (length x) nl
)

div
\x=42
say "Hello world."
put "x = " put x nl
say (+ x 5)
say (- x 5)
say (* x 5)
say (/ x 5)
say (/ x 0)

div
say (lt 2 3 "T" "F")
say (eq 2 2 "T" "F")
say (gt 3 2 "T" "F")
say (ge 3 4 "T" "F")
say (ge 3 3 "T" "F")
say (ge 3 2 "T" "F")
say (eq "x" "y" "T" "F")
say (eq "x" "x" "T" "F")
say (lt "x" "y" "T" "F")
say (lt "x" "x" "T" "F")
say (lt "y" "x" "T" "F")
say (lt "y" "" "T" "F")
say (lt "" "" "T" "F")
say (lt "" "x" "T" "F")
say (le "" "x" "T" "F")
say (le "x" "x" "T" "F")
say (le "x" "w" "T" "F")
say (ne "x" "x" "T" "F")
say (ne "x" "y" "T" "F")
say (ge "x" "x" "T" "F")
say (ge "x" "y" "T" "F")
say (ge "x" "w" "T" "F")
say (gt "x" "x" "T" "F")
say (gt "x" "y" "T" "F")
say (gt "x" "w" "T" "F")

div
say (+ -9.77 4.8)
say (- 211034.117654902 231.197659)
say (* 1.85 2.63)
say (round; * 1.85 2.63)
say (/ 130.08 2.63)
say (/ (* 2 (+ (- 100000000000.00 0.01) 0.02)) 2)
say (285)
say (round 125867.2)
say (round 7.2)
say (round -7.2)
say (round 7.8)
say (round -7.8)
say (trunc 7.2)
say (trunc -7.2)
say (trunc 7.8)
say (trunc -7.8)
say (^ 10 4)
say (^ 2.71828182845905 1.09861228866811)  # (^ e (ln 3))

say (. "" "")
say (. "" "a")
say (. "a" "b")
say (. "a" "")
say (. "abcde" "fgh")

say (length "")
say (length "a")
say (length "abc")
say (length (. "ab" "c"))

div
# Do fn for each item in list xs.
\do==(\xs\fn xs () \x\xs fn x; do xs fn)
# Return the first n items of a list.
\first==
	(\n\xs
	le n 0 [];
	xs [] \x\xs
	\n=(- n 1)
	\xs=(first n xs)
	[x;xs]
	)

\show_list=(\xs say "[" (do xs say) say "]")

# Testing with some "later" sprinkled in to ensure that type_later sets the
# value type to type_A, not type_I.
show_list (later null)
show_list [1 2]
show_list (cons 1; cons 2; later null)

# Test rand.

# An infinite list of pseudo-random numbers.
\list_rand=(later; @\loop \x=rand [x;loop])

\demo_rand=
	(
	later;
	div
	\list=(first 5 list_rand)
	show_list list
	show_list list
	)
seed_rand 0.1964
demo_rand
demo_rand

div
eval_file "test/stats.fxl"

div
eval_file "test/resolve.fxl"

\\
Extra stuff not parsed.
