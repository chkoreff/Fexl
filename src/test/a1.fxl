#
evaluate;
use "test.fxl";
\;

\show=
	(\x
	\x=x
	\type=(\t put [t " "] say x)
	is_str x (type "str");
	is_num x (type "num");
	is_bool x (type "bool");
	is_void x (say "void");
	say "other"
	)

\eval_file=
	(\name
	evaluate;
	use_standard;
	parse_file (path_under dir_local name)
	)

\eval_str=(\str evaluate; use_standard; parse str "")

(
\ping==(say "ping")
div
ping
div
I ping

div
\talk==(ping)
\talk==(talk talk talk)
\talk==(talk talk)
\talk==(talk talk)
talk

div
# Should say PING six times.
\ping==(say "ping")
\other=(once ping)
\talk==(ping other)
talk
talk
talk
talk
ping
)

div
show "abc"
show (I "abc")
show ("abc" "de")
show (. "abc" "de")
show (I (I "abc") "de")
show (. (I "abc") "de")
show (. ((\x\y x) "abc") "de")
show (. (I I "abc") (. "" "de"))
show void
show 3.14159265358979
show 42
show (length "12345")
show (length (. (I "abc") (. "" "d")))
show (slice (T (. "abcd" "efghi") I) 2 5)

show (+ -14.87 482.73)
show ((/ ((+ 1) (sqrt 5))) 2)

show (ge (I 5.9) 5.8)
show (lt 5.9 (I 5.8))
show (ge (I "ab") "a")
show (lt (I "ab") (I "a"))
show (eq (I "x") "x")
show (eq (I -7.2) -7.2)
show (lt (I 5.9) (I "ab"))
show (lt (I "ab") (I 5.9))
show (eq (I T) (I T))
div

show (num_str; / (+ 1 (sqrt 5)) 2)
show (str_num; . "+"; . "1." "61803398874989")
show (I I)
show (str_num (I 5.8))
show (str_num (I T))
show (num_str 5.8)
show (num_str "abc")
show (sqrt 9)
show (sqrt "abc")
show (+ "x" (I 3) 4)
show (sqrt "abc" 25)
show (length "abc")
show (length F)
show (str_num "42")
show (str_num "42x")
show (str_num "-7.8")
show (str_num "0")
show (str_num "-0")
show (+ (str_num "1"); str_num; num_str; str_num "42.8")

# Test slice.
(
div
show (slice "" 0 0)
show (slice "" 0 7)
show (slice "" 1 2)
div
show (slice "a" 0 1)
show (slice "a" 1 1)
show (slice "a" 2 1)
div
show (slice "abcd" 0 0)
show (slice "abcd" 0 1)
show (slice "abcd" 0 2)
show (slice "abcd" 0 3)
show (slice "abcd" 0 4)
show (slice "abcd" 0 5)
div
show (slice "abcd" 1 0)
show (slice "abcd" 1 1)
show (slice "abcd" 1 2)
show (slice "abcd" 1 3)
show (slice "abcd" 1 4)
div
show (slice "abcd" 2 0)
show (slice "abcd" 2 1)
show (slice "abcd" 2 2)
show (slice "abcd" 2 3)
div
show (slice "abcd" 3 0)
show (slice "abcd" 3 1)
show (slice "abcd" 3 2)
div
# Negative cases return void.
show (slice "abcd" -2 3)
show (slice "abcd" 2 -3)
show (slice "" -1 2)
show (slice "abc" -1 -2)
)

# Test search.
(
div
\try=(\x\y\offset show (search x y offset))

# These cases agree with the Perl "index" function.  Where Fexl returns void,
# Perl returns -1.
try "abcdefg" "de" 0 # 3
try "abcdefg" "cde" 0 # 2
try "abcdefg" "cdx" 0 # void
try "abcdefg" "cde" 2 # 2
try "abcdefg" "cde" 3 # void
try "abcdefg" "de" 2 # 3
try "abcdefg" "de" 3 # 3
try "abcdefg" "de" 4 # void
try "" "a" 0 # void
try "" "" -1 # void
try "abcdefghijklmnop" "" 0 # 0
try "abcdefghijklmnop" "" 7 # 7
try "abcdefghijklmnop" "" 15 # 15
try "abcdefghijklmnop" "ghI" 0 # void
try "abcdefghijklmnop" "ghi" 0 # 6
try "abcdefghijklmnop" "mnop" 0 # 12
try "abcdefghijklmnop" "mnopq" 0 # void
try "abcdefghijklmnop" "p" 0 # 15
try "abcdefghijklmnop" "q" 0 # void
try "abcdefghijklmnop" "abcdefghijklmnop" 0 # 0
try "abcdefghijklmnop" "abcdefghijklmnop" 1 # void
try "abcdefghijklmnop" "abcdefghijklmnopq" 0 # void
try "a" "ab" 0 # void
try "a" "a" 0 # 0

# These cases diverge from the Perl "index" function.  Fexl returns void, but
# Perl shows a match at position 0.  The difference is because str_search does
# not use -1 to indicate not found, since I use unsigned longs.  Instead, it
# returns a position which points beyond the end of the subject string, and
# when the subject string is empty, any value does that.  I find this
# difference acceptable.
try "" "" 0 # void
try "" "" 8 # void
)

(
say "== test char_width"

# Return the list of UTF-8 chars starting from the given position.
\str_chars=
	(\str @\loop \pos
	\pos=pos
	ge pos (length str) [];
	\n=(char_width str pos)
	\ch=(slice str pos n)
	[ch; loop (+ pos n)]
	)

\str="hej åabcüdef üä 1≠0 包子x"
\list=(str_chars str 0)

say ["str " str]
each list (\ch say ["ch " ch])
)

(
say "== test buf"
\buf=buf_new
\put=(buf_put buf)
\get==(say [": " (buf_get buf)])
put "abc"
put "defg"
get
get
put "abc"
put "d"
put ""
put ""
put "e"
get
put "tuvwxyz"
get

say (to_str [["ab" "c "] [[] [] ""] [2.3 " " -3.8] " defg"])
)

div
show (is_str I)
show (is_str 4)
show (is_str "x")
show (is_str; . "x" "y")
show (is_num "x")
show (is_num 4.2)
show (is_num (* 3.9 4.2))
show (is_num; str_num "4.87")
show (is_num; str_num "  4.87")

# The str_num function allows leading white space, but forbids any trailing
# invalid chars, including white space.  This reflects how strtod works.
show (is_num; str_num " 4.87 ")
show (is_num; str_num "4.87x")

show (is_num; str_num "-4.6")
show (is_num; str_num "-4.6x")

# Test some more good and void cases.
div
show void
show (void 3)
show (length 3)
show (length "abc")
show (length 3 "abc")
show (lt 3 4)
show (lt 3 "4")
show (lt 3 "4" "5")
show (+ "x" 4)
show (+ "x" 4 5)
show (sqrt 16)
show (sqrt "x")
show (sqrt "x" 16)
show 3
show (3 "x")
show (num_str 42)
show (num_str "abc")
show (num_str "abc" 42)
show (is_void void)
show "abc"
show ("abc" "x")
show (. "abc" "de")
show (. 3 "de")
show (. 3 "de" "fg")
show (length "abc")
show (length 27)
show (length 27 "abc")
show (slice "abcdefg" 3 2)
show (slice "abcdefg" 3 5)
show (slice "abcdefg" -3 5)
show (slice "abcdefg" "3" 5)
show (str_num "42")
show (str_num "42x")
show (str_num 42)

div
# Test some tricky string terminators.
say ~ABC abcd~ABA~ABC
say ~ABCD AAB~ABC~ABCD

# Multiple layers of quotation.
say "hello"
say ~(1) "hello"~(1)
say ~(2) ~(1) "hello"~(1)~(2)
say ~(3) ~(2) ~(1) "hello"~(1)~(2)~(3)

say ~ "Ain't nothin' simple when you're doin' it for real." (Gus Baird)~
nl
say ~
"My fathers sleep on the sunrise plains,
And each one sleeps alone.
Their trails may dim to the grass and rains,
For I choose to make my own.
I lay proud claim to their blood and name,
But I lean on no dead kin;
My name is mine, for the praise or scorn,
And the world began when I was born
And the world is mine to win. ..."

  (Badger Clark, "The Westerner")
~

# Test single evaluation.
(
div
\notify=(once; say "(CALC)")
\show_x==
	(
	notify
	\x=(* 5 6)
	say ["x = " x]
	)

say "["
show_x
show_x
show_x
show_x
say "]"

(
\notify=(once; put "(CALC)")
\x==(notify + 2 (* 7 6))

\make_square=
	(\x
	\notify=(once; put ["square " x "="])
	later;
	notify
	* x x
	)

div

say (* x x)
say (+ x x)
\s4=(make_square 4)
\s7=(make_square 7)

say s4
say s7
say s4
say s7
)
)

div
eval_file "hello.fxl"
div
eval_file "utf8.fxl"
div
eval_file "beer.fxl"
div
eval_file "hailstone.fxl"

div
eval_str ~END
\x=(+ 33 48)
say ["x = " x]
~END

div
(
evaluate;
use "try_fib.fxl";
define "show" show;
use_standard;
\;
show "x"
show (+ 2 3)
try_fib
)

div
(
evaluate;
define "say" say;
define "put" put;
define "nl" nl;
define "+" +;
define "round" round;
define "trunc" trunc;
define "abs" abs;
define "sqrt" sqrt;
define "exp" exp;
define "log" log;
define "sin" sin;
define "fred" (say "I am Fred.");
use_numbers;
\;
say "hi"
fred
say (+ 42.8 -7.6)
say (+ 28 46.5)
say (+ 28 46.5)
say (+ 28 46.5)
say (round 14.8)
say (trunc 14.8)
say (abs 14.8)
say (sqrt 14.8)
say (exp 4.8)
say (log 4.8)
say (sin 4.8)
put "bye" nl
)

div
(
\x42.5=8.76
\42.5x=2.28
\42.5=9.63
\inf=14
\nan=13
\-inf=-1.3
\-nan=-.5
say (+ x42.5; + 42.5x; + 42.5; + inf; + nan; + -inf; + -nan; 0)
)

div
(
\x="1234567890123456"
# Now make a string with length 16*(2^20) = 16,777,216 bytes.
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
\x=(. x x)
put "length is " put (length x) nl
)

div
\x=42
say "Hello world."
put "x = " put x nl
say (+ x 5)
say (- x 5)
say (* x 5)
say (/ x 5)
say (/ x 0)

div
say (lt 2 3 "T" "F")
say (eq 2 2 "T" "F")
say (gt 3 2 "T" "F")
say (ge 3 4 "T" "F")
say (ge 3 3 "T" "F")
say (ge 3 2 "T" "F")
say (eq "x" "y" "T" "F")
say (eq "x" "x" "T" "F")
say (lt "x" "y" "T" "F")
say (lt "x" "x" "T" "F")
say (lt "y" "x" "T" "F")
say (lt "y" "" "T" "F")
say (lt "" "" "T" "F")
say (lt "" "x" "T" "F")
say (le "" "x" "T" "F")
say (le "x" "x" "T" "F")
say (le "x" "w" "T" "F")
say (ne "x" "x" "T" "F")
say (ne "x" "y" "T" "F")
say (ge "x" "x" "T" "F")
say (ge "x" "y" "T" "F")
say (ge "x" "w" "T" "F")
say (gt "x" "x" "T" "F")
say (gt "x" "y" "T" "F")
say (gt "x" "w" "T" "F")

div
say (+ -9.77 4.8)
say (- 211034.117654902 231.197659)
say (* 1.85 2.63)
say (round; * 1.85 2.63)
say (/ 130.08 2.63)
say (/ (* 2 (+ (- 100000000000.00 0.01) 0.02)) 2)
say (285)
say (round 125867.2)
say (round 7.2)
say (round -7.2)
say (round 7.8)
say (round -7.8)
say (trunc 7.2)
say (trunc -7.2)
say (trunc 7.8)
say (trunc -7.8)
say (^ 10 4)
say (^ 2.71828182845905 1.09861228866811)  # (^ e (ln 3))
say (exp; log 3) # more exact

say (. "" "")
say (. "" "a")
say (. "a" "b")
say (. "a" "")
say (. "abcde" "fgh")

say (length "")
say (length "a")
say (length "abc")
say (length (. "ab" "c"))

div

show_list (null)
show_list [1 2]
show_list (cons 1; cons 2; null)

# Test rand.
(
\try=
	(\list
	div
	show_list (first 5 list)
	show_list (first 5 list)
	)

\list_rand==(stream_values rand)

\list_1=list_rand
\list_2=list_rand

seed_rand 0.1964
try list_1
try list_2
)

div
eval_file "stats.fxl"

div
eval_file "resolve.fxl"

div
\x=T say (is_bool x)
\x=F say (is_bool x)
\x=(T 1) say (is_bool x)
\x=(F 1) say (is_bool x)
\x=(T 1 2) say (is_num x)
\x=(F 1 2) say (is_num x)

div
(
\try=(\x say (is_list x))
try []
try ["a"]
try ["a" 3]
try [1]
try [1;2]
try null
try (cons 1 [])
div
try (null 1)
try cons
try (cons 1)
try T
try F
try 3
try ""
)

div
say (is_good 2)
say (is_good (say "hi"))
say (is_good [])
say (is_good void)
div
say (is_void 2)
say (is_void (say "hi"))
say (is_void [])
say (is_void void)
# Symbolic form applied to anything is void.
say (is_void ( (\; f x) 3) )
# evaluate_later can only be applied to forms.
say (is_void (evaluate_later 36.3))
say (is_void (evaluate_later (\x\y y x)))

say (is_resolved; \; say "hi")
say (is_resolved; define "say" say; \; say "hi")

# Test tuples
say "== tuples"
(
\show_tuple=
	(\data
	put "{ "
	(@\loop\data
	split_tuple data () \left\x
	loop left
	put [x" "]
	) data
	say "}"
	)

\join_items=
	(@\loop\data\xs
	show_tuple data
	xs () \x\xs
	\data=(join_tuple data x)
	loop data xs
	)

join_items {} (map (\x chr; + x 96); range 1 6)
)
(
\try=
	(\list
	each list
		(\pair
		pair \key\val
		put [key "=" val " "]
		)
	nl
	)

try []
try [ {"x" (+ 1 2)} ]

try [ {"x" 3} {"y" 4} ]
try [ {"x" "ab" } {"y" (. "cd" "efg") } {"z" (^ 4 8) }]
try [ {"x" (+ 1 2)} {"y" (* 3 4)} ]

(
\x=(+ 1 2)
\y=(* x 4)
try [ {"x" x} {"y" y} {"z" (* x y)} ]
)

try [ {"a" 1} {"b" 2} {"c" 3} {"d" 4} {"e" 5} {"f" 6} {"g" 7} ]
)

div

say []
say [""]
say ["a"]
say ["a""b"]
say ["a""b"3]
say ["a""b"(/ 6 4)]

(\x=(* 77 44) say ["x = " x])

(\x=(* 77 44) \y=(* 66 55)
say [["x = "x]", "["y = "y]]
)

say (cons "a")
say (cons "a" null)
say T
say F
say [T T F T F F]
say (T 1)
say (F 1)

(
\list=[(. "Hell" "o") " " (+ 4 5) NL "Bye" NL]
\list=(append list list)
\list=(append list list)
put list
)

(
# Test a function defined with UTF-8 characters.
\åabcüdef=say
åabcüdef "=="
åabcüdef ["x = " (+ 2 3)]
åabcüdef ["y = " (* 2 3)]
)

(
# Demonstrate the repetition of side effects.
div
\talk==(say (^ (put "(L)" (+ 1 1)) (say "(R)" (- 8 5))))
talk
talk
talk
)

eval_file "sort.fxl"
eval_file "mf.fxl"

\test_context=
(
\case_1==
	(
	say "["
	say "== resolve"

	\define=
		(\x\def\form
		say ["symbol "x]
		define x def form
		)

	evaluate;
	define "say" say;
	define "fred" (say "I am Fred.");
	define "wilma" (say "I am Wilma.");
	define "is_void" is_void;
	define "void" void;
	define "barney" (say "I am Barney.");
	\;
	say "== run"
	fred
	wilma
	say ["test void: " (is_void void)]
	barney

	say "]"
	)

\case_2==
	(
	say "["
	\form=(parse "say (+ 7 8)" "")

	say "Run in standard context."
	(
	evaluate;
	use_standard;
	form
	)

	say "Run in weird context."
	(
	evaluate;
	define "say" say;
	define "+" *;
	use_numbers;
	form
	)

	say "]"
	)

\case_3==
	(
	\run=
		(
		\form=
			(use_standard \;
			say "PING"
			)
		later;
		evaluate form
		)

	say "["
	run
	run
	run
	say "]"
	)

case_1
case_2
case_3
)

test_context

(
div
\notify=(once; say "Let's parse.")
\try==
(
notify
eval_file "hello.fxl"
)

try
try
try
)

(
div
\notify=(once; say "Let's parse.")
\try==
(
\source=
~~
\x say [x " " (* 3 x)]
~~

notify
eval_str source
)

try 5
try 7.2
try -1.3
)

\test_file==
(
\tmp_name="tmp.txt"
\tmp_file=(path_under dir_local tmp_name)

\write_file=
	(\content
	\fh=(fopen tmp_file "w")
	fput fh content
	fclose fh  # You must do this.
	)

\show_chars=
	(\f
	\fh=(fopen tmp_file "r")
	(@\loop
	\ch=(fget fh)
	is_void ch ();
	f ch
	loop
	)
	fclose fh
	)

\remove_file==
	(
	\code=(remove tmp_file)
	say [(eq code 0 "Removed" "Could not remove") " " tmp_name]
	)

\test_1==
	(
	div
	say ["Write " tmp_name ":"]
	write_file
~
Test data
here
üä 1≠0 包子
~
	say ["Read " tmp_name ":"]
	show_chars (\ch say ["ch " ch])
	remove_file
	)

\test_2==
	(
	div
	write_file
	[
~
This goes to the file.
~
(say "This should go to stdout.")
~
This also goes to the file.
~
	]

	show_chars put
	remove_file
	)

# Here I test interleaved writes and reads to the same file, which acts like a
# queue.
\test_3==
	(
	div

	\open==(fopen tmp_file)
	\fh_w=(once; open "w")
	\fh_r=(once; open "r")

	\put=
		(\x
		say ["put " x]
		fput fh_w x
		fflush fh_w  # You must do this.
		)

	\get==
		(
		\ch=(fget fh_r)
		say ["get " (is_void ch "void" ch)]
		)

	put "a"
	get get
	put "bc"
	get
	put "d"
	get get
	put "efg"
	get
	put "h"
	get get get get

	remove_file
	)

test_1
test_2
test_3
)

test_file

\test_var==
(
# In this test I created a little "assembly language" where I hide all the var
# operations in one place.

# The "!" function creates a read and write pair.
\!==(\v=var_new {(\x=(var_get v) {x}) (var_put v)})

\fib=
	(\max
	say ["The first " max " Fibonacci numbers:"]

	! \n?\n:
	! \x?\x:
	! \y?\y:

	n: 0
	x: 1
	y: 1

	@\loop
	n? \n
	ge n max ();
	x? \x
	y? \y
	say x
	x: y
	y: (+ x y)
	n: (+ n 1)
	loop
	)

fib 16
fib 5
)

div
(
\v=var_new
\x=(var_get v)
var_put v x
say "Passed var test of 20150907."
)
test_var

div
eval_file "var.fxl"

# Test evaluation order.
(
(
div
put "("
\x==(put "x=" 3)
put ")"
say x
say x
say x
)
(
div
put "("
\x=(put "x=" 3) # Force the evaluation.
put ")"
say x
say x
say x
)
(
div
\x==(say "hi" 3)
\x=x # The effect only happens once.
\x=x
\x=x
)
)

# Test numeric formatting.
div
(
\try=
	(\n\sep\x
	say (format_num n sep x)
	say (format_num n sep (neg x))
	say (format_num n "" x)
	nl
	)

try 8 "," 123456.789012
try 7 "," 123456.789012
try 6 "," 123456.789012
try 2 "|" 123456.789012
try 5 "," 12345678.789012
try 8 "," .789012
try 0 "," 00.789012
try 0 "," 0
try 3 "," 0
try 7 "," 314.159
try 7 "," 0.159
try 3 "," 0.159265
)

(
div
\talk==(say "Hi")
talk
talk
)

(
div
\talk==(say "Hi")
\x=talk
\x=talk
)

(
div
\talk=(say "Hi")
talk
talk
)

(
\try=
	(\list
	div
	each list (\x put [x " "]) nl
	)
try (reverse ["a" "b" "c"])
try (reverse; range 1 5)
)

(
div
\indent=
	(@\loop\n
	\n=n
	le n 0 ();
	put " ";
	loop (- n 1)
	)

\test_quote=
	(@\loop\x\n
	le n 0 nl;
	\x=(fexl_quote x)
	\n=(- n 1)
	indent (* 3 n); say x
	loop x n
	)

test_quote "abc" 7
test_quote "ab~1c" 3
test_quote ~1 a"b"~2c~1 4
)

(
div
\x = ~ a & "b" 1<3~
say x
\x=(quote x)
say x
say (is_str x)
)

(
div
\list=["a" "b" "c"]
\try=(\n say [n " : " (check (list_at list n) "(void)")])
try -1
try 0
try 1
try 2
try 3
)

(
div

(
# Test drop buffer without getting its content.
\buf=buf_new
buf_put buf "x"
)

# Now test redirecting output to a buffer.
\result==
(
\buf=buf_new
\put=(\x buf_put buf; to_str x)
\nl==(buf_put buf NL)
\say=(\x put x nl)
(
\hello==(say "Hello")
hello
say ["line " 1]
say "line 2"
put ["line " 3] nl
)
buf_get buf
)

say "result:"
put result
)

(
div
# Here I test the existence of the flock_ and limit_ function calls, though I'm
# not yet testing their effects.

\fh=(fopen (path_under dir_local "hello.fxl") "r")
say (is_good fh)
say (is_good; flock_ex fh)
say (is_good; flock_sh fh)
say (is_good; flock_un fh)
say (is_good; flock_ex "foo")
fclose fh
is_void fh (say "File handle is properly void after close.") ()

if F
(
limit_time 20
limit_memory 1000000
limit_stack 20000
# The following would test either out of memory or stack overflow.
#\list=(@\list append list list)
#each list say
)
)

div
each (range 1 12)
	(\n
	say [(short_month_name n) " " (ym_num_days 2016 n) " " (long_month_name n)]
	)

(
# Try the various kinds of output functions.
div
\try=
(\label\do
say ["== "label]
put "["
do (. "abcde" "fg")
do (+ 1 2.2)
do (I T)
do F
do (\x\y y)
do [["" "A"] ["B" "C"] "D"]
say "]"
)

try "put" put
try "say" say
try "fput" (fput stdout)
try "fsay" (fsay stdout)
)

# Test comparison of file modification times.
(
\try=
	(\f1\f2
	\base=(path_under dir_base)
	say ["is_newer "f1" "f2" = "(is_newer (base f1) (base f2))]
	)

\try=
	(\f1\f2
	try f1 f2
	try f2 f1
	nl
	)

try "src/fexl.c" "bin/fexl"
try "src/test/a1.fxl" "missing"
try "src/test/a1.fxl" "src/test/a1.fxl"
try "missing" "missing"
)

\\
Extra stuff not parsed.
