# Run the user's script given by argv[1] in the enhanced standard context.

# Use a file given by a direct path.
\use_file=(\name\context evaluate context; parse_file name)

# (check x d) = x if x is good, otherwise d.
\check=(\x \x=x is_defined x x)
# (default d x) = x if x is good, otherwise d.
\default=(\d\x \x=x is_defined x x d)

# Returns a context which tries prev first, then next.
\::=
	(\prev\next
	\key
	\val=((\= prev) key)
	is_defined val val;
	(\= next) key
	)

# Chain a list of contexts together, trying each one in turn.
\chain=
	(@\loop\list
	list void \cx\list
	\key
	\val=((\= cx) key)
	is_defined val val;
	(\= loop list) key
	)

# (if x y) = y if x is true, other I.
\if=(\x\y x y I)

\trace=(fsay stderr)
\error=(\msg trace msg die)

# Define key as val.
\def=(\key\val with key {val})

# Define numeric constants.
\def_num=
	(\cx\key
	\val=(str_num key)
	is_defined val {val};
	cx key
	)

# Define key to refer to a context.
\def_context=
	(\key\cx
	\cx=cx
	@\self
	def key self;
	cx
	)

# Evaluate a form in a list of chained contexts.
\using=
	(\list
	evaluate (chain list)
	)

\path_under=(\dir\name . (. dir "/") name)

# Establish paths based on command arguments.
\dir_base=(dirname; dirname; argv 0)
\dir_lib=(path_under dir_base "src/lib")

\script_name=(default "" (argv 1))
\dir_local=(dirname script_name)

# Use a file in the directory which contains the user's script.
\use=(\name use_file (path_under dir_local name))

# Make a cache which remembers the values of a function with n arguments.
\remember=
	(\n
	\v=var_new
	(@\loop\n
	le n 1 fetch;
	\n=(- n 1)
	\f=(loop n)
	\v\k
	\v=(fetch v k var_new)
	f v
	) n v
	)

# Equivalent to (remember 1).
\cache==(\v=var_new fetch v)

\NL=="
"
\TAB=="	"
\CR==(chr 13)
\LF==NL
\QU==~ "~

\import=(\cx\key with key (cx key))
\import_as=(\cx\key\name with name (cx key))

\run_benchmark=
	(\show\f
	fexl_benchmark f \val\steps\bytes
	show ["steps "steps" bytes "bytes]
	val
	)

\do_benchmark=(run_benchmark trace)
\show_benchmark=(run_benchmark say)

# Evaluate an expression in a library system.  This defines a "lib" function
# which loads libraries by name, caching them so they are not loaded again.
# Libraries are loaded with the load function and resolved in the base context.
# The resulting lib function is passed into the fn handler.
\def_lib=
	(\load\base\fn

	# Cache for named libraries.
	\v_lib=var_new

	\lib=
		(@\lib\name
		fetch v_lib name;
		evaluate
			(
			def_context "std";
			def "lib" lib;
			base
			);
		load name
		)

	# Evaluate the handler, passing in the lib function.
	\result=(fn lib)

	# Clear the cache to avoid any possible memory leak.  This could happen if
	# your code defines a context that refers back to "lib" or "std", creating
	# a physically circular structure in memory due to the use of var here to
	# cache the libraries.

	var_put v_lib void

	# Return the result.
	result
	)

# Define a library which loads files in a given directory.
\def_lib_in=
	(\dir
	def_lib (\name parse_file (path_under dir name))
	)

# Add some functions to the standard context.
\std=
(
def "def" def;
def "def_context" def_context;
def "def_num" def_num;
def "if" if;
def "::" ::;
def "using" using;
def "chain" chain;
def "def_lib" def_lib;
def "def_lib_in" def_lib_in;

def "use" use;
def "use_file" use_file;

def "check" check;
def "default" default;

def "path_under" path_under;
def "dir_base" dir_base;
def "dir_local" dir_local;

def "trace" trace;
def "error" error;

def "TAB" TAB;
def "NL" NL;
def "CR" CR;
def "LF" LF;
def "QU" QU;

def "remember" remember;
def "cache" cache;
def "import" import;
def "import_as" import_as;
def "do_benchmark" do_benchmark;
def "show_benchmark" show_benchmark;
std
)

# Create a lib function which loads libraries from dir_lib.
def_lib_in dir_lib std \lib

# Chain the libraries to load on demand.
\std=
(
chain
[
std
(lib "bool.fxl")
(lib "math.fxl")
(lib "list.fxl")
(lib "format.fxl")
(lib "indent.fxl")
(lib "assoc.fxl")
(lib "hex.fxl")
(lib "html.fxl")
(lib "time.fxl")
(lib "date.fxl")
(lib "run.fxl")
(lib "read_csv.fxl")
(lib "read_ssv.fxl")
]
)

# Create a lib function which loads libraries from dir_local.
def_lib_in dir_local std \lib

\std=
(
def_context "std";
def "lib" lib;
std
)

# Evaluate the user's script.
evaluate std;
parse_file script_name
