# Run the user's script given by argv[1] in the enhanced standard context.

# Use a file given by a direct path.
\use_file=(\name\context evaluate context; parse_file name)

# (check x d) = x if x is good, otherwise d.
\check=(\x \x=x is_defined x x)
# (default d x) = x if x is good, otherwise d.
\default=(\d\x \x=x is_defined x x d)

# Chain prev and next.  Returns a context which tries prev first, then next.
\::=
	(\prev\next
	\key
	\val=((\= prev) key)
	is_defined val val;
	(\= next) key
	)

# (if x y) = y if x is true, other I.
\if=(\x\y x y I)

\trace=(fsay stderr)
\error=(\msg trace msg die)

# Return a context with key defined as val.
\def=(\key\val with key {val})

\path_under=(\dir\name . (. dir "/") name)

# Establish paths based on command arguments.
\dir_base=(dirname; dirname; argv 0)
\dir_lib=(path_under dir_base "src/lib")

\script_name=(default "" (argv 1))
\dir_local=(dirname script_name)

# Use a file in the Fexl library directory.
\use_lib=(\name use_file (path_under dir_lib name))

# Use a file in the directory which contains the user's script.
\use=(\name use_file (path_under dir_local name))

# Make a cache which remembers the values of a function with n arguments.
\remember=
	(\n
	\v=var_new
	(@\loop\n
	le n 1 fetch;
	\n=(- n 1)
	\f=(loop n)
	\v\k
	\v=(fetch v k var_new)
	f v
	) n v
	)

# Equivalent to (remember 1).
\cache==(\v=var_new fetch v)

\NL=="
"
\TAB=="	"
\CR==(chr 13)
\LF==NL
\QU==~ "~

\import=(\cx\key with key (cx key))
\import_as=(\cx\key\name with name (cx key))

\cx_lib=
	(
	:: standard;
	def "def" def;
	def "if" if;
	def "NL" NL;
	def "QU" QU;
	def "CR" CR;
	def "LF" LF;
	def "trace" trace;
	def "error" error;
	void
	)

\cx_bool==(\= use_lib "bool.fxl"; cx_lib)
\cx_math==(\= use_lib "math.fxl"; cx_lib)

\cx_list==
	(\=
	use_lib "list.fxl";
	:: cx_lib;
	:: cx_bool;
	void
	)

\cx_format==
	(\=
	use_lib "format.fxl";
	:: cx_lib;
	:: cx_bool;
	:: cx_math;
	:: cx_list;
	void
	)

\cx_indent==
	(\=
	use_lib "indent.fxl";
	:: cx_lib;
	:: cx_format;
	:: cx_list;
	void
	)

\cx_assoc==
	(\=
	use_lib "assoc.fxl";
	:: cx_lib;
	:: cx_list;
	void
	)

\cx_hex==
	(\=
	use_lib "hex.fxl";
	:: cx_lib;
	:: cx_bool;
	:: cx_math;
	:: cx_list;
	void
	)

\cx_html==
	(\=
	use_lib "html.fxl";
	:: cx_lib;
	:: cx_hex;
	:: cx_list;
	:: cx_format;
	void
	)

\cx_time==(\= use_lib "time.fxl"; cx_lib)

\cx_date==
	(\=
	use_lib "date.fxl";
	:: cx_lib;
	:: cx_math;
	:: cx_list;
	void
	)

\cx_run==
	(\=
	use_lib "run.fxl";
	:: cx_lib;
	:: cx_bool;
	:: cx_list;
	void
	)

\cx_read==
	(\=
	use_lib "read.fxl";
	:: cx_lib;
	:: cx_list;
	void
	)

\cx_read_csv==
	(\=
	use_lib "read_csv.fxl";
	:: cx_lib;
	:: cx_read;
	void
	)

\cx_read_ssv==
	(\=
	use_lib "read_ssv.fxl";
	:: cx_lib;
	:: cx_read;
	:: cx_list;
	void
	)

# Evaluate the user's script.
use_file script_name;
:: standard;

def "def" def;
def "if" if;
def "::" ::;

def "use" use;
def "use_file" use_file;

def "check" check;
def "default" default;

def "path_under" path_under;
def "dir_base" dir_base;
def "dir_local" dir_local;

def "trace" trace;
def "error" error;

def "TAB" TAB;
def "NL" NL;
def "CR" CR;
def "LF" LF;
def "QU" QU;

def "remember" remember;
def "cache" cache;
def "import" import;
def "import_as" import_as;

# Chain the libraries to load on demand.
:: cx_bool;
:: cx_math;
:: cx_list;
:: cx_format;
:: cx_indent;
:: cx_assoc;
:: cx_hex;
:: cx_html;
:: cx_time;
:: cx_date;
:: cx_run;
:: cx_read_csv;
:: cx_read_ssv;
void
