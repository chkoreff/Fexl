# Run the user's script given by argv[1] in the enhanced standard context.

# (check x d) = x if x is good, otherwise d.
\check=(\x is_defined x x)
# (default d x) = x if x is good, otherwise d.
\default=(\\d\x is_defined x x d)

\path_under=(\dir\name . (. dir "/") name)

# Establish paths based on command arguments.
\dir_base=(dirname; dirname; argv 0)
\script_name=(default ""; argv 1)

\trace=(fsay stderr)
\error=(\msg trace msg die)

# Define some extra functions.
\\extra=
(\=

# (if x y) = y if x is true, other I.
\if=(\\x\\y x y I)

\dir_local=(dirname script_name)

\NL="
"
\TAB="	"
\CR=(chr 13)
\LF=NL
\QU=~ "~

\run_benchmark=
	(\\show\\f
	fexl_benchmark f \val\steps\bytes
	show ["steps "steps" bytes "bytes]
	val
	)

\do_benchmark=(run_benchmark trace)
\show_benchmark=(run_benchmark say)

# Use a file in the directory which contains the user's script.
\use=(\name use_file; path_under dir_local name)

# Define key to refer to a context.
\defc=
	(\key\cx
	@\\self\\form
	cx; def key self; form
	)

# Use the context only if the form has open symbols.
# LATER 20231223 "::" is deprecated
\::=
	(\\cx\form
	is_closed form form;
	cx form
	)

define "defc" defc;
define "if" if;
define "::" ::;
define "use" use;

define "check" check;
define "default" default;

define "path_under" path_under;
define "dir_base" dir_base;
define "dir_local" dir_local;

define "trace" trace;
define "error" error;

define "TAB" TAB;
define "NL" NL;
define "CR" CR;
define "LF" LF;
define "QU" QU;

define "do_benchmark" do_benchmark;
define "show_benchmark" show_benchmark;
void
)

# Enhance the standard context to load libraries on demand.
\cx_std=
(
\dir_lib=(path_under dir_base "src/lib")
\use=(\name use_file; path_under dir_lib name)

\\bool=
	(\=
	evaluate cx_std;
	use "bool.fxl"
	)

\\math=
	(\=
	evaluate cx_std;
	use "math.fxl"
	)

\\list=
	(\=
	evaluate (chain bool; cx_std);
	use "list.fxl"
	)

\\format=
	(\=
	evaluate (chain list; chain math; chain bool; chain extra; cx_std);
	use "format.fxl"
	)

\\indent=
	(\=
	evaluate (chain format; chain extra; cx_std);
	use "indent.fxl"
	)

\\assoc=
	(\=
	evaluate (chain list; cx_std);
	use "assoc.fxl"
	)

\\hex=
	(\=
	evaluate (chain list; chain math; chain bool; cx_std);
	use "hex.fxl"
	)

\\html=
	(\=
	evaluate (chain hex; chain format; chain list; chain extra; cx_std);
	use "html.fxl"
	)

\\time=
	(\=
	evaluate (chain extra; cx_std);
	use "time.fxl"
	)

\\date=
	(\=
	evaluate (chain list; chain math; cx_std);
	use "date.fxl"
	)

\\run=
	(\=
	evaluate (chain list; chain bool; chain extra; cx_std);
	use "run.fxl"
	)

\\read=
	(\=
	evaluate cx_std;
	use "read.fxl"
	)

\\read_csv=
	(\=
	evaluate (chain read; chain extra; cx_std);
	use "read_csv.fxl"
	)

\\read_ssv=
	(\=
	evaluate (chain read; chain extra; cx_std);
	use "read_ssv.fxl"
	)

\load=
	(\module

	\path=(path_under dir_base (. "lib/"; . module ".so"))
	\lib=(dlopen path)
	is_void lib (error dlerror);

	\sym=(. "type_cx_" module)
	\entry=(dlsym lib sym)
	is_void entry (error ["Could not find symbol "sym]);

	entry ()
	)

chain cx_std;
define "load" load;
define "use_lib" use;
chain extra;
chain bool;
chain math;
chain list;
chain format;
chain indent;
chain assoc;
chain hex;
chain html;
chain time;
chain date;
chain run;
chain read_csv;
chain read_ssv;
void
)

# LATER 20231223 Keeping the old std for now.
\cx_std=
(
define "std" (@\\std resolve (define "std" std; cx_std));
cx_std
)

# Evaluate the user's script.
extend cx_std; use_file script_name
